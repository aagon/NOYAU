#+TITLE : Prise de notes TD 4I401 NOYAU
#+PROPERTY: header-args :mkdirp yes
#+STARTUP: inlineimages

Jonathan Lejeune(jonathan.lejeune@lip6.fr)

* TD 1 : 25/09/2019

Rappels systèmes et introduction au noyau Unix.

*** Question 1 : Quel est l'intérêt de déclarer une variable en register ?

Le temps d'accès à un registre est particulièrement bas. Si on sait qu'une variable devra être lue souvent, il peut être bon pour la vitesse d'exécution de mettre la variable dans le registre.

*** Question 2 : Que fait le programme suivant ?

#+BEGIN_SRC c
  f(from, to, count)
  int *from, *to;
  register count;

  {
	  register *f, *t;
	  f = from;
	  t = to;
	  do
		  ,*t++ = *f++;
	  while(--count);
  }
#+END_SRC

Le programme prend en paramètre deux pointeurs vers entier, et un entier count.

La copie locale du paramètre count doit être mis dans un registre si possible.

Le programme déclare ensuite deux pointeurs vers des entiers f et t, et demande à les mettre dans le registre. Il donne aux deux pointeurs ainsi créés les valeurs des deux paramètres from et to en entrée.

Le choix est judicieux : les variables appelées à être souvent modifiées (t, f, et count) sont mises dans un registre, celles destinées à n'être lues qu'une fois (from, to) se contentent de la mémoire centrale. Il n'est pas sûr que ce paramètre explicite soit nécessaire en 2019 : on pourrait estimer gcc capable de faire cette optimisation seul.

Le but du programme est de copier une certain nombre d'entiers contigus (exactement count entiers) de l'adresse from à l'adresse to.

L'incrémentation se fait après la copie : opérateur d'incrémentation post-fixé.

La décrémentation de count se fait avant le test du while : opérateur pré-fixé.

*** Question 3

Soit un tableau t d'une structure quelconque x

#+BEGIN_SRC c
  struct x {
	  int x_a;
  } t[MAX];
#+END_SRC


Ce code permet de parcourir la structure. (cpt stocke la somme des éléments du tableau).

#+BEGIN_SRC c
  int i, cpt;
  cpt = 0;
  for (i = 0; i < MAX; ++i) {
	  cpt += t[i].x_a;
  }
#+END_SRC

Ecrire un code qui permet de parcourir la structure en utilisant un pointeur vers la structure.

On doit pouvoir donner une condition d'arrêt. On peut soit déclarer une variable i, l'incrémenter en même temps que le pointeur, soit se servir de MAX (on ne sait pas si MAX est une variable locale ou globale, ou un alias, ou quoi que ce soit).



#+BEGIN_SRC c
  int cpt = 0;
  int i = 0;

  for (; i < MAX; p++, i++) cpt =+ p->x_a;
#+END_SRC

On part bien entendu du compte que MAX est connu dans la portée du code.

Bonne solution :

#+BEGIN_SRC c
  int cpt = 0;
  struct x *p;

  for (p = t; p < t + MAX; ++p) {
	  cpt += p->x_a;
  }
#+END_SRC

En effet, on peut garder l'adresse du début du tableau dans une autre variable. Quand la différence entre l'adresse dynamique et l'adresse de départ atteint MAX, on s'arrête.

*** Question 4

CPU : Central processing unit, fait les opérations arithmétiques et logiques, charge des zones de mémoire centrale dans sa mémoire personnelle, décharge sa mémoire personnelle dans la mémoire centrale.

Les registres sont le nom donné à la mémoire personnelle du processeur (accessible en un cycle).

RAM : La mémoire centrale, non-persistante (contenu disparaît à l'extinction de la machine). Permet d'accéder directement à un octet donné.

La mémoire morte est une zone de mémoire sans droits d'écriture dans laquelle on peut écrire le bios, par exemple.

Interruption (trappe) : Signal matériel (par opposition aux signaux, qui sont des entités logicielles), qui demande au système d'exploitation de reprendre la main pour faire des trucs. L'appel système est une sorte d'interruption logicielle.

Comment le CPU communique-t-il avec le matériel ? Via les interruptions et les contrôleurs (en fait des processeurs monotâche).

DMA (Direct Memory Access) : permet aux contrôleurs d'I/O d'accéder directement à des zones mémoire intéressantes (sans avoir besoin de passer par un tampon).

*** Question 5

La mémoire virtuelle, c'est la manière dont le processeur voit la mémoire, qui ne correspond pas à la mémoire physique.

C'est l'ensemble des adresses mémoire accessible par le processeur (qui dépend directement de la taille de son mot d'instruction). La correspondance entre les adresses de mémoire virtuelle et celles de mémoire physique est faite par le MMU (Memory Management Unit), une zone du processeur (ou un processeur spécifique). Le MMU dispose d'un cache appelé TLB (Translation Local-side Buffer).

Chaque processus dispose d'une table des pages qui stocke l'adresse des différents segments et pages, à laquelle le MMU accède, fait son calcul, et accède à l'adresse physique correspondante.

*** Question 6

La commutation de contexte :

La commutation de contexte est l'opération qui consiste à remplacer dans le processeurs et la mémoire centrale les données qui permettent l'exécution d'un processus, par celles qui permettent l'exécution d'un autre processus.

(Déjà, on ne choisit pas quand on commute, c'est le noyau)
La commutation se fait seule quand le quantum d'un processus est épuisé, à la suite d'une interruption d'horloge. Concrètement, lorsqu'une commutation commence, on copie le contexte processeur (les registres) et le contexte mémoire noyau (ce qui, dans la partie noyau de la mémoire, fait référence au processus courant) qqpart dans la mémoire centrale, et on charge à la place depuis un endroit en mémoire centrale le contexte processeurs et le contexte mémoire noyau.

*** Question 7

Les segments sont des zones de la mémoire spécifiques à un processus qui partagent les mêmes permissions. On les distingue traditionnellement entre les données (dans lesquelles on trouve le tas), accessibles en lecture et en écriture, le code (dans laquelle on va trouver les instructions du processus), accessible seulement en lecture, et la pile (pour les variables locales des fonctions), accessible en lecture et en écriture.

Le CPU y accède (s'il en a le droit !) via une instruction de son jeu d'instruction (load word, load byte), qui est transmise au MMU.

#+BEGIN_SRC c
  #include <stdio.h>

  int x = 37;

  void f(int a, int b)
  {
	  int i = 17;
	  int j = a + b + i;
	  printf("Hello : %d\n", i);
	  i = 45;
  }

  void g()
  {
	  int *i = (int*)malloc(sizeof(int) * 5);
	  f(3, 4);
  }

  int main()
  {
	  g();
	  return 0;
  }
#+END_SRC

Dessin du contexte mémoire :


|   | @code après g |      |
|---+---------------+------|
|   |       @malloc | f    |
|   | @code après f |      |
| b |             4 |      |
| a |             3 |      |
| i |            45 |      |
| j |            24 |      |
|   |               |      |
|   |               |      |
|   |               |      |
|   |               |      |
|---+---------------+------|
|   |               | tas  |
|---+---------------+------|
| x |            37 | glob |

*** Aparté

Processus : instance d'exécution d'un programme, et *son contexte et flux d'exécution*.

*** Question 8

En mode système, un certain nombre d'instructions spéciales et de registres spéciaux du processeurs sont accessibles en plus de celles accessibles en mode usager.

Il y a ces différences parce qu'on ne veut pas que l'usager puisse casser le matériel en accédant à des instructions ou des registres auquel il n'a pas droit.

Dans un processeur MIPS, il y a un registre système qui garde si l'exécution courante se fait en mode sytème ou en mode utilisateur.

PDP-11 ? [Pas traité ici]

Il y aussi une certaine zone de mémoire qui apparaît en mode S : en fait, une deuxième pile apparaît, la pile S, spécifique à un processus (distincte de la zone des données du systèmes, qui regroupe les variables globales à tous les processus).

La pile S sert à sauvegarder les appels de fonction du noyau, les variables locales des fonctions qui y sont exécutées (c'est une pile, après tout).

*** Question 9

Un appel système, c'est une interruption logicielle qui permet à un processus de faire appel à des ressources du système en mode noyau, auxquelles il est seulement possible d'accéder en mode noyau.

Appel système : fonction du système appelée à partir du mode utilisateur.

*** Question 10

Interruption (trappe) : Signal matériel (par opposition aux signaux, qui sont des entités logicielles), qui demande au système d'exploitation de reprendre la main pour faire des trucs.

*** Question 11

Il est très important qu'il y ait deux piles :
- on veut définir des autorisations différentes sur ces deux piles
- on veut que le processus en mode système puisse accéder à ses propres variables privées, éventuellement à des variables globales.

La pile S étant critique, elle peut être définie pour ne jamais être vide. On ne saurait donner les mêmes droits à un mode U (on ne fait pas confiance au programme).

Pourquoi une pile S par processus ?
Chaque processus a un contexte mémoire dans le noyau (dans la partie noyau de la mémoire).

Il faut sauver un contexte d'exécution des fonctions systèmes par processus. Précisément parce qu'on a la possibilité de sortir "pas proprement" du mode système, et donc que la pile S n'est pas propre, il en faut plusieurs, une par processus.

*** Question 12

Structure proc

p_flag : vecteur de bits, correspond à des états secondaires du processus
p_stat : vecteur de bits, correspondant à des états d'ordonnancement
p_textp : pointeur vers une structure de type texte, qui lui-même pointe vers le code du programme

On a une déclaration d'un tableau de cette structure : c'est une variable globale, avec NPROC nombre maximal de processus existants à n'importe quel moment.

(résultat de ps(1), avec option -aux)


Structure user

Tableaux de sauvegarde des registres, selon les cas.
Pointeur vers la structure proc correspondance.

u_ofile : tableau des descripteurs de fichier.
u_signal : Handler de signal
u_cdir : pointeur vers inode du répertoire courant

Une instance de la structure user existe pour chaque processus, elle est déclarée : la variable u est toujours peuplée de la structure du processus courant.

Informations moins importantes que dans la structure proc : peuvent être swappées, contrairement à proc.

Les informations de proc sont vitales, en particulier pour l'ordonnancement.

*** Question 13

Zone U :

Pile S + struct u (l'instance de la structure user)

Une seule zone U active fonctionnelle, à un moment précis.

Etat de la mémoire virtuelle à un moment précis :

| S     | Zone U          | Dynamique |
| S     | Code du système | Statique  |
|-------+-----------------+-----------|
| S + u | Pile            | Dynamique |
| S + u | Données (tas)   | Dynamique |
| S + u | Texte (Code)    | Dynamique |

Par dynamique, on entend que la région de mémoire physique vers laquelle pointe la zone change avec chaque commutation.
Le code du système reste toujours mappé vers la même zone de mémoire physique, quel que soit le processus exécuté.

u.u_procp->p_pid donne le pid du processus courant.

*** Question 14

PID pour chaque processus, pourquoi et comment attribué ?

Identification unique.

Compteur global, incrémenté à chaque création de processus (retour à partir d'une certaine valeur). On a la possibilité d'avoir plusieurs processus qui dans la vie de la machine ont eu le même pid (mais pas en même temps).

*** Question 15

BIOS what ?

Le code chargé au démarrage de la machine, teste le matériel, et lance l'exécution du système.



* TD 2 : 02/10/2019

On traite aujourd'hui de la synchronisation entre processus.

*** Question 1

On doit prendre garde à la fonction noyau sleep (à ne pas confondre avec l'appel système sleep(3) ou avec la commande shell sleep(1))

#+BEGIN_SRC c
  int sleep(caddr_t chan, int pri);
#+END_SRC

le processus appelant va se mettre en attente sur l'adresse chan (la ressource avec lequel on se synchronise), et se réveillera avec la priorité pri.

#+BEGIN_QUOTE
Give up the processor till a wakeup occurs on chan, at which time the process enters the scheduling queue at priority pri. The most important effect of pri is that when pri<=PZERO a signal cannot disturb the sleep ; if pri >PZERO signals will be processed. Callers of this routine must be prepared for premature return, and check that the reason for sleeping has gone away.
#+END_QUOTE

La fonction noyau wakeup :

#+BEGIN_SRC c
  int wakeup(caddr_t chan);
#+END_SRC

*** Question 3 bis

Seulement avec les fonctions sleep et wakeup, coder deux fonctions noyau newtemp et hot.

newtemp est appelé par la sonde, avec en paramètre  : pour faire quoi ?
On ne sait pas ce que les fonctions doivent faire.

hot est censée être appelée par d'autres processus, tourner en boucle, et se terminer dès lors que la température t passée en paramètre est dépassée.

Or hot ne peut pas connaître la température, il n'existe pas de fonction qui permettre d'obtenir la température.

La solution passe par les variables globales du noyau : en effet, newtemp peut se contenter d'enregistrer la température dans cette variable globale.

#+BEGIN_SRC c
  // TEMPHB est un define

  int cpt = 0;
  int curtemp = -20000;

  void newtemp(int t)
  {
	  curtemp = t;
	  if(cpt) wakeup(&curtemp);
  }

  void hot(int max)
  {
	  int oldmask = gpl();
	  spl(TEMPHB);

	  cpt++;
	  while (curtemp <= max) {
		  sleep(&curtemp,PRI_TEMP);
		  spl(TEMPHB);
	  }
	  cpt--;

	  spl(oldmask);
  }
#+END_SRC

L'addresse de tmp est prise au hasard : la seule contrainte, c'est que wakeup et sleep portent sur la même adresse : on aurait pu prendre n'importe quoi (mais préfère donner qqch de signifiant, ici )

cpt permet de ne pas avoir à parcourir toute la table : il compte le nombre de processus qui ont appelé hot : on ne lance wakeup que si on sait que le nombre de processus endormis (donné par cpt) dans l'adresse &curtemp est au moins 1.

On peut se permettre de ne pas protéger cpt parce que le noyau dont on parle est non-préemptif : on ne peut pas avoir cpt modifié par plusieurs processus en même temps, ils devraient tous être en mode noyau, or un processus en mode noyau ne lâche le processeur que si il se termine, ou ne sort du mode noyau que s'il le demande explicitement.

*** Analyse de sleep, wakeup et setrun

**** sleep

sleep est appelé par un processus qui souhaite s'endormir.

rp pointe vers la structure proc du processus courant :
#+BEGIN_SRC c
  register struct proc *rp = u.u_procp;
#+END_SRC

spl est le set priority level : fonction qui permet de masquer toutes les interruptions moins prioritaires.
CLINHB au moins aussi prioritaire que l'horloge : on fait ça pour changer des champs des structures proc, qui ont une influence sur l'ordonnanceur : *ces champs sont archi critiques*, c'est uniquement pour cette raison que le noyau se permet cette opération extrêmement violente de masquer toutes les interruptions, même l'interruption horloge.

#+BEGIN_QUOTE
Interruption, c'est comme si j'appelais une fonction sans l'avoir voulu : les données de la fonction handler de l'interruption sont empilées au-dessus (en-dessous en fait) des données du processus, ce qui fait que quand l'appel est fini, c'est comme si on dépilait : le pointeur de pile est directement au bon endroit pour reprendre l'execution directement où elle a été laissée.

Jonathan Lejeune
#+END_QUOTE

p_wchan est mis à chan l'adresse de l'événement à attendre, p_stat est mis à SLEEP, et p_pri est mis à pri.

Puis on appelle l'ordonnanceur (swtch()) : le moment où on lâche vraiment le processeur, le vrai moment où on s'endort.

dans l'alternative non-prioritaire :
runin signale au swapper que le processus est swappable, si il a envie.

On doit remettre la condition de traitement du signal après le switch, parce que le PC du processus est sur l'instruction de la ligne 42 : c'est la qu'on reviendra quand le processus récupèrera le processeur : donc on doit remettre l'instruction de traitement du signal avant de sortir de la fonction.

**** wakeup

On parcourt toute la table des processus à la recherche du processus qui attendait l'événement passé en argument.

**** setrun

p->p_wchan est une adresse, champ de la structure proc, et représente l'adresse de l'événement que le processus attent (en effet, les sleep et les wakeup sont fait sur une adresse) : il est mis à 0 si le processus n'attend rien.

runrun est une variable globale : si runrun > 0 alors il faudra appeler swtch dès qu'on sort du noyau : grâce à cette variable-là, le noyau peut ne pas être préemptif :
Si je réveille qqn de plus prioritaire que moi, je devrai lui laisser la main, *mais pas avant d'avoir fini ce que je voulais faire dans le noyau*.

Est-ce que le processus que je viens de réveiller a été swappé : si oui, on le rétablit dans la mémoire.

*** Question 4

spl définit le masquage des interruptions jusqu'à un certain niveau passé en paramètre.
gpl donne en valeur de retour le niveau de masquage des interruptions.

On utilise spl pour protéger les variables globales du noyau.

*** Question 5

Tout de suite, dans la fonction. Pour wakeup, c'est uniquement quand on sort du mode noyau.
Commutation se fait soit par abandon volontaire du processus, soit à la sortie du mode noyau.

*** Question 6

Processus qui s'occupe de faire le transfert des pages du processus de la mémoire vers le disque, ou vice versa.

*** Question 7

pri de sleep est la priorité à laquelle on veut s'endormir : il compte pour savoir si on est interruptible par signal, et il sert à l'ordonnanceur.

*Ce n'est pas le truc qui est passé en argument de spl !!!*. On passe en général à spl une valeur défini par un define en en-tête.

*** Question 8

Déjà décrit plus haut

*** Question bonus : question annale

L'objectif est de transmettre une valeur générée par un processus à un de ses fils.

On ajoute le champ int p_value à la structure proc.

S'il existe au moins 1 fils, la fonction void send_value(int val) sauvegarde la valeur val dans le champ p_value de la structure proc de l'appelant.
Cette valeur sera lue par un de ses fils en utilisant la fonction int recv_value(). Cette fonction renvoie la dernière valeur sauvegardée dans le champ p_value de la structure proc du père.

Un processus ne peut pas écrire une nouvelle valeur dans son champ p_value tant qu'un de ses fils n'a pas lu la valeur précédente. Dès lecture d'un fils, le père peut écrire une nouvelle valeur.

Si le père n'a pas écrit de nouvelle valeur, le fils qui appelle recv_value() doit s'endormir jusqu'à qu'une nouvelle valeur soit écrite. (ce qui signifie qu'une valeur ne saurait être lue deux fois)


En gros, on cherche à implémenter un tube, avec un problème de lecteur-rédacteur relativement classique :


On peut endormir le processus qui appelle la fonction send_value (le processus père, donc) après qu'il a mis à jour la valeur : il sera réveillé par le processus fils qui aura lu la valeur : il pourra sortir de la fonction send_value en train d'être exécutée, et à ce moment là en lancer une nouvelle.

Sinon, une variable globale indique si la valeur est lisible ou non, et elle bloque le père ou les fils selon les cas. Il faut protéger cette variable pendant son édition (sections critiques à déterminer.)

Si la variable globale est à 0 et que des fils veulent lire la variable, ils sont endormis. Au moment où on remet la variable à 1, on wakeup les fils, et on commande un coup d'ordonnanceur pour la sortie du mode noyau.

Si la variable globale est à 1 et que le père veut écrire sur la variable, il est endormi. Au moment où la variable est remise à 0, on wakeup le père, et on commande un coup d'ordonnanceur pour la sortie du mode noyau.

La vraie bonne manière de placer la variable, c'est de rajouter un champ dans la structure proc, appelé p_msgstate, initialisé à 0 pour tout le monde (pas de message).



#+BEGIN_SRC c
  void send_value(int val)
  {
	  register struct proc *moi = u.u_proc;
	  register struct proc *fils = NULL;

	  /*
	     vérifier si des fils existent. Si aucun existe, on termine la
	     fonction.
	  ,*/
	  for (fils = proc; fils < &proc[NPROC]; p++) {
		  if (fils->p.ppid == moi->p.pid) {
			  break;
		  }
	  }

	  // Si on a au moins un fils :
	  if (fils != &proc[NPROC] ) {

		  /* Apparemment pas nécessaire */
		  spl(PRIO);
		  /* Si j'ai déjà un message dans ma boîte d'envoi, je m'endors */
		  while (moi->p_msgstatedown) {
			  sleep(&(moi->p_msgstatedown), PRIORITE);
		  }

		  spl(PRIO); // Apparemment pas nécessaire
		  moi->p_value = val;
		  moi->p_msgstatedown = 1;
		  spl(NORMAL);

		  /* Réveiller les éventuels fils */
		  wakeup(&(moi->p_msgstatedown));
	  }

  }


  int recv_value()
  {
	  register struct proc *pere, moi = u.u_procp;

	  /*
	     La version précédente initialisait à moi la variable pere.
	     Or si ça se trouve, le père est avant le fils dans la table des
	     processus. C'est même le plus probable.
	     On vérifie tous les processus de la table des processus à la
	     recherche du père.
	     On suppose que le père ne meurt pas : très important
	  ,*/
	  for (pere = proc; pere < &proc[NPROC]; pere++) {
		  if (pere->p_pid == moi->p_ppid) {
			  break;
		  }
	  }

	  /*
	    Si le père n'a pas de message dans sa boîte d'envoi, on s'endort
	    sur l'adresse de son indicateur de message descendant
	  ,*/
	  while (!(pere->p_msgstatedown)) {
		  sleep(&(pere->p_msgstatedown), PRIORITE);
	  }

	  /*
	    Si le père a un message sur sa boîte d'envoi, on lui dit qu'il n'en a
	    plus, on le réveille s'il s'est éventuellement endormi en essayant
	    d'en mettre un autre, et on retourne la valeur du message.
	  ,*/

	  /* On veut que cette suite d'instructions soit atomique */
	  spl(PRIO);
	  pere->p_msgstatedown = 0;
	  wakeup(&(pere->p_msgstatedown));
	  spl(NORMAL);

	  return pere->p_value;
  }
#+END_SRC


* TD 3 : 09/10/2019

On traite aujourd'hui du traitement des signaux.

#+BEGIN_SRC c
  int kill(pid_t pid, int sig);
#+END_SRC

Il est bien clair qu'on parle ici de l'appel système, kill(2), et non pas de la fonction du noyau (dont l'implémentation est masquée de l'utilisateur, dépend de l'implémentation de unix).

Moyen rudimentaire de communication.

Traité par le processus !

Unix implémente la "boîte à diodes" des signaux entrants sous la forme d'un vecteur de bits. Diode allumée \to bit à 1.
(On ne sait donc pas si on a reçu un signal plusieurs fois, ce n'est pas une file d'attente)

On doit savoir quoi faire pour chaque signal : notion de *handler* (une fonction). Si aucun handler défini, on a un comportement par défaut.

Cette fonction est exécutée en mode utilisateur : en effet, ça a été codé par l'utilisateur.

Pour définir un handler de signal, on utilisait l'appel système signal(2):

#+BEGIN_SRC c
  typedef void (*sighandler_t)(int);

  sighandler_t signal(int signum, sighandler_t handler);
#+END_SRC

(De nos jours, on utiliserait plutôt sigaction, recommandé par la norme POSIX)

*signal redéfinit le handler de signal de manière provisoire (seulement la prochaine réception) !!*

On doit donc faire appel à signal dans le handler lui-même si on veut garder le handler pour les prochains traitements de signal.

Il y a deux signaux dont on ne peut pas redéfinir les handlers :
- SIGKILL
- SIGSTOP

#+BEGIN_QUOTE
The signals SIGKILL and SIGSTOP cannot be caught or ignored.

man page signal(2)
#+END_QUOTE

*** Question 1

#+BEGIN_SRC c
  #include <stdio.h>
  #include <unistd.h>

  void bonjour(int i)
  {
	  printf("Bonjour\n");
	  signal(SIGALRM, bonjour);
	  alarm(1);
  }

  int main()
  {
	  bonjour();
	  while (true) {
		  sleep(N);
	  }
	  return 0;
  }

#+END_SRC

*** Question 2

Différence signal ignoré et signal masqué.

Les deux ne prennent pas en compte le signal.

Ignorer : Je détruis ce signal (cette occurence du signal, mais pas forcément les occurences futures).
Masquer : retarder le traitement d'un signal.

(pas de masquage de signaux dans cette version du noyau.
Soit on les ignore, soit on les traite de manière précise avec un handler)

*** Question 2, TD 2

Rappels des opérateurs bit à bit en C :

AND bitwise : &

3 & 2 : 0b011 & 0b010 = 0b010 soit 2
(la puissance de 2 l'emporte toujours)

OU bitwise : |
3 | 2 = 0b011 | 0b010 = 0b011 = 3

NOT bitwise : ~
~2 = ~0b010 = 0b101 = 5

XOR bitwise : ^
3^2 = 0b011 ^ 0b010 = 0b001 = 1

SHIFT right : >>
5>>2 = 0b101>>2 = 0b001 = 1

SHIFT left : <<
5<<2 = 0b101<<2 = 0b100 = 4

Par exemple, si je veux mettre de manière certaine le ième bit à 1 du vecteur de bit v, je fais :
#+BEGIN_SRC c
  v |= (1<<(i-1));
#+END_SRC

Sinon, pour mettre le ième bit à 0 de manière sûre, je fais :
#+BEGIN_SRC c
  v = v & ~(1<<(i-1));
#+END_SRC

Tester si le ième bit est à 1 :
#+BEGIN_SRC c
  (v & (1<<(i-1)));
#+END_SRC

Tester si le ième bit est à 0 :
#+BEGIN_SRC c
  !(v & (1<<(i-1)));
#+END_SRC

*** Question prof

Trouver dans les structures unix les champs ou variables relatives aux signaux :

**** Dans la structure user (swappable) :

int u_signal[NSIG];

Or NSIG = 19, d'après le fichier d'en-tête sig.h

Donc on a un tableau de 19 entiers ??? (soient 19*32 bits : c'est bien plus qu'il n'en faut)

Contient les pointeurs vers les handlers, en fait. Les int étaient en fait des adresses.

**** Dans la structure proc (toujours en mémoire) :

long p_sig;

Un long est un entier de la taille d'un mot mémoire : ici, on va dire 32 bits : sachant qu'on a 19 signaux, ça suffit.

Les bits de p_sig constituent le vecteur de bits qui donne les signaux reçus par le processus.

short p_clktimer (un truc qui sert à compter le temps avant l'alarme).

*** Question 3

On vient d'y répondre.

*** Question 4

On est bien d'accord qu'on peut assimiler les signaux à des espèces d'interruptions logicielles.

Des différences majeures :
- Le traitement de l'interruption est toujours exécuté en mode noyau, mais en mode utilisateur dans le cas d'un signal.
- Emetteur est le matériel dans le cas de l'interruption, le noyau ou le processus dans le cas du signal.
- Mécanisme matériel, indépendemment du noyau dans le cas de l'interruption, et mécanisme logiciel dans le cas du signal.

*** Question 5

Quels sont les rôles des fonctions kill, psignal, issig, psig, fsig, sendsig et ssig ?

Pourquoi il n'y a pas d'argument à ces fonctions ?

Les arguments sont stockés dans la structure user.

Les fonctions en question sont exécutées sur la pile s : il n'y a rien dans cette pile, elles vont donc chercher leurs arguments dans la structure user du processus.

Le retour de la fonction système est stockée dans une zone R0, pour que la fonction utilisateur appelante puisse récupérer ce retour via son pointeur vers R0 dans sa structure user.

**** La fonction ssig()

On enregistre dans a le premier argument de la fonction utilisateur signal.

a représentera le numéro du signal.

On vérifie que a est valide (pas en dessous de 0, au dessus de 19, ni égale à SIGKIL) : s'il ne l'est pas, on sort de la fonction en rendant une erreur.

On remplit le retour de la fonction via la structure u_ar0

On met à jour le pointeur de fonction (ligne 15) : on met le deuxième argument de la fonction utilisateur signal dans le champ idoine de la structure user du processus.

(0 correspond à par défaut, 1 correspond à ignorer)

On remet à zéro la "diode" du signal.

**** La fonction kill()

On cherche dans la table des processus.

On doit intervertir le numéro du signal et le numéro du pid dans les noyaux modernes.

On met dans a le pid du processus à qui on veut envoyer un signal.

On boucle dans la table des processus :
- On vérifie que le p_stat du processus bouclé n'est pas NULL. (Il n'y a pas de processus dans ce champ)
- On vérifie que le pid du processus à signaler n'est pas 0, et que le pid du processus à signaler n'est pas le pid du processus bouclé (s'il ne l'est pas, on passe directement à la prochaine itération)
- Si le processus à signaler est 0 , ça veut soit dire qu'on veut s'adresser aux processus du même terminal, ou au processus swapper ou au processus init, on skip directement.
- On vérifie que (on n'est pas root AND on est bien proprio du processus) 

Si ces vérifications sont passées, on incrémente un compteur f et on lance la fonction psignal(p, u.u_arg[0]) (en n'oubliant pas que u.u_arg[0] contient le signal)

psignal a bien des arguments !
C'est normal, psignal n'est appelé que par d'autres fonctions noyau.

**** La fonction psignal(struct proc_p *p, int sig)

On vérifie que le signal existe bien.

On met le bit idoine du vecteur de bit du processus destinataire à 1 (quel que soit l'état du processus)

Si le processus n'est pas endormi avec une forte priorité, on le réveille.

**** La fonction issig()

Tant que le vecteur de bits du processus courant n'est pas exactement 0 (soit tant qu'on a pas vidé les signaux en attente) :

- On garde dans n le numéro du signal le plus bas (d'après l'analyse de la fonction fsig)

issig retourne le numéro du signal le plus bas reçu s'il y en a un, 0 sinon.

Ca veut dire que les signaux de numéro les plus bas sont traités de manière prioritaire : on peut avoir une famine pour les signaux les 

ligne 84 : si on a 1 au bit de poids faible, on sait qu'on veut ignorer : les adresses des handlers sont forcément alignées sur le mot mémoire, donc multiples de 4

Si on voulait ignorer (ligne 86), on remet le bit correspondant à 0.

**** La fonction fsig(struct proc *p)

Une fonction bien utile : retourne le signal de numéro le plus bas.

**** La fonction psig()

if(issig()) psig(); est la séquence exécutée systématiquement au retour en mode utilisateur.

Une version simplifiée, on ne va pas s'amuser à mettre tous les handlers par défaut.

psig récupère le numéro du signal à traiter dans n.
Il vérifie que ce n'est pas nul (ça ne devrait pas l'être si on suit la séquence plus haut)

Il remet le bit à 0.
Si le handler n'est pas 0 (càd si on ne veut pas utiliser le handler par défaut), on va lancer le handler, après l'avoir enlevé de la table des handlers (rappelons-nous, temporaire)

Si le handler est à 0, on fait les traitements par défaut.

**** La fonction sendsig(void *handler, int num)

La fonction charger d'appeler la fonction handler définie par l'utilisateur.

On manipule directement la pile de l'utilisateur pour le faire exécuter la fonction qu'il a lui-même écrite, à sa prochaine sortie du mode noyau.

Dans l'ordre :
- on enregistre dans sp le pointeur de pile enregistré du processus (u.u_ar0[SP]), pile augmenté d'un mot mémoire (en effet la pile croît de l'adresse la plus haute 0xffffffff vers l'adresse la plus basse 0x00000000).
- on alloue effectivement la mémoire de 0xffffffff jusqu'à sp (on imagine que la fonction grow alloue effectivement de la mémoire de 0xffffffff, ou un autre point de référence, à l'adresse qui lui est passée en paramètre)
- On enregistre cette nouvelle adresse modifiée dans le pointeur de pile enregistré du processus (u.u_ar0[SP]) (la pile est maintenant "officiellement" augmentée d'un mot mémoire)
- On enregistre dans ce mot mémoire qu'on vient d'allouer le PC (Program Count, AKA Compteur Ordinal, l'adresse le l'instruction à exécuter, tya compris fréro) enregistré du processus (u.u_ar0[PC])
- On met dans cette variable de sauvegarde du registre PC l'adresse de la fonction handler.

De cette manière, quand le processus repasse en mode utilisateur et récupère le processus, il exécute la fonction handler comme si c'était lui qui l'avait appelé.

*** Petit exo type examen

Implémenter un truc qui permet de masquer les signaux.

Requiert de modifier la fonction fsig.

Et de noter qqpart (dans la struct proc du processus) les indicateurs de signaux masqués.

On suppose dans la struct proc un vecteur de bits qui correspondent aux bits masqués.

Si le signal est masqué, fsig ne repère même pas le signal.

En C ANSI :

#+BEGIN_SRC c
  int fsig(struct proc *p)
  {
	  register int n, i, m, r;

	  n = p->p_sig;
	  m = m->p_mask; // Le vecteur des signaux masqués

	  r = n & ~m; // r correspond au vecteur des signaux non-masqués

	  for (i = 0; i < NSIG; ++i) {
		  if (r & 1) return (i);
		  r >>= 1;
	  }

	  return 0;
  }
#+END_SRC

Il faut aussi une fonction noyau pour ajouter un masque dans cette structure, une pour l'enlever. (assez trivial : on a juste un bit à bouger, juste des vérifications chiantes à faire avant)

Il faut aussi modifier la boucle while dans issig, de manière à éviter la boucle infinie (on ne teste plus while de p->p_sig, mais while de (p->p_pig & ~p->p_mask))


* TD 4 : 16/10/2019

On traite aujourd'hui de la question du temps et de l'ordonnancement.

*** Analyse des structures

L'interruption horloge, ou plutôt sa gestion, est écrite dans le fichier clock.

#+BEGIN_QUOTE
clock is called straight from real time clock interrupt.

Code source de Unix v6
#+END_QUOTE

La structure callo dans la fichier d'en-tête callo.h, permet de créer des appels réguliers.

On a un tableau statique de cette structure de taille NCALL, défini par une macro à la compilation.

On a dans le fichier param.h un define de l'inhibition des interruptions horloge.

Dans la structure proc, p_time, p_clktime, p_cpu.
p_time définit le temps pendant lequel on a été résident à un endroit précis en mémoire ou dans le swap (remis à 0 dès qu'on est swappé ou déswappé, mais incrémenté tout le temps).
p_clktime donne le temps avant l'alarme.
p_cpu donne l'utilisation du cpu.

On a une fonction accessible à l'utilisateur, time(2), définie comme suit.

#+BEGIN_SRC c
  #include <time.h>

  time_t time(time_t *tloc);
#+END_SRC

*** Question 1 : analyse des fonctions

La variable globale time fait appel au temps global, soit le nombre de secondes depuis 1/1/1970

**** clock()

On créé deux entiers externes (on fait appel à des variables déjà définies ailleurs).

Un pointeur vers une structure callo, dans un registre.

Un pointeur vers un entier, dans le registre.

On regarde le premier élément du tableau des callouts.

On parcourt le tableau des callouts :
Si c_time est inférieur à 0 et qu'il n'y a pas de fonction dans le champ c_func, on passe à l'élément suivant.
Sinon on décrémente le champ c_time et on sort de suite (plus de précisions dans l'explication de l'algorithme de callo)

idleflag est à 1 signifie qu'il n'y a aucun processus à élire.
Si l'usage du cpu d'un processus est en-dessous de 80, on incrémente cet usage.
L'usage du cpu est borné à 80.

On incrémente les stats, en vérifiant bien qu'on est pas idle.

On incrémente lbolt, puis on vérifie qu'il est supérieur ou égal à HZ, si c'est le cas on rajoute le flag WAKEUP.

HZ donne le nombre de ticks qu'on doit avoir en une seconde.
Quand lbolt arrive à HZ, on sait qu'on a passé une seconde.

On vérifie que le flag WAKEUP est vrai sur iaflags, et on appelle la fonction realtime(). (Ce n'est pas fait dans la fonction clock, mais ailleurs. On croira Jonathan Lejeune sur parole)

**** realtime()

On créé un pointeur vers une structure proc.

On remet lbolt à zéro.

On incrémente la variable globale time.

On incrémente runrun pour forcer une élection juste avant de sortir du mode noyau.

On réveille tout le monde à l'adresse lbolt (Quelqu'un qui veut être réveillé toutes les secondes, souvent des processus qui utilisent des drivers).

On parcourt la table des processus.

Si il y a bien un processus, on incrémente le resident time jusqu'à une limite de 127.

Si le temps jusqu'au prochain signal SIGALRM est 0, on traite le signal SIGALRM.

(utilisé par la fonction utilisateur alarm)
#+BEGIN_SRC c
  #include <unistd.h>

  unsigned int alarm(unsigned int seconds);
#+END_SRC


On divise le cpu usage par 2 : On applique le decay de l'algorithme d'ordonnancement de UNIX.

Si le processus a une prio faible, on remet à jour sa priorité selon l'algorithme unix, en appelant setpri.

Ensuite, si pression mémoire (testée par runin), on réveille le swapper.

**** setpri

En gros applique l'algorithme vu en cours, pour recréer un système de round robin sans queue.

*** Question 2

timeout permet de planifier l'exécution d'une fonction dans un certain temps.

Cette fonction prend en argument un pointeur vers une fonction, une chaîne de caractères pour les arguments et un entier qui donne le temps.

On créé deux pointeurs vers des structures callo.
Deux entiers, dont un dans le registre.

Le premier pointeur vers la structure callo est peuplé avec le premier élément de la table callout.

On met dans un des deux entiers le masquage des interruptions courant.
On met dans l'autre entier la valeur du paramètre.

On change le masquage des interruptions au niveau le plus puissant (CLINHB).

On parcourt la table callout.

Si on a bien une fonction dans la structure callo courante, et que le temps incrémentiel est en-dessous de t le temps passé en paramètre.

On applique l'algorithme décrit plus bas dans l'exercice.

En fait, l'idée est de ne noter que les temps cumulés à la prochaine fonction : il faut donc, lorsqu'on rajoute une fonction à exécuter plus tard, descendre dans le tableau en comparant aux temps de la fonction dans le tableau. Si c'est inférieur, c'est qu'on a trouvé notre place, auquel cas on shift tout le monde vers le bas. Si c'est supérieur, on décrémente le temps de la fonction à ajouter, et on compare au prochain élément.

De cette manière, lors d'une interruption horloge, on peut se contenter de ne décrémenter que le champ time du premier élément, ce qui mettra à jour tous les éléments du tableau :

#+BEGIN_QUOTE
The time in each structure entry is the number of HZ's more than the previous entry. In this way, decrementing the first entry has the effect of updating all entries
#+END_QUOTE

**** Petit exercice d'entraînement

On applique timeout(f, arg_f, 11) et timeout(g, arg_g, 5)

2 interruptions horloges

Puis timeout(h, arg_h, 3)

1 interruption horloge

Puis timeout(i, arg_i, 8)

Dessiner l'état du tableau callout à tout moment (on part du principe que la table est vide au début).


Tout est vide
| i | func | arg | time |
|---+------+-----+------|
| 0 |    0 |     |      |
| 1 |    0 |     |      |
| 2 |    0 |     |      |
| 3 |    0 |     |      |
| 4 |    0 |     |      |
| 5 |    0 |     |      |
| 6 |    0 |     |      |
| 7 |    0 |     |      |
| 8 |    0 |     |      |

| i | func | arg   | time |
|---+------+-------+------|
| 0 |    f | arg_f |   11 |
| 1 |    0 | '\0'  |  -11 |
| 2 |    0 |       |      |
| 3 |    0 |       |      |
| 4 |    0 |       |      |
| 5 |    0 |       |      |
| 6 |    0 |       |      |
| 7 |    0 |       |      |
| 8 |    0 |       |      |

| i | func | arg   | time |
|---+------+-------+------|
| 0 |    g | arg_g |    5 |
| 1 |    f | arg_f |    6 |
| 2 |    0 | '\0'  |  -11 |
| 3 |    0 |       |      |
| 4 |    0 |       |      |
| 5 |    0 |       |      |
| 6 |    0 |       |      |
| 7 |    0 |       |      |
| 8 |    0 |       |      |

| i | func | arg   | time |
|---+------+-------+------|
| 0 |    g | arg_g |    4 |
| 1 |    f | arg_f |    6 |
| 2 |    0 | '\0'  |  -11 |
| 3 |    0 |       |      |
| 4 |    0 |       |      |
| 5 |    0 |       |      |
| 6 |    0 |       |      |
| 7 |    0 |       |      |
| 8 |    0 |       |      |

| i | func | arg   | time |
|---+------+-------+------|
| 0 |    g | arg_g |    3 |
| 1 |    f | arg_f |    6 |
| 2 |    0 | '\0'  |  -11 |
| 3 |    0 |       |      |
| 4 |    0 |       |      |
| 5 |    0 |       |      |
| 6 |    0 |       |      |
| 7 |    0 |       |      |
| 8 |    0 |       |      |

| i | func | arg   | time |
|---+------+-------+------|
| 0 |    g | arg_g |    3 |
| 1 |    h | arg_h |    0 |
| 2 |    f | arg_f |    6 |
| 3 |    0 | '\0'  |  -11 |
| 4 |    0 |       |      |
| 5 |    0 |       |      |
| 6 |    0 |       |      |
| 7 |    0 |       |      |
| 8 |    0 |       |      |

| i | func | arg   | time |
|---+------+-------+------|
| 0 |    g | arg_g |    2 |
| 1 |    h | arg_h |    0 |
| 2 |    f | arg_f |    6 |
| 3 |    0 | '\0'  |  -11 |
| 4 |    0 |       |      |
| 5 |    0 |       |      |
| 6 |    0 |       |      |
| 7 |    0 |       |      |
| 8 |    0 |       |      |

| i | func | arg   | time |
|---+------+-------+------|
| 0 |    g | arg_g |    2 |
| 1 |    h | arg_h |    0 |
| 2 |    f | arg_f |    6 |
| 3 |    i | arg_i |    0 |
| 4 |    0 | '\0'  |  -11 |
| 5 |    0 |       |      |
| 6 |    0 |       |      |
| 7 |    0 |       |      |
| 8 |    0 |       |      |

*** Rappel

A chaque interruption d'horloge :
- clock()
- if(iaflag & WAKEUP)  realtime()
- if(iaflag & CALOUT) restart()

*** Coder la fonction restart

#+BEGIN_SRC c
  int restart()
  {
	  struct callo *p1;
	  struct callo *p2;

	  while ((&callout[0]->c_time == 0) &&
		 (&callout[0]->c_func != 0)) {

		  p1 = &callout[0];
		  ,*(p1->c_func)(p1->c_arg);

		  p2 = p1 + 1;

		  while ((p2-1)->c_func != 0) {
			  (p2-1)->c_func = p2->c_func;
			  (p2-1)->c_arg = p2->c_arg;
			  (p2-1)->c_tim = p2->c_tim;
			  ++p2;
		  }
	  }

	  return;
  }
#+END_SRC

On n'a pas besoin de masquer des interruptions, parce qu'on est déjà dans une interruption horloge.

*** Coder une fonction noyau sleep qui ne se servirait que de delay

On a bien compris ce que delay faisait : il demande à être réveillé dans ticks ticks et s'endort.

#+BEGIN_SRC c
  sleep()
  {
	  int sec = u.u_args[0];
	  int ticks = sec * HZ;
	  int expected_date = time + sec;
	  delay(ticks);

	  if (time < expected_date) {
		  u.u_ar0[R0].expected_date - time;
	  } else {
		  u.u_ar0[R0] = 0;
	  }
  }
#+END_SRC

*** Question type examen

Implémenter untimeout(ident)

#+BEGIN_SRC c
  untimeout(int ident)
  {
	  struct callo *p1;
	  struct callo *p2;

	  p1 = &callout[O];

	  while (p1->c_func != 0) {
		  if (p1->c_ident == ident) {
			  p2 = p1 + 1;
			  p2 ->c_time += p1->c_time;

			  while ((p2-1)->c_func != 0) {
				  (p2-1)->c_func = p2->c_func;
				  (p2-1)->c_arg = p2->c_arg;
				  (p2-1)->c_ident = p2->c_ident;
				  (p2-1)->c_time = p2->c_time;
				  ++p2;
			  }
		  }
		  ++p1;
	  }
  }
#+END_SRC


* TD 5 : 23/10/2019

On va parler aujourd'hui du mécanisme de commutation.

Comment faire pour passer d'un processus à un autre ?

La commutation, c'est le mécanisme du noyau qui permet le partage du temps processeur entre les processus (temps partagé).

*** Rappels de l'automate d'état

Un processus passe du mode élu S au mode prêt quand il a incrémenté runrun et qu'il perd l'élection.

Un processus passe du mode élu S au mode bloqué avec sleep().

Un processus passe du mode élu U au mode zombie avec exit().

*** La commutation

#+BEGIN_THEOREM
*Un processeur (ses registres visibles du processeur) ne connaît pas les adresses physiques*, mais seulement des adresses virtuelles.

Il existe certains registres (très peu) qui doivent connaître des adresses physiques.
#+END_THEOREM

Le compteur ordinal, en particulier, ne connaît que des adresses virtuelles.

Du point de vue du processeur, la mémoire ressemble à ça :

|---------|
| Zone U  |
|---------|
| OS      |
|---------|
| Pile U  |
|---------|
| Données |
|---------|
| Code    |
|---------|

Chacune des zones est mappée vers une zone de mémoire physique (la correspondance est dans la table des pages).
La zone OS est toujours mappée vers le même endroit (elle ne bouge pas dans la mémoire physique, et elle n'est jamais swappée).

On a un registre qui donne l'adresse *physique* de la table des pages (les registres systèmes ont le droit de stocker directement des adresses physiques).

p_addr est l'adresse physique de la zone mémoire du processus.


La commutation consiste donc en :
- Changer la traduction virtuelle-physique (opération de pointeur simple, peu coûteux)
- Changer le pointeur de pile (registres visibles de l'utilisateur)

On part du principe que tout processus qui est potentiellement élu avait appelé switch avant de perdre le processeur. Donc en fait, quand je change la table des pages et le pointeur de pile, en fait je sors de la fonction *pile au bon endroit* : la valeur à mettre dans le compteur ordinal, qu'on trouve en pointe de pile pour être retrouvée à chaque sortie de fonction, est déjà la bonne puisque c'est celle qu'on avait mis à l'appel de switch au temps jadis.

Le pointeur d'instruction reste donc le même (il doit bien exécuter le reste de la fonction switch), mais on sait qu'on retrouvera le bon.

#+BEGIN_THEOREM
Deux adresses physiques contigües en nombre ne sont pas forcément contigües en matériel
#+END_THEOREM

Segments mémoire d'un processus :
- Code
- Pile U
- Zone U (pile S plus struct u)
- Données (tas et variables globales)

Puis, ailleurs, dans la zone système de la mémoire :
- Code de l'OS
- Données de l'OS, variables globales
- Structures de données pour l'OS.

La fonction retu :
Prend en paramètre l'adresse physique de la mémoire des processus.
Remplace la table des pages courante par la table des pages adressée physiquement par le paramètre (en vrai, uniquement la partie de la table des pages qui mappe les adresses virtuelles de la zone U vers les adresses physiques. Le reste du travail est fait par une autre fonction, sureg())

**** Fichier text.h

x_daddr : l'adresse du bloc disque.
x_caddr : l'adresse du segment mémoire du texte.

x_count : nombre de références totales (quand c'est 0, on sait qu'on peut flush).
x_ccount : nombre de références par des processus chargés (quand c'est 0, on sait qu'on peut swap : on ramènera du disque en même temps que le processus qu'on ramènera).

*** Question 3

**** Analyse de swtch()

On déclare un pointeur (static : enregistré dans le segment de données plutôt que dans la pile, survit donc à la fonction, mais reste visible uniquement par celle-ci) vers une structure proc.
Deux entiers (dans le registre).
Un pointeur vers une structure proc (dans le registre).

Seulement si p est le pointeur NULL, on fait pointer p vers le premier élément du tableau (la struct proc du processus 0, le scheduler).
Si p n'est pas le pointeur NULL, alors il garde la valeur qu'il avait lors du dernier appel à swtch() : c'est pour cette raison qu'on a déclaré p avec le mot-clé static. Pourquoi on fait ça ? On veut que la recherche reprenne exactement là où on l'a interrompu la dernière fois.

On met le pointeur de pile dans la structure u du processus qui a appelé swtch (dans le champ u_rsav, plus spécifiquement).

savu sauvegarde le SP dans la structure passée en paramètre.

On charge dans les registres du processeur les registres sauvegardés en mémoire du scheduler (le processus 0) : u a changé.

aretu permet de changer le pointeur de pile sans commuter (retu en un peu moins puissant).

On a un label de loop :
runrun est remis à 0
On fait pointer rp vers p, p vers NULL, et n vers 128.

On regarde tous les processus prêts et chargés en mémoire.

On garde le plus prioritaire.

Quand on sort de la boucle après avoir décrémenté i NPROC fois (on ne fait plus d'un tour complet), on a un pointeur p vers la processus à élire.

Si j'ai trouvé aucun processus p, alors p est resté à NULL.
Je remets p à rp, j'attends la prochaine interruption, et je réessaye.

Si j'en ai un, j'alias son pointeur statique dans rp.

Je charge le registre qui donne l'adresse de sa table des pages.

sureg() : en fait, retu ne fait que changer la zone U, sureg() change les autres segments genre la pile U, les données et le code. On n'a pas fait sureg à l'entrée dans le processus 0 car ce processus n'a pas de pile, ni de code, ni de données (il écrit dans la pile du noyau, il manipule des données globales du noyau, et son code est celui du noyau)

ligne 69-72 : réponse dans deux épisodes.
Avant-goût : On vérifie si le champ p_flag du processus sélectionné porte le flag SSWAP (est-ce que le processus a été créé dans le swap).
Si oui, alors on l'enlève, et on change le pointeur de pile vers la valeur enregistrée dans u_ssav la dernière fois qu'on a appelé savu (on sait qu'on a appelé savu, parce qu'on part du principe que tous processus qui a existé a appelé swtch(), et que swtch() fait un appel à savu).

Si on a élu un processus, c'est qu'il est chargé en mémoire. Donc ce flag SSWAP peut être enlevé et on l'enlève. En fait, c'est lié au fork. Quand un processus fork, s'il n'y a pas assez de mémoire pour le nouveau processus, on peut immédiatement swap out le fils. Pendant ce swap-là, on enregistre le pointeur de pile du fils dans son u_ssav, avant de le swap out.

Si ensuite par chance il s'est fait reswap in, on rétablit son pointeur de pile. (pas encore très clair)

return(1) : Si jamais le processus que j'ai élu, c'est la première fois qu'il est là (via un fork). Permet de dire vrai. [en vrai, on verra ça dans 2 séances].

*** Passage mode U - mode S (et vice versa)

Une trappe : Fonction appelée quand on passe du mode U au mode S. Cette fonction est définie au niveau matériel, elle est écrite par le constructeur.

*** Question 5

Appel système (la fonction utilisateur) doit renseigner :
- La fonction système qu'on veut exécuter (en fait le numéro de l'appel système dans un registre)
- On met les arguments à passer à la fonction système dans un tableau (et on met l'adresse dans un registre)
- On appelle la fonction trap() : défini au niveau du matériel (changement de contexte, sp dans la zone U), on passe en mode S (on change la valeur d'un processus), déroutement vers l'appel système

- On sauvegarde les registres utilisateurs dans u.u_ar0
- On va chercher les arguments et on les met dans u.u_arg
- Réinitialiser le u_error
- savu(u.u_qsav) : on garde un SP vers là où on est dans la fonction trap
- On appelle la fonction noyau

A la sortie de la fonction noyau :

- Checker runrun, swtch() le cas échéant
- Checker les signaux, psig() le cas échéant
- Copier u.u_error dans errno

- On restaure les registres qu'on a sauvegardés avant de passer en mode S.

On revient en mode U (PC vers code U).

L'interruption, ce sera un sous-ensemble :
- TRAP : changement de contexte, déroutement
- Sauvegarde des registres utilisateurs
- Exécution "handler" interruption
- Vérification runrun
- Vérification signaux
- Restauration des registres utilisateurs

#+BEGIN_THEOREM
Quand on réveillé par un signal, on sort du mode noyau : on dépile toute la pile S jusqu'à TRAP, et on sort de TRAP
#+END_THEOREM

Dans les structures rsav, ssav, qsav sont enregistrés des SP qui correspondent à des états différents de quand ils ont été enregistrés (ssav, on l'a déjà vu, sert à enregistrer le SP juste avant de se faire swap).


* TD 6 : 20/11/2019

Petite reprise de l'épisode précédent, on a pu reprendre la fonction swtch().

On traite aujourd'hui de la naissance des processus.

*** Question 1

Modifier le programme pour créer N processus fils. Chaque processus doit incrémenter la variable a, afficher la nouvelle valeur et se terminer. Le processus original attend la fin des N fils puis affiche a avant de se terminer.

On part du principe, même si la consigne ne le précise pas, que le père doit créer les N fils avant de les attendre. On doit avoir, à un point dans le programme, N fils existant en même temps.

Notre solution :

#+BEGIN_SRC c
  #include <stdio.h>
  #include <sys/types.h>
  #include <unistd.h>
  #include <stdlib.h>
  #include <sys/wait.h>

  #define N 10

  int main(int argc, char *argv[])
  {
	  int a = 10;

	  for (int i = 0; i < N; ++i) {
		  if (fork() == 0) {
			  ++a;
			  printf("%d\n", a);
			  exit();
		  }
	  }

	  for (int i = 0; i < N; ++i) {
		  wait();
		  printf("%d\n", a);
	  }

	  return 0;
  }
#+END_SRC

Quelles sont les valeurs affichées pour chacun des processus ?

11 : Chaque fils incrémente sa propre version de la variable a.

Le père affiche par contre systématiquement 10. C'est sa propre version de la variable a qu'il regarde, et celle-ci n'a été modifiée par personne.

*** Fonctionnement de fork()

On enregistre dans deux registres visibles du processeur deux pointeurs p1 et p2 vers une structure proc.

On sauve dans p1 le pointeur vers le processus courant.

On itère dans la table des processus à la recherche d'une entrée libre (telle que p_stat == NULL), on fait pointer p2 vers cette entrée.
Si on est à la fin de la table des processus et qu'on a pas trouvé de place libre, on retourne une erreur, on met une valeur d'erreur sur la pile utilisateur pour la valeur de retour de l'appel système côté user.

Sinon, on appelle newproc qui créé le fils, et en fonction de son retour (newproc retourne 1 pour le processus fils, et 0 pour le processus père), on retourne 0 (respectivement le pid du fils créé) et on initialise des champs (les champs avec les stats de temps) de la structure proc du fils à 0 (respectivement on ne fait rien).

Ce fonctionnement est basé sur la capacité de newproc à retourner une valeur distincte selon si le processus courant est le père et le fils.

On va se pencher maintenant sur le fonctionnement de la fonction qui fait le gros du travail, la fonction newproc.

*** Fonctionnement de newproc

La fonction newproc déclare dans sa pile deux entiers (a1 et a2), deux pointeurs vers une struct proc p et up.

Elle demande aussi un pointeur vers une struct proc rpp dans un registre, ainsi qu'un pointeur vers un entier et un entier.

Un des pointeurs vers struct proc dans la pile est initialisé à NULL.

La variable globale mpid est incrémentée.

Le pointeur dans le registre *parcourt inconditionnellement la table des procs*, et ce dans sa totalité. Si il trouve une place libre, il stocke son adresse dans le pointeur précédemment initialisé à NULL.

Si le pid d'un des éléments de la table est égal à mpid, on incrémente mpid, et on recommence le parcours de la table *du début*.

Si on sort de la boucle et que le pointeur initialisé est toujours à NULL, c'est qu'on a trouvé aucune entrée libre. Dans ce cas, on a une panique noyau, Cette situation ne peut pas arriver parce qu'on a vérifié avant l'appel à newproc l'existence d'une entrée libre.

À la sortie de cette boucle, on a si tout va bien un pointeur vers une entrée libre, ainsi que dans mpid une valeur qu'on sait avec certitude n'être égale à aucun des pid présents dans la table (ni même à aucun des pid reliquats des entrées libres, ce qui ne semble pas nécessaire à première vue).

Le pointeur vers entier qu'on a stocké dans le registre est cast en pointeur vers struct proc (est-ce seulement possible en C K&R, pas sûr...) pour stocker un pointeur vers le processus courant (donc le père qui s'apprête à créer son fils).

Le pointeur vers le processus courant est aussi stocké sur la pile.

Dans l'entrée libre de la table des procs qu'on a sélectionné, on met l'état SRUN, le flag SLOAD, l'UID du père, le [pseudo-]terminal du père, le nice, le pointeur vers la zone de texte, mpid dans le champ pid, et le pid du père dans le champ ppid, et 0 dans le champ du temps résident.

Les descripteurs de fichier du père sont passés au fils (le pointeur vers entier casté en pointeur vers struct proc redevient pointeur vers entier au passage).

Le compteur de références vers la zone de texte est incrémenté, de même que le compteur de références par des processus chargés en mémoire.

Le compteur de références à l'inode du répertoire courant (qui est un fichier, ne l'oublions pas) est incrémenté.

On sauvegarde le pointeur de pile courant dans la structure u_rsav du processus courant.

Le pointeur vers la structure proc du processus courant est sauvée (ligne 100), le pointeur vers la structure proc de la structure user du processus courant est écrasé avec celui vers la structure proc du fils : le père prend l'identité de son fils.

Le champ taille mémoire du processus fils prend la taille de son père.

On tente d'allouer dans la mémoire la place correspondant à cette taille mémoire. Deux cas possibles :

**** L'allocation échoue

Si cette allocation échoue pour manque de place, on écrit alors l'image mémoire du processus dans le swap : on fait passer l'état du processus père à SIDL, on stocke dans le champ d'adresse de l'image mémoire du fils celle du père.

On sauvegarde le pointeur de pile courant dans la structure u_ssav du père, on copie (sans effacer, attention !) l'image mémoire du père dans le swap (la copie sera utilisée par le fils).

Ici, faisons bien attention : le pointeur de pile courant qu'on a sauvé à la ligne 114 fait bien partie des données qu'on est en train de copier. À la fin de cette copie, le fils a bien le pointeur de pile de là où on est maintenant sauvé dans sa propre structure u_ssav aussi.

Le pointeur de pile courant qu'on avait sauvé à la ligne 99 fait aussi partie des données qu'on a copié.

On met l'état du fils à SSWAP, et on remet l'état du père à SRUN.

**** L'allocation réussit

- Soit cette allocation réussit, on copie simplement tous les blocs un à un de l'image mémoire du père vers la zone mémoire juste allouée pour le fils.

**** Sortie de l'alternative

À ce moment, le père récupère son identité.

On sort de la fonction, avec la valeur de retour 0.

**** Et le fils ?

À ce moment, le fils n'a encore jamais jamais eu le processeur de sa vie, il n'a exécuté aucune instruction (en particulier aucune instruction de cette fonction)

Où est-ce que le fils va apparaître ? Autrement (mieux) dit, où est la toute première instruction que le fils va exécuter ? Vous l'avez compris, dans le code de swtch() : le registre pointeur d'instruction du processeur est à la ligne 57 du code de swtch() juste avant que le fils "obtienne le processeur".

Transportons-nous maintenant dans le code de swtch(), à la ligne 57. Le processeur exécute l'appel à la fonction retu.

On le rappelle, la fonction retu permet d'activer la partie de la table des pages qui décrit la correspondance entre l'adresse virtuelle et l'adresse physique de la zone U. Autrement dit, permet (entre autres) de changer de structure u.

retu implique entre autres un appel à aretu, qui copie simplement de l'entier passé en paramètre vers le registre pointeur de pile du processeur. La fonction retu appelle aretu sur u_rsav.

À la fin de cette instruction, le pointeur de pile dans le registre idoine du processeur est mis à la valeur qui lui avait été passée à la ligne 99 de la fonction newproc. Ce pointeur de pile est une adresse virtuelle, dont la correspondance avec l'adresse physique est donnée par la table des pages : l'appel à retu garantit que cette adresse se résout vers l'adresse physique de la pile du fils et non du père (parce que l'adresse virtuelle du pointeur de pile du père et de celui du fils peuvent parfaitement être encore la même : on a eu une copie simple à 115 ou à 124 de newproc).

Donc à ce moment là, le registre pointeur de pile contient l'adresse du mot de la pile qui stocke le mot d'instruction correspondant à l'instruction de la ligne 15 de la fonction fork (l'instruction de comparaison, plus précisément : l'instruction C de la ligne 15 se transcrit en au moins de deux instructions assembleur : un instruction de stockage de la valeur de retour, et une instruction de comparaison de la valeur de retour à 1 : c'est bien de cette deuxième instruction qu'il est question ici).

Le processeur appelle sureg, ce qui lui permet d'activer le reste des correspondances de la table des pages (celles qui donnent la pile U, les données, le code).

Si le processus sort maintenant de la fonction, il sort avec la valeur de retour 1, et il se retrouve à devoir exécuter la deuxième partie de l'instruction de la ligne 15 de la fonction fork(), et ainsi de suite.

Si le processus avait été créé dans le swap (il en a depuis été ramené, vous vous en doutez bien), on enlève son flag SSWAP, et on charge dans le registre pointeur de pile l'adresse sauvée à la ligne 114 de newproc.

Donc à ce moment là, exactement comme plus haut, le registre pointeur de pile contient l'adresse du mot de la pile qui stocke le mot d'instruction correspondant à l'instruction de comparaison de la ligne 15 de la fonction fork.

Si le processus sort maintenant de la fonction (et il le fait), il sort avec la valeur de retour 1, et il se retrouve à devoir exécuter la deuxième partie de l'instruction de la ligne 15 de la fonction fork(), et ainsi de suite.

Quoiqu'il se soit passé avec ces histoires de swap à la naissance ou non, on veut qu'à la sortie de la fonction swtch(), le processus fils aille exécuter l'instruction de comparaison de la ligne 15, et ignore tout le bruit potentiellement arbitraire qui a pu être mis dans la pile entre temps. Les sauvegardes de pointeur de pile dans la fonction newproc() et ses chargements à la fin de swtch() répondent à cette exigence.

De surcroît, la valeur de retour de swtch() sert à distinguer le père et le fils. Le père arrive à l'instruction de comparaison de la ligne 15 de fork() en venant de newproc, donc avec une valeur de retour de 0. Le fils arrive à cette même instruction depuis swtch(), donc avec une valeur de retour de 1.

*** Apartés et aphorismes nuls

#+BEGIN_THEOREM
Le processeur ne voit pas de processus, il ne voit que des instructions.
#+END_THEOREM

#+BEGIN_THEOREM
Un processus n'obtient pas le processeur, c'est le processeur qui va chercher ses instructions dans le contexte d'un processus plutôt que d'un autre.
#+END_THEOREM

*** La fonction exit()

On alloue, dans les registres visibles du processeur, un pointeur vers un entier, un entier, un pointeur vers une structure proc.

On enlève le flag STRC au processus courant.

On met 1 à tous les éléments de la table u_signal du processus courant, ce qui revient donc à effectivement ignorer tous les signaux reçus par le processus courant (cf. les lignes 84 et 85 de la fonction issig).

On ferme tous les descripteurs de fichier ouverts, et on supprime leurs référence de la table des fichiers.

On décrémente le compteur de références vers l'inode du répertoire courant.

On décrémente aussi le compteur de références vers le segment de code (opération qu'on ne voit pas ici, voir aparté et version Lions du code).

On alloue dans le swap 1 bloc. Si cette opération échoue, panique.

Cette allocation dans le swap est une allocation mémoire, mais qui se fait sur une section du disque. Elle ne réserve aucun espace dans la mémoire, juste un bloc sur le disque.

La fonction getblk réserve de la place dans le cache tampon de la mémoire, place dans laquelle est copiée le bloc du disque dont l'adresse est passée en deuxième paramètre (le premier paramètre est le matériel). La valeur de retour de la fonction est un pointeur vers une structure buf.

Grâce à cette fonction, on obtient un pointeur vers une structure buf, qui contient l'adresse en mémoire centrale (dans le cache tampon plus précisément) du bloc cache tampon copié depuis le bloc disque (ici, le processus courant fait une entrée/sortie, il va donc s'endormir).

La fonction bcopy nous permet de copier les n octets depuis l'adresse adr1 vers l'adresse adr2, adr1 étant le premier paramètre, adr2 étant le deuxième, et n étant le troisième. Elle permet aussi probablement de marquer le bloc mémoire comme modifié, devant donc être synchronisé vers le disque à un moment opportun (pure hypothèse, en vrai on n'en sait rien).

Comme là c'est un peu urgent, on demande explicitement la synchronisation du bloc tampon cache vers le bloc disque. (là techniquement, le processus courant fait une entrée/sortie, il va donc s'endormir).

On garde un pointeur dans le registre vers la structure proc du processus courant.

On vide de la mémoire toute l'image mémoire du processus (sa structure u, sa pile S [la raison pour laquelle exit() ne manipule jamais jamais la pile mais seulement du registre ou des variables globales], sa pile U, ses données)

Dans la structure proc du processus courant (qui, on le rappelle, ne fait pas partie de l'image mémoire du processus), le champ p_addr qui stocke l'adresse du premier octet du premier bloc de l'image mémoire contient maintenant l'adresse du bloc du swap qui contient la structure u du processus courant.

On fait passer l'état du processus courant à SZOMB.

On parcourt la table des procs. On réveille son père si on le trouve.

Si on trouve son père, on notifie tous ses fils que leur nouveau père est le processus de pid 1, le processus init, et on les réveille si ils sont stoppés ou tracés (? leur p_state égale SSTOP). Ensuite, on appelle swtch(), appel dont on ne retournera jamais.

Si à la sortie de la boucle qui parcourt la table des procs, on a pas trouvé son père, on se voit adopté par le processus init, puis renvoyé dans la boucle.

**** Aparté entrées/sorties

En deux endroits au moins le processus fait une entrée/sortie. Il va perdre le processeur au moins deux fois. On a bien pris garde à ne tenir aucun compte des signaux et à laisser l'état du processeur à SRUN. On est bien sûr que le processus va récupérer le processeur au même endroit à partir d'un certain moment.

**** Aparté segment texte (ou code)

Lors de la création d'un processus, on prend soin d'incrémenter le compteur de référence de la structure texte vers laquelle pointe p_textp.

Il n'y a pas, dans le code de exit présenté ici, de décrémentation symétrique, ce qui est incohérent.

Dans la version Lions du code, on a effectivement un appel à xfree(), placé entre la ligne 16 et la ligne 19 de notre version du code. Cette fonction se charge de décrémenter les compteurs de référence vers la zone de texte, de libérer la mémoire et le swap si ces compteurs tombent à 0.

L'image mémoire d'un processus ne comprend donc pas son segment de code.

*** Question 6

Implémenter le code de wait, selon la spécification POSIX, ou plutôt selon la simplification Lejeune de la spécification POSIX.

La fonction doit :

- Si le processus appelant n'a pas de fils, ni zombie ni vivant (aussi bien prêt que élu que bloqué/endormi), la fonction se termine, l'exécution n'est pas bloquante.
- Si le processus appelant a au moins un fils zombie, indépendemment de son nombre de fils actifs, il écrit la valeur de retour de son fils (le premier dans l'ordre de la table des processus) dans le pointeur qui lui a été passé en paramètre. Si aucun pointeur, ou le pointeur NULL lui a été passé, il n'écrit rien. Puis il libère le bloc dans lequel la structure u du zombie a été stockée lors du exit() du fils, il libère l'entrée correspondant à la structure p du fils, et il retourne enfin le pid du fils. Dans ce cas, la fonction se termine, l'exécution n'est pas bloquante.
- Si le processus appelant n'a pas de fils zombie, mais au moins un fils vivant, l'exécution est bloquante : le processus appelant s'endort, jusqu'à ce que son fils devienne zombie, moment auquel il reprend l'alternative 2.

Voilà notre solution : elle est a priori assurée de fonctionner.

On n'est en revanche pas capable de tester si l'utilisateur a effectivement passé un paramètre à l'appel système côté user wait(2). Il y a bien toujours quelque chose à u.u_arg[0], mais on n'a aucune manière de vérifier que cette chose interprétée comme un entier veut bien dire quelque chose, qu'elle fait référence à une adresse légale du processus, etc... Tout ça est quand même très important : quand on exécute le code de wait, on est en mode système, on peut écrire dans toutes les adresses sans peine, potentiellement écraser des informations importantes.

On a deux manières de régler le problème. Soit on décide de ne pas écrire la valeur de retour du fils à une adresse mémoire, mais dans un registre, et à l'appel système côté utilisateur d'aller l'y chercher (suppose d'être sûr que ce registre ne sera pas écrasé entre temps). C'est, d'après le Lions, la solution choisie par MM. Thompson et Ritchie.

Soit l'appel système côté utilisateur, avant le passage en mode noyau, s'assure de ce que l'appel système côté noyau trouvera en u.u_arg[0] une adresse valable si une adresse est spécifiée (erreur et sortie prématurée sinon), une adresse "poubelle" (par exemple l'adresse d'un entier de sa propre pile destinée à être dépilée après le retour du mode noyau) si rien ou NULL est passé en paramètre. D'après ce qu'on sait, c'est la manière dont fonctionnent les unix modernes : la fonction API utilisateur est en fait une fonction d'enveloppe qui vérifie que toutes les hypothèses faites par l'appel système côté noyau sont respectées.

Tout ça pour dire : dans notre implémentation, on écrira directement dans une adresse mémoire, en faisant toutes les hypothèses de correction sur cette adresse.

La fonction utilise un goto, *ce qui n'est pas un problème*. Tant qu'on arrive à garder les choses simples, il n'y a aucun problème à utiliser goto.

#+BEGIN_SRC c
  wait()
  {
	  register struct proc *p;
	  struct buf *b;
	  int f = 0;

  loop:
	  for (p = &proc[0]; p != &proc[NPROC]; p++) {
		  if ((p->p_stat & SZOMB) &&
		      (u.u_procp->pid == p->p_ppid)) {
			  u.u_ar0[R0] = p->p_pid;

			  /* Fonctionne aussi avec bread() */
			  b = getblk(swapdev, p->p_addr);
			  ,*(u.u_arg[0]) = b->b_addr->u_ar0[R0];
			  brelse(b);

			  mfree(swapmap, 1, p->p_addr);

			  p->p_stat = NULL;

			  /* Ici on copie le Lions */
			  /* On n'aurait pas pensé à faire ce nettoyage */
			  p->p_pid = 0;
			  p->p_ppid = 0;
			  p->p_sig = 0;
			  p->p_ttyp = 0;
			  p->p_flag = 0;

			  return;
		  }

		  if ((p->p_stat & SRUN) &&
		      (u.u_procp->pid == p->p_ppid)) {
			  f++;
		  }
	  }

	  if (f) {
		  sleep(u.u_procp, PWAIT);
		  goto loop;
	  }

	  u.u_ar0[R0] = -1;
	  return;
  }
#+END_SRC


* TD 7 : 27/11/2019

Aujourd'hui, le fonctionnement du swapper.

On commence à avoir fait le tour du fonctionnement des processus, on se rapproche petit à petit du fonctionnement du disque et du cache tampon.

*** Les caractéristiques du swapper

Le swapper est le processus d'id 0.

Il est toujours en mémoire, il s'exécute toujours en mode système : il n'exécute que du code système.

Sa priorité est la priorité PSWAP la plus prioritaire (minimale, donc). C'est la priorité qu'il a tout le temps (pas seulement quand il est endormi). On sait donc que quand on réveille le swapper :
- On force une nouvelle élection (runrun++, cf. code de setrun), dès la sortie du mode noyau.
- On sait qu'on va élire le swapper.

*** runin et runout

Dans quelles conditions le swapper s'endort-il ?

- Soit la mémoire est pleine et on a rien à évincer immédiatement : on s'endort sur runin (cf. ligne 129).
- Soit la mémoire est non pleine, mais on n'a rien à rappeler : on s'endort sur runout (cf. ligne 45).
- On s'endort bien entendu aussi pendant les entrées/sorties bloquantes, même si ça ne se verra pas forcément dans le code de cette fonction-là précisément.

Dans quelles conditions le swapper est-il réveillé ?
- Quand ses entrées/sorties sont finies, on imagine qu'il est réveillé par une interruption matérielle, même si on ne le voit pas encore dans le code.
- On veut ramener quelque processus du swap vers la mémoire centrale, par exemple quand on le réveille (cf. ligne 102 de setrun()), ou alors on vient d'évincer quelque processus, et on veut que le swapper vérifie s'il peut ramener quelque autre processus (cf. ligne 212 de xswap()) : on réveillera alors l'adresse runout.
- On veut signaler au swapper qu'on vient de s'endormir, et qu'on se porte volontaire pour se faire évincer (cf. ligne 40 de sleep()), ou alors une seconde vient de passer, et on doit réveiller le swapper de toute façon (cf. ligne 84 de realtime) : on réveillera alors sur l'adresse runin.

#+BEGIN_THEOREM
On réveille sur runout quand on veut rappeler quelque processus du swap vers la mémoire centrale.

On réveille sur runin quand on veut évincer quelque processus de la mémoire centrale vers le swap.

"in" et "out" sont toujours "in" le swap et "out" le swap.
#+END_THEOREM

*** Apartés et aphorismes nuls

#+BEGIN_THEOREM
Une écriture peut être asynchrone, une lecture ne le peut pas, à moins d'inventer ce qu'on lit.
#+END_THEOREM

*** Algorithme de la fonction sched()

Cette fonction est la boucle principale du processus swapper. Le processus est toujours dans cette fonction (ou des fonctions appelées par celle-ci) quand il a la main.

L'algorithme n'est pas si compliqué que ça, mais il est long. Le plus clair est encore de faire un automate.


#+NAME: swapper
#+BEGIN_SRC dot

  digraph Swapper {

	  node [shape = box];

	  /* Cette option sert à empêcher les courbes */
	  /* splines = "line"; */
	  /* Cette option sert à pénaliser les cassures */
	  /* edge [weight = 1]; */

	  /* Noeuds */

	  subgraph tests
	  {
		  loop [label = "loop:"];
		  finduserswapin [label = "∃ processus prêt\n à rappeler ?"];
		  corealloc [label = "Assez de mémoire ?"];
		  finduserswapout1 [label = "∃ processus endormi, non système,\n n'ayant rien verrouillé, à évincer ?"];
		  userswapinwait [label = "Processus à rappeler\n en swap depuis 3s+ ?"];
		  finduserswapout2 [label = "∃ processus prêt, non système,\n n'ayant rien verrouillé, en mémoire\n depuis 2s+, à évincer ?"];
	  }

	  subgraph sleeps
	  {
		  sleeprunout [label = "sleep(&runout)"];
		  wakeupgotoloop [label = "wakeup();goto loop"];
		  sleeprunin [label = "sleep(&runin)"];
		  sleeprunout -> wakeupgotoloop [style = dotted];
		  wakeupgotoloop -> sleeprunin [style = dotted, dir="back"];
	  }


	  subgraph swaps
	  {
		  swapinuser [label = "Rappel"];
		  gotoloop [label = "goto loop"];
		  swapoutuser [label = "Éviction"];
		  swapinuser -> gotoloop;
		  gotoloop -> swapoutuser [dir="back"];
	  }

	  /* Début */
	  loop -> finduserswapin;

	  /* Première alternative */
	  finduserswapin -> sleeprunout [label = "Non"];
	  finduserswapin -> corealloc [label = "Oui"];

	  /* Deuxième alternative */
	  corealloc -> swapinuser [label = "Oui"];
	  corealloc -> finduserswapout1 [label = "Non"];

	  /* Troisième alternative */
	  finduserswapout1 -> swapoutuser [label = "Oui"];
	  finduserswapout1 -> userswapinwait [label = "Non"];

	  /* Quatrième alternative */
	  userswapinwait -> finduserswapout2 [label = "Oui"];
	  userswapinwait -> sleeprunin [label = "Non"];

	  /* Dernière alternative */
	  finduserswapout2 -> sleeprunin [label = "Non"];
	  finduserswapout2 -> swapoutuser [label = "Oui"];

	  /* Forme */
	  {rank = min; swapinuser gotoloop swapoutuser };
	  {rank = same; loop finduserswapin corealloc finduserswapout1 userswapinwait finduserswapout2 };
	  {rank = same; sleeprunout  wakeupgotoloop  sleeprunin };
  }

#+END_SRC


#+CALL: swapper[:engine graph-easy :results output verbatim drawer :cmdline --as_boxart]()

#+RESULTS:
:RESULTS:
                              ┌−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−┐
                              ╎                  tests                   ╎
                              ╎                                          ╎
                              ╎ ┌──────────────────────────────────────┐ ╎
                              ╎ │                loop:                 │ ╎
                              ╎ └──────────────────────────────────────┘ ╎
                              ╎   │                                      ╎
                              ╎   │                                      ╎
                              ╎   │                                      ╎
┌−−−−−−−−−−−−−−−−−−−−┐        ╎   │                                      ╎
╎       sleeps       ╎        ╎   │                                      ╎
╎                    ╎        ╎   ▼                                      ╎
╎ ┌────────────────┐ ╎        ╎ ┌──────────────────────────────────────┐ ╎
╎ │ sleep(&runout) │ ╎  Non   ╎ │           ∃ processus prêt           │ ╎
╎ │                │ ╎ ◀───── ╎ │             à rappeler ?             │ ╎
╎ └────────────────┘ ╎        ╎ └──────────────────────────────────────┘ ╎
╎   :                ╎        ╎   │                                      ╎
╎   :                ╎        ╎   │ Oui                                  ╎
╎   :                ╎        ╎   │                                      ╎
╎   :                ╎        ╎   │                                      ╎        ┌−−−−−−−−−−−−−−−┐
╎   :                ╎        ╎   │                                      ╎        ╎     swaps     ╎
╎   :                ╎        ╎   ▼                                      ╎        ╎               ╎
╎   :                ╎        ╎ ┌──────────────────────────────────────┐ ╎  Oui   ╎ ┌───────────┐ ╎
╎   :                ╎        ╎ │          Assez de mémoire ?          │ ╎ ─────▶ ╎ │  Rappel   │ ╎
╎   :                ╎        ╎ └──────────────────────────────────────┘ ╎        ╎ └───────────┘ ╎
╎   :                ╎        ╎   │                                      ╎        ╎   │           ╎
╎   :                ╎        ╎   │ Non                                  ╎        ╎   │           ╎
╎   :                ╎        ╎   │                                      ╎        ╎   │           ╎
╎   :                ╎        ╎   │                                      ╎        ╎   │            −−−−−−−−−−−−−−−−−−┐
╎   :                ╎        ╎   ▼                                      ╎        ╎   ▼                              ╎
╎   :                ╎        ╎ ┌──────────────────────────────────────┐ ╎        ╎ ┌───────────┐       ┌──────────┐ ╎
╎   :                ╎        ╎ │  ∃ processus endormi, non système,   │ ╎        ╎ │ goto loop │       │ Éviction │ ╎
╎   :                ╎        ╎ │ n'ayant rien verrouillé, à évincer ? │ ╎ ─┐     ╎ │           │ ◀──── │          │ ╎ ◀┐
╎   :                ╎        ╎ └──────────────────────────────────────┘ ╎  │     ╎ └───────────┘       └──────────┘ ╎  │
╎   :                ╎        ╎   │                                      ╎  │     ╎                                  ╎  │
╎   :                ╎        ╎   │                                      ╎  │     └−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−┘  │
╎   :                ╎        ╎   │                                      ╎  │      Oui                    ▲             │
╎   :                ╎        ╎   │ Non                                  ╎  └─────────────────────────────┘             │
╎   :                ╎        ╎   ▼                                      ╎                                              │
╎   :                ╎        ╎ ┌──────────────────────────────────────┐ ╎                                              │
╎   :                ╎        ╎ │         Processus à rappeler         │ ╎                                              │ Oui
╎   :                ╎        ╎ │         en swap depuis 3s+ ?         │ ╎ ─┐                                           │
╎   :                ╎        ╎ └──────────────────────────────────────┘ ╎  │                                           │
╎   :                ╎        ╎   │                                      ╎  │                                           │
╎   :                ╎        ╎   │ Oui                                  ╎  │                                           │
╎   :                ╎        ╎   ▼                                      ╎  │                                           │
╎   :                ╎        ╎ ┌──────────────────────────────────────┐ ╎  │                                           │
╎   :                ╎        ╎ │    ∃ processus prêt, non système,    │ ╎  │                                           │
╎   :                ╎        ╎ │ n'ayant rien verrouillé, en mémoire  │ ╎  │                                           │
╎   :                ╎        ╎ │       depuis 2s+, à évincer ?        │ ╎ ─┼─────  ────────────────────────────────────┘
╎   :                ╎        ╎ └──────────────────────────────────────┘ ╎  │
╎   :                ╎        ╎                                          ╎  │
╎   :                ╎        └−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−┘  │
╎   :                ╎            │                                         │
╎   :                ╎            │ Non                                     │ Non
╎   :                ╎            ▼                                         │
╎   :                 −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−┐  │
╎   :                                                                    ╎  │
╎   :                           ┌──────────────────────────────────────┐ ╎  │
╎   :                           │            sleep(&runin)             │ ╎ ◀┘
╎   :                           └──────────────────────────────────────┘ ╎
╎   :                             :                                      ╎
╎   :                             :                                      ╎
╎   :                             ▼                                      ╎
╎   :                           ┌──────────────────────────────────────┐ ╎
╎   └·························▶ │          wakeup();goto loop          │ ╎
╎                               └──────────────────────────────────────┘ ╎
╎                                                                        ╎
└−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−┘
:END:

#+CALL: swapper[:engine graphviz :file ./TD7/swapper.png :cmdline -Tpng -Grankdir=LR]()

#+RESULTS:
[[file:./TD7/swapper.png]]

On se permet aussi de fournir une analyse cursive :

La fonction masque toutes les interruptions.

La recherche d'un éventuel processus *prêt* à rappeler se fait par le parcours de la tables des processus. Celui qui a le temps résident en disque le plus long est gardé.

Si on en trouve pas, on s'endort sur la variable runout. On se réveillera quand un processus se réveille, ou quand un processus se fait évincer par xswap.

Si on en trouve un, on va essayer de le ramener : pour cela, il faut vérifier si il y a assez de place en mémoire centrale. On prend pour cela la taille de l'image mémoire du processus, donnée par p_size, *éventuellement augmentée de la taille du segment texte du processus*. En effet, si ce processus à ramener ne partage son segment de texte avec aucun autre, alors ce dernier n'est pas chargé en mémoire, et il faut le ramener aussi. Sa taille doit donc être prise en compte dans la vérification de ce qu'il reste assez de place.

Inversement, si le segment de texte est déjà chargé, pas besoin de le ramener, donc pas besoin de tenir compte de sa taille lors de la vérification.

Si l'allocation fonctionne :

On charge éventuellement le texte, si il n'est pas déjà chargé.
On charge les autres structures du processus.
On libère du disque ce qu'on vient de copier dans la RAM.
On ajoute le flag "chargé en mémoire" (SLOAD) au processus courant.
On réinitialise le temps résident.
On retourne au début.

Si cette allocation ne fonctionne pas :

On cherche une victime. On regarde si il existe un processus chargé, non système, qui n'a rien verrouillé, endormi ou stoppé.

Si on en a trouvé un, on l'évince, et on retourne au début.

Sinon, on vérifie si le temps résident du processus qu'on veut faire rentrer est strictement moins que trois secondes. Si c'est le cas, on s'endort sur runin (on se réveillera toutes les secondes, ou quand un processus s'endort, et on reviendra au début).

Si le temps résident du processus qu'on veut faire rentrer est de trois secondes ou plus, on étend la recherche aux processus prêts, et on prend celui dont le temps résident en mémoire est le plus grand. Si le temps résident en mémoire de ce processus est plus de deux secondes, on le vire, sinon on s'endort sur runin (on se réveillera sous les mêmes conditions).

On remarque que le processus swapper, dont le code principal est donné par la fonction sched(), ne se termine jamais. Il ne fait que s'endormir pour laisser la main à d'autres.

*** Les fonctions swap et xswap

La fonction swap est la fonction qui va effectivement faire les entrées/sorties en lecture comme en écriture.

Les lignes 212-215 sont là si ce n'est pas swapper qui a appelé la fonction xswap. Si c'est bien lui, en effet, il n'a pas besoin de se réveiller lui-même. En revanche, si c'est (par exemple) newproc qui a appelé xswap, alors le swapper doit être réveillé.

*** Exercice type examen

Hypothèses :

- Aucun processus autre que swapper ne change d'état.
- Pas d'autoswap
- Pas de nouveau proc/pas de exit.
- La mémoire est pleine.
- Les I/O << 1 seconde.
- Le processus p[3] vient de passer à l'état run, via setrun.

La question :

Dans combien de temps le processus d'indice 3 reviendra en mémoire ?
Donnez l'état de la table des procs au moment où il revient.

On a besoin de la taille de la mémoire : on peut la déduire de ce qu'elle est pleine, donc de la somme des tailles des processus résidents en mémoire.

| index | pwchan | p_time | p_pri | p_stat | p_flag      | p_size | p_addr (RAM ou SWAP) |
|-------+--------+--------+-------+--------+-------------+--------+----------------------|
|     0 | runout |    ... |       | SSLEEP | SSYS&SLOAD  |      0 | RAM                  |
|     1 |        |     44 |       | SSLEEP | SSYS&SLOAD  |      3 | RAM                  |
|     2 |        |     10 |       | SSLEEP | SLOCK&SLOAD |      2 | RAM                  |
|     3 |        |      2 |       | SRUN   | NULL        |     14 | SWAP                 |
|     4 |        |      3 |       | SRUN   | SLOAD       |      2 | RAM                  |
|     5 |        |      0 |       | SRUN   | SLOAD       |      4 | RAM                  |
|     6 |        |      0 |       | SSLEEP | SLOAD       |      5 | RAM                  |
|     7 |        |      4 |       | SSLEEP | SLOAD       |      4 | RAM                  |
|     8 |        |      0 |       | SRUN   | SLOAD       |      6 | RAM                  |

Taille de la mémoire : 26

La liste des opérations :

- Etat initial, place dispo 0
- On vire p[6] (premier processus endormi non système), place dispo 5

| index | pwchan | p_time | p_pri | p_stat | p_flag      | p_size | p_addr (RAM ou SWAP) |
|-------+--------+--------+-------+--------+-------------+--------+----------------------|
|     0 | runout |    ... |       | SRUN   | SSYS&SLOAD  |      0 | RAM                  |
|     1 |        |     44 |       | SSLEEP | SSYS&SLOAD  |      3 | RAM                  |
|     2 |        |     10 |       | SSLEEP | SLOCK&SLOAD |      2 | RAM                  |
|     3 |        |      2 |       | SRUN   | NULL        |     14 | SWAP                 |
|     4 |        |      3 |       | SRUN   | SLOAD       |      2 | RAM                  |
|     5 |        |      0 |       | SRUN   | SLOAD       |      4 | RAM                  |
|     6 |        |      0 |       | SSLEEP | ~SLOAD      |      5 | SWAP                 |
|     7 |        |      4 |       | SSLEEP | SLOAD       |      4 | RAM                  |
|     8 |        |      0 |       | SRUN   | SLOAD       |      6 | RAM                  |

- On vire p[7] (premier processus endormi non système), place dispo 9

| index | pwchan | p_time | p_pri | p_stat | p_flag      | p_size | p_addr (RAM ou SWAP) |
|-------+--------+--------+-------+--------+-------------+--------+----------------------|
|     0 | runout |    ... |       | SRUN   | SSYS&SLOAD  |      0 | RAM                  |
|     1 |        |     44 |       | SSLEEP | SSYS&SLOAD  |      3 | RAM                  |
|     2 |        |     10 |       | SSLEEP | SLOCK&SLOAD |      2 | RAM                  |
|     3 |        |      2 |       | SRUN   | NULL        |     14 | SWAP                 |
|     4 |        |      3 |       | SRUN   | SLOAD       |      2 | RAM                  |
|     5 |        |      0 |       | SRUN   | SLOAD       |      4 | RAM                  |
|     6 |        |      0 |       | SSLEEP | ~SLOAD      |      5 | SWAP                 |
|     7 |        |      0 |       | SSLEEP | ~SLOAD      |      4 | SWAP                 |
|     8 |        |      0 |       | SRUN   | SLOAD       |      6 | RAM                  |

- Le temps résident du processus à ramener en mémoire est de 2, donc inférieur à 3, donc on s'endort une seconde.

Temps attendu : 1 seconde.
Etat au réveil.

| index | pwchan | p_time | p_pri | p_stat | p_flag      | p_size | p_addr (RAM ou SWAP) |
|-------+--------+--------+-------+--------+-------------+--------+----------------------|
|     0 | runout |    ... |       | SRUN   | SSYS&SLOAD  |      0 | RAM                  |
|     1 |        |     45 |       | SSLEEP | SSYS&SLOAD  |      3 | RAM                  |
|     2 |        |     11 |       | SSLEEP | SLOCK&SLOAD |      2 | RAM                  |
|     3 |        |      3 |       | SRUN   | NULL        |     14 | SWAP                 |
|     4 |        |      4 |       | SRUN   | SLOAD       |      2 | RAM                  |
|     5 |        |      1 |       | SRUN   | SLOAD       |      4 | RAM                  |
|     6 |        |      1 |       | SSLEEP | ~SLOAD      |      5 | SWAP                 |
|     7 |        |      1 |       | SSLEEP | ~SLOAD      |      4 | SWAP                 |
|     8 |        |      1 |       | SRUN   | SLOAD       |      6 | RAM                  |

- On rééssaie : le temps résident du candidat est passé à 3, donc on cherche une victime vivante.
On prend celle dont le temps résident en mémoire est le plus long : p[4].
Le temps résident de p[4] est bien supérieur à 2, on peut le virer.
Place disponible 11.

| index | pwchan | p_time | p_pri | p_stat | p_flag      | p_size | p_addr (RAM ou SWAP) |
|-------+--------+--------+-------+--------+-------------+--------+----------------------|
|     0 | runout |    ... |       | SRUN   | SSYS&SLOAD  |      0 | RAM                  |
|     1 |        |     45 |       | SSLEEP | SSYS&SLOAD  |      3 | RAM                  |
|     2 |        |     11 |       | SSLEEP | SLOCK&SLOAD |      2 | RAM                  |
|     3 |        |      3 |       | SRUN   | NULL        |     14 | SWAP                 |
|     4 |        |      0 |       | SRUN   | ~SLOAD      |      2 | SWAP                 |
|     5 |        |      1 |       | SRUN   | SLOAD       |      4 | RAM                  |
|     6 |        |      1 |       | SSLEEP | ~SLOAD      |      5 | SWAP                 |
|     7 |        |      1 |       | SSLEEP | ~SLOAD      |      4 | SWAP                 |
|     8 |        |      1 |       | SRUN   | SLOAD       |      6 | RAM                  |

- On essaie encore. Le candidat vivant à virer est p[5]. Ce processus a un temps résident en mémoire strictement inférieur à 2, on s'endort.

Temps attendu : 2 secondes
Etat au réveil.

| index | pwchan | p_time | p_pri | p_stat | p_flag      | p_size | p_addr (RAM ou SWAP) |
|-------+--------+--------+-------+--------+-------------+--------+----------------------|
|     0 | runout |    ... |       | SRUN   | SSYS&SLOAD  |      0 | RAM                  |
|     1 |        |     46 |       | SSLEEP | SSYS&SLOAD  |      3 | RAM                  |
|     2 |        |     12 |       | SSLEEP | SLOCK&SLOAD |      2 | RAM                  |
|     3 |        |      4 |       | SRUN   | NULL        |     14 | SWAP                 |
|     4 |        |      1 |       | SRUN   | ~SLOAD      |      2 | SWAP                 |
|     5 |        |      2 |       | SRUN   | SLOAD       |      4 | RAM                  |
|     6 |        |      2 |       | SSLEEP | ~SLOAD      |      5 | SWAP                 |
|     7 |        |      2 |       | SSLEEP | ~SLOAD      |      4 | SWAP                 |
|     8 |        |      2 |       | SRUN   | SLOAD       |      6 | RAM                  |

- On essaie encore : le candidat vivant à virer est p[5].
Son temps résident en mémoire est de 2, on peut le virer.

Place dispo 15.

| index | pwchan | p_time | p_pri | p_stat | p_flag      | p_size | p_addr (RAM ou SWAP) |
|-------+--------+--------+-------+--------+-------------+--------+----------------------|
|     0 | runout |    ... |       | SRUN   | SSYS&SLOAD  |      0 | RAM                  |
|     1 |        |     46 |       | SSLEEP | SSYS&SLOAD  |      3 | RAM                  |
|     2 |        |     12 |       | SSLEEP | SLOCK&SLOAD |      2 | RAM                  |
|     3 |        |      4 |       | SRUN   | NULL        |     14 | SWAP                 |
|     4 |        |      1 |       | SRUN   | ~SLOAD      |      2 | SWAP                 |
|     5 |        |      0 |       | SRUN   | ~SLOAD      |      4 | SWAP                 |
|     6 |        |      2 |       | SSLEEP | ~SLOAD      |      5 | SWAP                 |
|     7 |        |      2 |       | SSLEEP | ~SLOAD      |      4 | SWAP                 |
|     8 |        |      2 |       | SRUN   | SLOAD       |      6 | RAM                  |

On peut swap in le processus.

| index | pwchan | p_time | p_pri | p_stat | p_flag      | p_size | p_addr (RAM ou SWAP) |
|-------+--------+--------+-------+--------+-------------+--------+----------------------|
|     0 | runin  |    ... |       | SSLEEP | SSYS&SLOAD  |      0 | RAM                  |
|     1 |        |     46 |       | SSLEEP | SSYS&SLOAD  |      3 | RAM                  |
|     2 |        |     12 |       | SSLEEP | SLOCK&SLOAD |      2 | RAM                  |
|     3 |        |      0 |       | SRUN   | SLOAD       |     14 | RAM                  |
|     4 |        |      1 |       | SRUN   | ~SLOAD      |      2 | SWAP                 |
|     5 |        |      0 |       | SRUN   | ~SLOAD      |      4 | SWAP                 |
|     6 |        |      2 |       | SSLEEP | ~SLOAD      |      5 | SWAP                 |
|     7 |        |      2 |       | SSLEEP | ~SLOAD      |      4 | SWAP                 |
|     8 |        |      2 |       | SRUN   | SLOAD       |      6 | RAM                  |

Place dispo : 1
swapper s'endort sur runin.

*** Exercice de l'an dernier

Taille de la mémoire = 20.

Table des processus :

| index | p_pid | p_uid | p_flag      | p_stat | p_size | p_time | p_wchan  | p_pri |
|-------+-------+-------+-------------+--------+--------+--------+----------+-------|
|     0 |     0 |     0 | SSYS&SLOAD  | SSLEEP |      2 |    120 | runout   | PSWP  |
|     1 |     1 |     0 | SSYS&SLOAD  | SSLEEP |      4 |    125 | &proc[1] | PWAIT |
|     2 |   101 |  1000 | SLOAD       | SSLEEP |      1 |      1 | &toto    | 50    |
|     3 |   102 |  1000 | SLOCK&SLOAD | SSLEEP |      3 |     10 | &toto    | 50    |
|     4 |   103 |  1000 | SLOAD       | SRUN   |     10 |      0 |          | 50    |
|     5 |   104 |  1000 | NULL        | SLEEP  |     10 |     10 | &toto    | 50    |
|     6 |   105 |  1000 | NULL        | SLEEP  |     10 |      5 | &toto    | 50    |

Pas de fork, pas de exit, pas de wakeup(&toto)

Temps d'exécution du code noyau (appels système, swapper, init) et E/S sont négligeables.
Segments de texte non pris en compte.

**** Question 1

On suppose qu'à t=0 le proc 103 exécute kill(104, SIGUSR1) et entre dans une boucle infinie d'instructions ne comportant pas d'appel système.
Montrer que le swapper va se réveiller.

kill la fonction API utilisateur est exécutée, donc le code de kill appel système est exécuté.
Dans le code de kill, on a un appel à psignal.
psignal va appeler setrun sur 104
104 n'a pas le flag SLOAD, wakeup est donc appelé sur &runout.
Or le processus swapper est endormi sur runout. Le processus swapper sera élu lors de la prochaine élection, qui va arriver tout de suite (runrun++).

Les filtres de priorité sont bien respectés [à spécifier si on veut tous les points].

**** Question 2

A quelle date 104 va-t-il commencer à s'exécuter pour traiter le signal ?

On part du principe que le swapper commence à s'exécuter à t=0.
Mémoire occupée : 20 Mémoire totale : 20.

Réponse : t = 2 [on refera les calculs pendant les révisions].

On exécute le code de swapper. On veut faire rentrer 104. Sur quelle adresse le swapper s'endort lorsque 104 s'exécute ?

Réponse :
Sur runin. En effet, pour faire rentrer 104, on a dû évincer 103, qui se trouve donc dans le swap. Mais 103 est toujours prêt, il a très envie d'exécuter sa boucle infinie. 103 veut rentrer, mais il n'y a pas de place pour lui, et personne à évincer immédiatement : le swapper s'endort donc sur runin, d'après le code de sched().

En supposant que la signal SIGUSR1 provoque un calcul de 9 secondes sur le proc 104., combien de temps après l'envoi du signal va se terminer le calcul ?

103 et 104 sont les deux seuls processus qui peuvent être évincés. Toutes les 3 secondes, un des deux peut être évincé au profit de l'autre. On va donc échanger la place dans la mémoire entre 103 et 104 toutes les 3 seconde : donc 104 termine son exécution au plus tôt à 17 secondes.



* TD 8 : 04/12/2019

Aujourd'hui, on traite le buffer cache, ou le cache tampon (plus correctement le cache d'entrées/sorties).

#+BEGIN_DEFINITION
Cache

Le cache est une mémoire qui entretient un rapport caractéristique constant avec une autre mémoire réputée capable de stocker nos données d'intérêt (ci-après appelée mémoire d'intérêt) :
- il est (beaucoup) plus petit
- il est (beaucoup) plus rapide

C'est un concept généralisable : le cache L1 est un cache du cache L2, les caches L1, L2, L3 sont des caches de la mémoire centrale, la mémoire centrale est un cache du disque, le disque local est un cache d'un disque distant, etc...

Le but du cache est d'accélérer les accès aux données de la mémoire d'intérêt, en en gardant un sous-ensemble réputé, selon les principes de localité (définition plus bas), de probabilité d'accès élevé.

De cette manière, quand une donnée demandée par le processeur est dans le cache, elle est donnée directement. Sinon, elle est cherchée dans la mémoire d'intérêt.
#+END_DEFINITION

#+BEGIN_DEFINITION
Localité

Propriété assez générale *des programmes* : si une instruction (respectivement une donnée) a été utilisée par le processeur, les instructions (respectivement les données) proches en adresse ont plus de chance d'être utilisées que des instructions ou données plus lointaines : localité spatiale. Si une instruction (respectivement une donnée) a été juste utilisée par le processeur, elle a davantage de chance d'être réutilisée dans un future proche que dans un futur lointain : localité temporelle.
#+END_DEFINITION

Le cache étant beaucoup plus petit que la mémoire d'intérêt, il faut donner une stratégie de choix du sous-ensemble mentionné plus haut.

D'après le principe de localité spatiale, quand on va chercher une donnée dans la mémoire d'intérêt, on en profite pour prendre tout le *bloc* autour de la donnée.
D'après le principe de localité temportelle, quand on doit évincer un bloc du cache pour le remplacer par celui qu'on est en train de ramener, on prendre celui auquel on a accédé pour la dernière fois il y a le plus longtemps (*LRU, pour Least Recently Used*).

Le cache peut être implémenté en matériel ou en logiciel.
Dans une implémentation matérielle, celle qui se trouve par exemple dans les caches L1, L2, L3, l'ensemble de la stratégie détaillée plus haut est implantée sous forme de fils et de transistors, elle est transparente du point de vue du programmeur système. Cette implémentation en matériel fait d'ailleurs que c'est rarement un vrai LRU qui est implémenté, celui-ci étant beaucoup trop coûteux en matériel et donc en temps d'accès au cache.
Dans une implémentation logicielle, le cache est une zone blanche sur laquelle le programmeur système est libre de programmer n'importe quelle stratégie. La mémoire centrale est juste une mémoire centrale, elle n'est pas conçue *a priori* pour être le cache d'une autre mémoire (il existe des machines qui n'ont pas de mémoire au-delà de la mémoire centrale). Si il faut faire de cette mémoire un cache d'une autre mémoire, c'est au programmeur système de l'implémenter, parce que ce n'est pas implémenté en matériel.

La mémoire centrale (physique) dans un noyau va donc se séparer entre les zones allouées aux processus, les zones qui gardent les structures résidentes du système, et la partie qui servira de cache aux mémoires plus lointaines. Cette dernière partie sera le cache tampon, ou le cache d'entrées/sorties. Aujourd'hui, dans un noyau linux récent, toute la mémoire non utilisée est utilisée comme cache tampon.

L'écriture amène aussi d'autres problèmes. Comment gérer la *cohérence* (la notion de cohérence fait l'objet d'une définition plus poussée dans les notes d'ARCHI1) ?

L'écriture semble supposer aussi la présence du bloc mémoire sur lequel on écrit dans le cache, donc suppose éventuellement un accès mémoire pour ramener le bloc d'intérêt dans le cache, et aussi un autre accès pour répercuter l'écriture.

*** Le fonctionnement du cache tampon

On doit pour commencer distinguer entre les blocs de données et en-têtes, ou les métadonnées de ces blocs.

Les blocs de données viennent en trois types :
- Les blocs de données (qui se distinguent entre blocs d'intérêt et blocs d'indirection)
- Les superblocs : des blocs qui stockent des données sur la partition (début, fin, etc...)
- Les blocs d'inode

Les distinctions entre tous ces types de blocs de données seront vues plus en détail lors du TD sur le système de fichiers, soit le TD 9.

Ces blocs font tous la même taille BSIZE, une taille apparemment donnée à la compilation par un define (disons à tout le moins non modifiable à la volée).

Un bloc de donnée ne saurait exister sans son en-tête : il y a donc toujours autant de blocs de données que d'en-têtes.

La quantité totale de blocs de données peut être soit statique, soit dynamique. Dans unix v6, elle est statique : regardons pour nous en convaincre les lignes 247 à 250, dans la fonction getblk(). Si il n'y a aucun tampon libre, on s'endort et on revient au début de la boucle principale. Apparemment, dans linux, le cache tampon pouvant s'étendre à toute la place libre dans la mémoire, il doit bien y avoir la possibilité de faire croître et décroître le nombre de blocs et d'en-têtes avec cette mémoire libre. Les structures dans lesquelles sont stockés et les blocs et les en-têtes permettent a priori cette dynamicité.

Un bloc de données du cache d'entrée/sortie correspond à un bloc du disque : un disque n'est qu'une suite de blocs ordonnés et numérotés.

#+BEGIN_THEOREM
Lemme

Le processus ne connaît ni ne considère que la mémoire centrale. Il ne connaît pas les autres périphériques, ni les autres processeurs.
#+END_THEOREM

#+BEGIN_THEOREM
Corollaire

Le processeur n'écrit jamais sur le disque, il écrit dans le cache d'entrées/sorties de la mémoire centrale.
#+END_THEOREM

L'entrée/sortie sur un bloc précis supposant la présence de ce bloc dans le cache tampon, il faut être capable de vite savoir si la version cachée du bloc disque se trouve bien dans la mémoire centrale, et vite l'identifier le cas échéant.

Cette vitesse doit être assez indépendante du nombre de blocs de données dans le cache d'entrées/sorties : dans un premier temps (unix v6), le nombre de blocs de données dans le cache d'E/S est statique, mais on l'a vu, on voudrait assez vite le faire bouger avec la mémoire libre.

La technique qui a été retenue est celle de la table de hachage. L'identifiant de chaque bloc de donnée (et donc et surtout de chaque en-tête, ceux-ci et ceux-là correspondant exactement), donnée par la concaténation du numéro de device et du numéro de bloc est haché par une fonction qui s'efforce de respecter une propriété importante : pas ou très peu de collisions entre des blocs proches les uns des autres.

On entrevoit maitenant comment sera organisé le cache tampon :

Les en-têtes des blocs présents dans le cache tampon sont gardés dans une table de hachage qui va bien. La table de hachage, si besoin est de le rappeler, est un tableau de listes chaînées. Le congruent du haché modulo le nombre d'éléments du tableau moins 1 donne l'index de la liste chaînée dans laquelle stocker l'en-tête. Dans notre cas précis, les listes sont doublement chaînées, de manière circulaire (jamais de pointeur vers NULL, on revient au début de la liste).

Le cache tampon étant un cache, il doit disposer d'une stratégie de remplacement : le LRU qui est choisi est implémenté par une autre liste doublement chaînée circulaire. Cette nouvelle liste a toujours un en-tête spécial (il ne fait référence à aucun bloc de données) en son début, qui pointe doublement vers lui-même si la liste est vide. Ce bloc s'appelle bfreelist (ligne 60 du fichier buf.h).

Le LRU est implémenté par un mécanisme très simple : les en-têtes correspondant aux blocs qui cessent d'être utilisés rentrent toujours en un côté de bfreelist, les en-têtes correspondant aux blocs qu'on veut attribuer sont toujours pris de l'autre côté.

Dans chaque en-tête se trouve bien entendu un pointeur vers le bloc (c'est l'union des lignes 25 à 30).

Le tableau qui forme la base de la table de hachage est un tableau d'une structure plus simple, la structure hbuf définie entre les lignes 72 et 77.

Les blocs sont gardés de manière contigüe : chaque bloc est assimilé à un tableau de BSIZE caractères, soit exactement BSIZE octets, et ces tableaux sont eux-mêmes dans un tableau de taille statique (NBUF, quantité obtenue par macro substitution, présente dans le Lions à la page 71, ligne 4720).

Le tableau que Pierre Sens appelle bdevsw[] dans cette image :

[[./TD8/cacheES.jpg][Le cache d'entrées/sorties selon Pierre Sens]]

S'appelle en réalité hbuf[] dans notre code. On a bien un double chaînage circulaire pour les chaînes horizontales (on devrait avoir une double flèche des deux derniers en-tête à droite vers l'entrée de hbuf[]).

Le lien entre l'entrée de hbuf[] et le premier en-tête devrait aussi être double.

bfreelist a bien deux pointeurs qu'on ne voit pas ici, un allant de chaque côté d'un "collier" d'en-têtes disponibles.

*** La structure buf

Le chaînage "horizontal", qui part de hbuf[], est fourni grâce aux pointeurs b_forw et b_back.

Le chaînage "vertical", qui part de bfreelist, est fourni grâce aux pointeurs av_forw et av_back.

b_dev est l'identifiant du matériel : c'est un entier, qui est en fait un vecteur de bits. Ce vecteur est séparé entre les bits de poids fort, qui identifient le pilote, et les bits de poids faible qui permettent d'identifier le numéro de périphérique que ce pilote permet d'utiliser (il arrivait, et il arrive peut-être toujours, qu'un pilote permette d'utiliser plusieurs périphériques, ce qui explique cette association contre-intuitive).

b_count donne la quantité de données qui restent à transférer vers ou depuis le périphérique : quand cette quantité tombe à zéro, cela signifie la fin de l'entrée/sortie.

b_blkno correspond au numéro de bloc dans le périphérique.

b_flags stocke des informations sur le bloc et sur l'entrée/sortie en cours.

*** La fonction d'entrée/sortie

Il y a une couche d'abstraction entre le noyau et les pilotes des périphériques, qui peuvent bien ne pas avoir été écrit par les mêmes personnes.

Il existe en mémoire centrale des tables de structures, cdevsw et bdevsw, qui ne contiennent que des pointeurs de fonctions qui sont les pilotes.

Les seules exigences posées par le noyau sur les pilotes est qu'ils doivent être capable de copier un bloc de la mémoire vers le périphérique, ou vice versa, pourvu qu'on leur donne l'identifiant exact du bloc dans le périphérique et l'adresse physique exacte de l'endroit où le copier en mémoire.

Une fonction d'entrée/sortie du noyau ressemblera donc à ça :

#+BEGIN_SRC c
  doIO(device device, struct buf *buffer)
  {
	  ,*(bdevsw[bmajor(device)].d_strategy)(buffer);
  }
#+END_SRC

Cette fonction prend en paramètre un périphérique, et une structure buf *préparée*.

Par contre, partir du principe que c'est la fonction pointée par d_strategy qui va à partir de l'en-tête trouver toute seule comme une grande et l'identifiant du bloc sur le périphérique et le bloc dans la mémoire me semble fantaisiste.

Si les pilotes ne dépendent pas du noyau, c'est à mon avis bien à cette fonction d'enveloppe doIO d'aller chercher les informations idoines (soient, pour ceux qui ont suivi, le numéro du bloc dans le périphérique, et l'adresse du bloc dans la mémoire centrale) dans la struct buf passée en paramètre, pour les passer à son tour à la fonction pointée par d_strategy.

*** bread

Cette fonction est censée rendre un pointeur vers une structure buf, structure buf qui doit avoir un pointeur vers un bloc du cache d'entrée/sortie qui correspond bien au bloc du numéro et du périphérique passé en paramètre.

On doit écrire cette fonction.

#+BEGIN_SRC c

  struct buf *bread(dev_t dev, daddr_t blkno)
  {
	  register struct buf *bp;

	  bp = getblk(dev, blkno);

	  if (bp->b_flags&B_DONE) return bp;

	  bp->b_flag |= B_READ;
	  bp->b_count = BSIZE;
	  ,*(bdevsw[bmajor(dev)].dstrategy)(bp);
	  iowait(bp);
	  return bp;
  }

#+END_SRC

*** Analyse de la fonction getblk

Cette fonction n'est pas forcément compliquée, mais on va faire un automate :

#+NAME: getblk
#+BEGIN_SRC dot

  digraph getblk {

	  node [shape = box];

	  /* Cette option sert à empêcher les courbes */
	  graph [nodesep = 0.2];

	  /* Noeuds */

	  subgraph nominal
	  {
		  loop [label = "loop:"];
		  headerincache [label = "∃ en-tête corr.\n dans le cache E/S ?"];
		  headeroccupied [label = "Occupé ?"];
		  lockheader [label = "Verrouillage"];
		  end [label = "Fin\nPointeur rendu"];

		  loop -> headerincache;
		  headerincache -> headeroccupied [label = "Oui"];
		  headeroccupied -> lockheader [label = "Non"];
		  lockheader -> end;
	  }

	  subgraph presentoccupied
	  {
		  sleepheader [label = "sleep(bp)"];
	  }

	  subgraph absent
	  {
		  emptybfreelist [label = "bfreelist vide ?"];
		  sleepbfreelist [label = "sleep(&bfreelist)"];
		  lockheaderunfree [label = "En-tête libre verrouillé,\nsorti de la bfreelist"];
		  dirty [label = "Bloc dirty ?"];
		  IO [label = "Faire I/O\n différée"];
		  updateheader [label = "Mise à jour en-tête"];
		  gotoloop [label = "goto loop"];

		  sleepbfreelist -> emptybfreelist [label = "Oui", dir="back"];

		  emptybfreelist -> lockheaderunfree [label = "Non"];
		  lockheaderunfree -> dirty;
		  dirty -> IO [label = "Oui"];
		  dirty -> updateheader [label = "Non"];
		  IO -> gotoloop;
	  }

	  /* Réveil, retour au début */
	  sleepbfreelist -> loop [style = dotted, label = "wakeup();goto loop"];
	  sleepheader -> loop [style = dotted, label = "wakeup();goto loop"];


	  /* Première alternative manquée */
	  headerincache -> emptybfreelist [label = "Non"];

	  /* Deuxième alternative réussie */
	  headeroccupied -> sleepheader [label = "Oui"];

	  /* En-tête modifiée, fin */
	  updateheader -> end;

	  // /* Forme */
	  {rank = min; sleepbfreelist emptybfreelist lockheaderunfree dirty IO gotoloop };
	  {rank = same; loop headerincache headeroccupied lockheader end };
	  {rank = max; sleepheader };
  }

#+END_SRC

#+CALL: getblk[:engine graph-easy :results output verbatim drawer :cmdline --as_boxart]()

#+RESULTS:
:RESULTS:
                                                                ┌−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−┐
                                                                ╎            nominal            ╎
                                                                ╎                               ╎
                    wakeup();goto loop                          ╎ ┌───────────────────────────┐ ╎  wakeup();goto loop
    ┌·························································▶ ╎ │           loop:           │ ╎ ◀·······················┐
    :                                                           ╎ └───────────────────────────┘ ╎                         :
    :                                                           ╎   │                           ╎                         :
    :                                                           ╎   │                           ╎                         :
    :                                                           ╎   │                           ╎                         :
┌−−−−−−−−−−−−−−−−−−−┐        ┌−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−    │                           ╎                         :
╎  presentoccupied  ╎        ╎                                      │                           ╎                         :
╎                   ╎        ╎                                      ▼                           ╎                         :
╎ ┌───────────────┐ ╎        ╎ ┌─────────────────────┐            ┌───────────────────────────┐ ╎                         :
╎ │   sleep(bp)   │ ╎  Oui   ╎ │      Occupé ?       │   Oui      │      ∃ en-tête corr.      │ ╎                         :
╎ │               │ ╎ ◀───── ╎ │                     │ ◀───────── │    dans le cache E/S ?    │ ╎                         :
╎ └───────────────┘ ╎        ╎ └─────────────────────┘            └───────────────────────────┘ ╎                         :
╎                   ╎        ╎   │                                                              ╎                         :
└−−−−−−−−−−−−−−−−−−−┘        ╎   │                      −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−┘                         :
                             ╎   │                     ╎            │                                                     :
                             ╎   │ Non                 ╎            │ Non                                                 :
                             ╎   │                     ╎            ▼                                                     :
                             ╎   │                     ╎        ┌−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−┐
                             ╎   │                     ╎        ╎                                        absent                               ╎
                             ╎   ▼                     ╎        ╎                                                                             ╎
                             ╎ ┌─────────────────────┐ ╎        ╎ ┌───────────────────────────┐   Oui                   ┌───────────────────┐ ╎
                             ╎ │    Verrouillage     │ ╎        ╎ │     bfreelist vide ?      │ ──────────────────────▶ │ sleep(&bfreelist) │ ╎
                             ╎ └─────────────────────┘ ╎        ╎ └───────────────────────────┘                         └───────────────────┘ ╎
                             ╎   │                     ╎        ╎   │                                                                         ╎
                             ╎   │                     ╎        ╎   │                            −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−┘
                             ╎   │                     ╎        ╎   │                           ╎
                             ╎   │                     ╎        ╎   │ Non                       ╎
                             ╎   ▼                     ╎        ╎   ▼                           ╎
                             ╎ ┌─────────────────────┐ ╎        ╎ ┌───────────────────────────┐ ╎
                             ╎ │         Fin         │ ╎        ╎ │ En-tête libre verrouillé, │ ╎
                             ╎ │   Pointeur rendu    │ ╎        ╎ │   sorti de la bfreelist   │ ╎
                             ╎ └─────────────────────┘ ╎        ╎ └───────────────────────────┘ ╎
                             ╎                         ╎        ╎   │                           ╎
                             └−−−−−−−−−−−−−−−−−−−−−−−−−┘        ╎   │                           ╎
                                 ▲                              ╎   │                           ╎
                                 │                              ╎   │                           ╎
                                 │                              ╎   │                           ╎
                             ┌−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−    │                           ╎
                             ╎                                      ▼                           ╎
                             ╎ ┌─────────────────────┐   Non      ┌───────────────────────────┐ ╎
                             ╎ │ Mise à jour en-tête │ ◀───────── │       Bloc dirty ?        │ ╎
                             ╎ └─────────────────────┘            └───────────────────────────┘ ╎
                             ╎                                      │                           ╎
                             └−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−    │                           ╎
                                                                ╎   │                           ╎
                                                                ╎   │ Oui                       ╎
                                                                ╎   ▼                           ╎
                                                                ╎ ┌───────────────────────────┐ ╎
                                                                ╎ │         Faire I/O         │ ╎
                                                                ╎ │         différée          │ ╎
                                                                ╎ └───────────────────────────┘ ╎
                                                                ╎   │                           ╎
                                                                ╎   │                           ╎
                                                                ╎   ▼                           ╎
                                                                ╎ ┌───────────────────────────┐ ╎
                                                                ╎ │         goto loop         │ ╎
                                                                ╎ └───────────────────────────┘ ╎
                                                                ╎                               ╎
                                                                └−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−┘
:END:

#+CALL: getblk[:engine graphviz :file ./TD8/getblk.png :cmdline -Tpng -Grankdir=LR]()

#+RESULTS:
[[file:./TD8/getblk.png]]


On l'aura compris, le but de cette fonction est de fournir un en-tête de bloc, soit en le trouvant directement dans les en-têtes de bloc déjà chargés et libres, soit en attendant sa libération le cas échéant, soit en allouant un nouveau bloc le cas échéant. L'en-tête de bloc dont un pointeur est fourni en retour de fonction est bien entendu verrouillé.

En plus de l'automate, on va en plus donner une lecture cursive de la fonction :

La fonction prend en paramètres un entier correspondant au périphérique, et un autre entier correspondant au numéro du bloc.

La boucle commence par un masquage des interruptions de niveau NORMAL.

La fonction calcule le haché de la concaténation périphérique + bloc, et donc son congruent modulo le nombre des éléments de hbuf[] moins 1.

À ce moment, le pointeur dp tient une adresse d'un élément de hbuf[] (on prend quand même la peine de vérifier les erreurs).

On parcourt la liste doublement chaînée qui commence à l'élément de hbuf[] pointé par dp, à la recherche d'un en-tête dont le numéro de périphérique et de bloc sont les mêmes que ceux passés en paramètres.

Si on en trouve un, et qu'il est libre : on le verrouille et on le retourne.

Si on en trouve un, et qu'il est occupé : on y ajoute le flag B_WANTED, on s'endort sur son adresse, et on se fera réveiller quand il se libèrera. Quand on se réveillera, on recommencera cependant tout au début de la boucle.

Si on en trouve pas, on vérifie que le pointeur av_forw de bfreelist ne pointe pas vers bfreelist. Si c'est le cas, ça signifie qu'il n'y a pas d'en-tête libre. Dans ce cas, on rajoute le flag B_WANTED à bfreelist, on s'endort sur son adresse. On se réveillera quand un en-tête libre se rajoutera. On recommencera cependant tout au début de la boucle.

Si le pointeur av_forw de bfreelist ne pointe pas sur bfreelist, c'est qu'il pointe vers l'en-tête du bloc disponible le moins récemment accédé.

Le LRU, qui est un algorithme en général très coûteux à mettre en place, est ici résolu d'une manière intelligente : tous les en-têtes qui veulent se manifester comme disponibles rentrent du même côté du "collier" : le côté av_back. Parcourir la chaîne en partant du côté av_back revient donc exactement à parcourir tous les en-têtes de blocs disponibles du plus récemment accédé (MRU, Most Recently Used) au moins récemment accédé (LRU, Least Recently Used). Inversement, si on parcourt la chaîne en partant du côté av_forw, on parcourra tous les en-têtes de blocs disponibles du moins récemment accédé (LRU) au plus récemment accédé (MRU).

C'est en revanche un "collier" un peu spécial, dont on peut enlever des "perles" en plein milieu et pas seulement aux extrémités.

Ce premier en-tête du bloc LRU est dans un premier temps verrouillé. Si le flag d'écriture différée est activé, cela signifie que le bloc est dirty et qu'il doit donc être répercuté sur le disque. On fait l'entrée/sortie correspondante, et on recommence au début de la boucle.

Si le flag d'écriture différée n'est pas activé, le bloc est clean, il peut être écrasé sans problèmes. On met donc le flag busy à l'en-tête, on le sort de la chaîne des blocs disponibles (les 6 opérations sur pointeur des lignes 261-266), on peuple la structure avec le numéro de périphérique et de bloc et on retourne enfin le pointeur.

*** iowait et iodone

Ces deux fonctions sont simplement des fonctions d'enveloppe autour de sleep et wakeup respectivement.

Elles prennent toutes deux un pointeur vers un en-tête.

La première doit s'endormir sur l'adresse de l'en-tête tant que celui-ci n'a pas fini son entrée/sortie.

La deuxième doit :
- Marquer que l'entrée/sortie est terminée
- Si le flag B_ASYNC est activé, relâcher l'en-tête. Sinon réveiller à l'adresse de l'en-tête.

*** bwrite

À écrire nous-même.

Cette fonction lance une écriture, et se bloque en attendant la fin avant de cette écriture, avant de relâcher l'en-tête, si le flag B_ASYNC est absent. S'il est présent, lance simplement l'écriture.

#+BEGIN_SRC c

  void bwrite(struct buf *bp)
  {
	  bp->b_flags &= ~(B_READ | B_DONE | B_ERROR | B_DELWRI);
	  bp->b_count = BSIZE;

	  ,*(bdevsw[bmajor(dev)].dstrategy)(bp);

	  if (!(bp->b_flags&B_ASYNC)) {
		  iowait(bp);
		  brelse(bp);
	  }

	  return;
  }

#+END_SRC

*** brelse

À écrire nous-même.

Cette fonction est supposée relâcher un en-tête, en le plaçant dans la liste doublement chaînée des en-têtes libres. Si le bloc était demandé, réveiller sur l'adresse de l'en-tête du bloc. Si il n'y avait aucun bloc libre, réveiller sur l'adresse de bfreelist.

#+BEGIN_SRC c

  void brelse(struct buf *bp)
  {
	  bp->b_flag &= ~(B_BUSY | B_WANTED | B_ASYNC);

	  if (bp->b_flag&B_WANTED) wakeup(bp);

	  if (bfreelist.b_flag&B_WANTED) {
		  bfreelist.b_flag &= ~B_WANTED;
		  wakeup(&bfreelist);
	  }

	  int mask = gpl();

	  spl(BDINHB);

	  bfreelist.av_back->av_forw = bp;
	  bp->av_back = bfreelist.av_back;
	  bfreelist.av_back = bp;
	  bp->av_forw = &bfreelist;

	  bfreelist.b_count++;

	  spl(mask);
  }

#+END_SRC

Cette fonction n'implique aucune entrée-sortie.

Elle est appelée soit après que l'entrée-sortie a été complétée, soit avant (si le flag B_DELWRI était à 1) : un en-tête de bloc peut parfaitement être relâché, sans que l'entrée/sortie ait été complétée.

*** Remarques et discussion

Les concepteurs de unix v6 ont très tôt implémenté la possibilité des écritures asynchrones, les entrées/sorties, donc les accès au bus étant coûteux.

Pour cela, deux flags dans l'en-tête ont été mis en place :
- Le flag B_ASYNC (pour ASYNChronous writing), *qui n'est activé qu'en cas d'écriture*, qui signifie simplement que l'écriture n'est pas bloquante. On n'active le flag B_ASYNC dans un seul cas : juste avant de lancer une écriture, soit expicitement via la fonction bawrite, simple fonction d'enveloppe autour de bwrite, soit quand on tient à utiliser un en-tête disponible via getblk, et que celui-ci est dirty.

- Le flag B_DELWRI (pour DELayed WRIting), qui ne lance pas d'écriture mais qui relâche l'en-tête, et qui dit que cette écriture pourra se permettre d'être lancée seulement quand quelqu'un d'autre voudra utiliser l'en-tête relâchée.

Le flag B_DELWRI est transformé en flag B_ASYNC par getblk à la ligne 256, juste avant de lancer une écriture qui sera donc non-bloquante.

Le chemin d'un en-tête marqué B_DELWRI rejoint donc celui d'un en-tête marqué B_ASYNC : *un en-tête ne saurait cependant avoir les deux flags à la fois* (sauf pendant un très court instant entre la ligne 256 de la fonction getblk, et la première ligne de la fonction bwrite appelée juste après).

On ne doit pas oublier que le cache d'entrées/sorties *est avant tout un cache*. De plus, c'est un *cache unique en son niveau*. Tous les processeurs doivent s'adresser à la mémoire centrale, il n'existe pas plusieurs mémoires centrales entre lesquelles il faudrait assurer la cohérence.

*Un système d'écriture Write Back est donc naturel.*

Il y a bien sûr le problème de la volatilité de la mémoire, qui n'en est un que si on le décide (on peut partir du principe que la machine ne va pas s'arrêter de manière intempestive).

Il peut y avoir aussi le problème d'un débit d'écritures trop grand et trop dispersé en localité : si le débit des écritures dans le cache tampon dépasse pendant un long moment celui du débit des écritures entre la mémoire centrale et les périphériques, les processus se voient endormis, de manière à ce que leurs entrées/sorties dans le cache E/S se font plus rares, le débit retombant à terme vers le débit maximal des entrées/sorties de la mémoire centrale vers les périphériques. Ce problème est mitigé par le fait que le tampon d'entrée/sortie est relativement grand. Le masquage complet du coût des écritures est en fait assez facile à assurer.

C'est pour ces raisons que les écritures seront plus souvent différées qu'immédiates. On peut bien entendu explicitement demander une écriture immédiate quand on le souhaite. Mais il est naturel que les écritures ne soient répercutées qu'une fois que le bloc est réclamé par quelqu'un d'autre.


* TD 9 : 11/12/2019

Cette semaine, le fonctionnement du système de fichiers, ses liens avec le cache d'entrée/sortie, et le lien entre les inodes et les chemins du système de fichier.

*** Question 1

Petit entraînement : implémenter cat.

#+BEGIN_SRC c
  #include <stdio.h>
  #include <stdlib.h>
  #include <unistd.h>
  #include <sys/types.h>
  #include <sys/stat.h>
  #include <fcntl.h>

  int main(int argc, char *argv[])
  {
	  int fd;
	  char buf;

	  for (int i = 1; i < argc; ++i) {
		  if ((fd = open(argv[i], O_RDONLY)) == -1) exit(1);

		  while (read(fd, &buf, 1) > 0) {
			  printf("%c", buf);
		  }

		  close(fd);
	  }

	  return 0;
  }
#+END_SRC

Sans rigoler, le truc au-dessus est vraiment une implémentation fonctionnelle de cat (mais pas très performante, ni très POSIX). Elle est en fait assez proche des implémentations minimalistes de cat qui ont pu être celles de plan9, par exemple. On pourra consulter certaines implémentations historiques de cette commande fort utile [[https://github.com/pete/cats][ici]].

L'entier fd est le *descripteur de fichier*, qui correspond à un index dans un tableau de pointeurs situé dans la structure user du processus. Ces pointeurs pointent vers des structures file, dont un tableau de taille statique est déclaré dans le zone système de la mémoire centrale.

On a donc une table des ouvertures de fichier à l'échelle du processus, qui est en fait un tableau de pointeurs, vers des éléments d'une table globale du système.

Les index 0, 1 et 2 sont les index de la table des ouvertures de fichier d'un processus qui correspondent respectivement à l'entrée standard, la sortie standard et la sortie d'erreur.

On a bien entendu une table des ouvertures de fichier par processus. Pour éviter la redondance des informations, toutes ces tables des ouvertures de fichier se contentent de pointer vers une table globale des ouvertures de fichier.

*** La structure file

Comme on l'a dit, la table des ouvertures de fichier du processus pointe vers une table globale du système, une table de structures file.

À quoi ressemble la structure file ?

On a dedans f_flag qui est un vecteur de 8 bits, désignant les permissions avec lesquelles a été ouvert le fichier : le bit de poids faible à 1 désigne que la lecture est possible, le bit à gauche du premier dit que l'écriture est possible, le bit encore à gauche dit que le fichier est un tube.

On a ensuite un entier qui compte le nombre de références vers cette structure file. En effet, on a dans l'espace d'adressage d'un nombre inconnu de processus un pointeur vers cette entrée. On doit garder bon compte du nombre de références, car cette quantité est particulièrement difficile et coûteuse à retrouver. Cette donnée est aussi d'intérêt, car c'est elle qui déterminera s'il est possible de faire sortir une entrée de la table des fichier ouverts, qui, on le rappelle, est statique, et dans laquelle les places sont chères.

Ensuite, cette structure stocke un pointeur vers un i-noeud (ou *i-node*, ou encore *inode*), dont on verra l'utilité plus tard.

Enfin, cette structure stocke un entier qui correspond au déplacement du "curseur" depuis le début du fichier.

Il est donc en mémoire centrale une table statique de NFILE (variable probablement définie à la compilation, par macro-substitution) fois cette structure.

*** La structure inode

Dans les polys de travaux dirigés, la structure inode vient en deux versions, une de la version unixv5 et une de la version unixv6.

L'inode est l'identifiant unique du fichier dans le système de fichiers, ainsi que ses métadonnées.

Il en existe une table statique (de taille NINODE) en mémoire centrale. Ce sont les entrées de cette structure qui sont pointées par le champ f_inode de la structure file.

Bien entendu, il existe surtout des inodes sur le disque où est défini le système de fichier : les inodes étant l'identifiant et les métadonnées du fichier, il est nécessaire que ces inodes soient stockés sur la même mémoire *persistante* que les fichiers dont ils sont les métadonnées.

Les inodes en mémoire centrale représentent donc des fichiers ouverts. La table en mémoire centrale est une espèce de cache de la masse des inodes sur le disque.

**** Aparté et teaser : organisation du système de fichiers

Dans le système de fichier défini par unix, le format extfs (EXTended File System), les blocs du disque (numérotés) sont organisés de cette façon :

- le premier bloc du disque est le boot bloc (il est chargé au démarrage de la machine et donne éventuellement l'adresse du code à charger)
- le deuxième bloc est le superbloc de la première partition. Il stocke les métadonnées de la partition. Il y a autant de superblocs qu'il y a de partitions sur un disque.
- les blocs suivants sont les blocs d'inodes, qui contiennent donc les métadonnées des fichiers du système. Il y a plusieurs inodes stockés dans un bloc d'inode.
- les blocs suivants sont les blocs de données, qui contiennent soit des données, soit l'adresse (en numéro de bloc) de données. Dans le deuxième cas, on parlera de *blocs d'indirection*.

La limite entre toutes ces zones de blocs est donnée dans le superbloc.

**** Fin de l'aparté, retour à la structure inode

Puisqu'il existe des inodes stockées en mémoire centrale qui sont un sous-ensemble des inodes en mémoire secondaire, un certain nombre de champs n'auront peut-être de sens que pour une seule version de ces inodes.

Cette structure inode stocke avant toute chose un vecteur de bits, les flags ayant diverses significations (i_flag).

Elle stocke ensuite un compteur de références, pour les mêmes raisons que la structure file stocke un compteur de références (i_count).

Une donnée qui n'a de sens que si l'inode est en mémoire centrale, le périphérique où réside la version persistante de cette dernière (i_dev).

Une autre donnée qui n'a de sens que si l'inode est en mémoire centrale, le numéro d'inode (pourquoi est-ce que cette donnée n'a de sens qu'en mémoire centrale ? Parce que les inodes étant stockés en mémoire secondaire de manière contigüe, et avec un point de départ connu, un nombre constant constant d'inode pouvant être stockés sur un bloc, l'endroit où on trouve l'inode en mémoire secondaire donne son numéro, et vice et versa) (i_number).

Un autre vecteur de 16 bits, qui stocke à la fois des flags sur le type de fichier et sur les permissions qui y sont associées (i_mode).

Le nombre de liens physiques vers cette inode (i_nlink).

**** Aparté sur les liens physiques et les liens symboliques

Un chemin dans le système de fichier correspond à exactement un inode. La traduction entre le chemin et l'inode est d'ailleurs une opération un peu coûteuse qui est assurée par la fonction namei, qui sera vue plus tard.

Il peut bien entendu y avoir plusieurs chemins (appelés liens) qui mènent à un même inode. On parle dans ce cas de liens physiques.

On prendra bien soin de distinguer ces liens des liens symboliques, *qui sont des fichiers*, qui font donc référence à leur propre inode.

**** Fin de l'aparté

Un entier qui identifie le propriétaire du fichier (i_uid).

Un autre entier qui identifie le groupe du propriétaire du fichier (i_gid).

Un entier qui donne la taille du fichier (i_size).

Et enfin un tableau de numéros de blocs dans lesquels sont stockées les données du fichier.

**** Remarques

L'existence d'un fichier est donnée par l'existence de son inode. Une inode n'a besoin d'exister que si un chemin correspondant à cette inode.

Supprimer un fichier avec la commande shell rm consiste donc en la suppression d'un lien physique vers l'inode vers lequel pointe le lien qu'on supprime.

Un inode est effectivement supprimé quand le dernier lien physique vers cette inode est supprimé, soit quand i_nlink tombe à 0. Retrouver le nombre de liens vers un inode est extrêmement coûteux, c'est pour ça qu'on prend la peine de le stocker.

Un lien symbolique est juste un fichier qui contient simplement l'inode (ou le chemin, ou les deux) d'un autre fichier.

Un répertoire est juste un fichier qui contient simplement l'inode d'autres fichiers, ceux dont son chemin est un préfixe du leur.

*** Exercice type examen

Voilà deux processus, qui exécutent chacun :

#+BEGIN_SRC c
  // Processus A

  fd = open("f", OWRONLY);
  write(fd, "aaa", 3);
  write(fd, "c", 1);

  // Processus B

  fd = open("f", OWRONLY);
  write(fd,, "bb", 3);
#+END_SRC

Décrire l'état de la table des fichiers ouverts et des inodes, et donner le contenu du fichier f.

#+BEGIN_THEOREM
Un appel à open ouvre toujours toujours (sous réserve de réussite, bien entendu) une nouvelle entrée dans la table des ouvertures de fichier, quand bien même deux entrées se trouveraient par là exactement identiques !
#+END_THEOREM

#+BEGIN_THEOREM
Corollaire

La seule manière dont on pourrait avoir une entrée de la table globale des ouvertures de fichier avec un compteur de références supérieur à 1, c'est le fork.
#+END_THEOREM

On peut en revanche parfaitement avoir deux entrées de cette table globale des fichiers ouverts qui pointent sur la même entrée de la table des inodes.

Dans notre cas, puisqu'on a une entrée dans la table des ouvertures de fichier par processus, chaque processus écrit en son propre endroit du fichier, déterminé par l'offset de l'entrée.

Plusieurs entrelacements possibles des exécutions :

- Si A écrit tout, puis B : "bbac"

- Si A écrit, puis B, puis A à nouveau : "bbac"

- Si B écrit, puis A : "aaac"

*** Autre exercice type examen

#+BEGIN_SRC c

  fd = open("f", OWRONLY);
  write(fd, "aaa", 3);
  if (fork() == 0)
	  write(fd,"bb",2);
  else
	  write(fd,"c",1);

#+END_SRC

Cette fois-ci, le père et le fils partagent la référence à l'entrée dans la table centrale des ouvertures de fichier, et partagent donc l'offset.

Donc deux possibilités :
aaabbc
aaacbb

*** Analyse de la fonction iget

La fonction iget prend en paramètre un numéro de périphérique et un numéro d'inode, et renvoie un pointeur vers une structure inode verrouillée.

La fonction est un peu longue, on va faire un automate :





ligne 44 : +31 pour se débarrasser du boot bloc et du superbloc.
16 inodes par blocs.


[aparté sur iupdat, code du Lions]

*** Analyse de la structure filsys

*** Analyses des fonctions

schéma de open
namei [très long, à reprendre]
close
unlink


* TD 10 : 18/12/2019

Aujourd'hui, la gestion des blocs de données.

Pour un numéro de fichier, on veut savoir à quel bloc on veut accéder.

La fonction bmap.

Mappe un inode et un numéro de bloc logique à un numéro de bloc physique.

On vérifie que le numéro de bloc logique est bien une quantité positive (sinon erreur).

alloc réserve un bloc random libre sur le device passé en paramètre.

NSHIFT est le log de la taille en octets du bloc.

76-84 : aller chercher le numéro du bloc d'indirection (l'allouer si il ne l'est pas).




Automate :

Est-ce que bn est un bloc direct.

Si oui, est-ce que le bloc pointé est alloué ?

Si non, l'allouer (si on est en écriture) erreur (si on est en lecture, ou si l'allocation ne marche pas), puis le rendre.

Si oui, le rendre.


Si bn n'est pas un bloc direct, chercher le niveau d'indirection.

(3, 2, ou 1)

On parcourt chaque niveau d'indirection à la recherche du bon bloc.



alloc serait appelé seulement depuis cette fonction.


Le chaînage intelligent.

Le chaînage est fait au moment du formatage.

Par contre si on perd un chaînage, on perd tout les éléments pointés.

ext1/ext2


* Révisions

** Examen réparti de Janvier 2019

*** Question de cours

**** 1

Oui. Le masquage lors d'une interruption disque est de priorité inférieure à celle de l'interruption horloge, qui est la plus grande.

**** 2

Le processus traitera au plus tôt le signal quand il aura le processeur, à la sortie du mode noyau.

**** 3

Oui.

*** Exercice 2

**** 1

C'est le bloc 1000

**** 2

La table des inodes sur disque commence au bloc 2.

Une inode fait 32 octets, un bloc est de 512 octets.

2 ^ 5 et 2 ^ 9.

On peut avoir 2^4 soit 16 inodes par bloc.

Si on admet que les inodes sont stockées dans l'ordre de leur numéro, alors l'inode numéro 20 est dans le bloc 3, et l'inode numéro 30 est dans le bloc 3.

**** 3

État des tables de descripteurs de fichier.

Table du père :

| 0 | ptrstdin  |
| 1 | ptrstdout |
| 2 | ptrstderr |
| 3 | ptrf1     |
| 4 | ptrf2     |

Table du fils :

| 0 | ptrstdin  |
| 1 | ptrstdout |
| 2 | ptrstderr |
| 3 | ptrf1     |
| 4 | ptrf2     |

Table du petit-fils :

| 0 | ptrstdin  |
| 1 | ptrstdout |
| 2 | ptrstderr |
| 3 | ptrf1     |
| 4 | ptrf2     |

Table globale des ouvertures de fichier :

|   |        | f_flags           | f_offset | f_count |
|---+--------+-------------------+----------+---------|
|   | stdin  |                   |          |         |
|   | stdout |                   |          |         |
|   | stderr |                   |          |         |
|   | /fich  | O_WRONLY O_APPEND |     5136 |       3 |
|   | /fich  | O_RDWR            |        0 |       3 |

Tables des inodes :


|   |       | i_size | i_count | i_number |
|---+-------+--------+---------+----------|
|   | /     |      ? |       ? |       20 |
|   | /fich |   5136 |       2 |       30 |

**** 4

ligne 2 :

namei() transforme "/" en inode 20.
On accède à l'inode 20, qui est déjà dans la table des inodes (à l'index 0 par hypothèse) : on accède donc au bloc 3 du disque (plutôt dans la version cache I/O), puisque c'est là que se trouve l'inode.

On accède au premier bloc de données de l'inode 20, soit le bloc 100, à la recherche de la chaîne de caractères "fich". On ne la trouve pas, par hypothèse.

On accède au deuxième bloc de données de l'inode 20, soit le bloc 201, à la recherche de la chaîne de caractères "fich". On la trouve.

On accède à l'inode 30, qui est sur le bloc 3 (déjà chargé)

On ajoute à la table des inodes, à l'index 1, l'inode 30 (elle n'y était pas déjà, par hypothèse). On 

[la suite manque, on complètera]

**** 5

Lors du namei du premier open, on doit accéder au bloc 3.

On vérifie que le bloc 3 est dans les blocs du cache IO, il y est par hypothèse. On sort le bloc 0-3 de la bfreelist, on le réserve : pas d'IO.

On doit accéder au bloc 100. On vérifie qu'il est dans le cache IO (il y est). On sort le bloc 0-100 de la bfreelist, on le réserve : pas d'IO.

On doit accéder au bloc 201. On vérifie qu'il est dans le cache IO (il y est). On sort le bloc 0-201 de la bfreelist, on le réserve : pas d'IO.

On doit accéder au bloc 3 (inode 30) : il est déjà dans le cache IO. On le réserve à nouveau, etc...

Pareil pour la ligne 2.

On doit accéder au bloc 3 (inode 30) : il est déjà dans le cache IO. Réservé à nouveau.

On calcule qu'on doit aller écrire dans le bloc 10.

Or le bloc 10 est un bloc d'indirection simple.

On doit récupérer le bloc 402. Le haché de 402 par 5 est 2. On ramène 0-402 dans le cache IO (IO physique), il est pointé par le 3ème élément de la liste hbuf.

On lit le bloc 402, à la recherche de la première ligne.

On doit ramener le bloc 1000. Il est pas dans le cache IO. Le haché est 0. On le ramène (IO physique), il est pointé par 0-100.

bdwrite(). On écrit dans la version cache IO, et on marque le tampon en dirty : pas d'IO.

bdwrite(). On réécrit dans la version cache IO, et on marque le tampon en dirty : pas d'IO.

4 IO logiques, dont 2 IO physiques.




* Annexes

Les supports de TD :

[[./TDTME.pdf][TD]]

La version Lions du code :

[[./unixv6Lions.pdf][Lions]]


