#+TITLE : Prise de notes TD 4I401 NOYAU
#+PROPERTY: header-args :mkdirp yes
#+STARTUP: inlineimages

Jonathan Lejeune(jonathan.lejeune@lip6.fr)

* TD 1 : 25/09/2019

Rappels systèmes et introduction au noyau Unix.

*** Question 1 : Quel est l'intérêt de déclarer une variable en register ?

Le temps d'accès à un registre est particulièrement bas. Si on sait qu'une variable devra être lue souvent, il peut être bon pour la vitesse d'exécution de mettre la variable dans le registre.

*** Question 2 : Que fait le programme suivant ?

#+BEGIN_SRC c
  f(from, to, count)
  int *from, *to;
  register count;

  {
	  register *f, *t;
	  f = from;
	  t = to;
	  do
		  ,*t++ = *f++;
	  while(--count);
  }
#+END_SRC

Le programme prend en paramètre deux pointeurs vers entier, et un entier count.

La copie locale du paramètre count doit être mis dans un registre si possible.

Le programme déclare ensuite deux pointeurs vers des entiers f et t, et demande à les mettre dans le registre. Il donne aux deux pointeurs ainsi créés les valeurs des deux paramètres from et to en entrée.

Le choix est judicieux : les variables appelées à être souvent modifiées (t, f, et count) sont mises dans un registre, celles destinées à n'être lues qu'une fois (from, to) se contentent de la mémoire centrale. Il n'est pas sûr que ce paramètre explicite soit nécessaire en 2019 : on pourrait estimer gcc capable de faire cette optimisation seul.

Le but du programme est de copier une certain nombre d'entiers contigus (exactement count entiers) de l'adresse from à l'adresse to.

L'incrémentation se fait après la copie : opérateur d'incrémentation post-fixé.

La décrémentation de count se fait avant le test du while : opérateur pré-fixé.

*** Question 3

Soit un tableau t d'une structure quelconque x

#+BEGIN_SRC c
  struct x {
	  int x_a;
  } t[MAX];
#+END_SRC


Ce code permet de parcourir la structure. (cpt stocke la somme des éléments du tableau).

#+BEGIN_SRC c
  int i, cpt;
  cpt = 0;
  for (i = 0; i < MAX; ++i) {
	  cpt += t[i].x_a;
  }
#+END_SRC

Ecrire un code qui permet de parcourir la structure en utilisant un pointeur vers la structure.

On doit pouvoir donner une condition d'arrêt. On peut soit déclarer une variable i, l'incrémenter en même temps que le pointeur, soit se servir de MAX (on ne sait pas si MAX est une variable locale ou globale, ou un alias, ou quoi que ce soit).



#+BEGIN_SRC c
  int cpt = 0;
  int i = 0;

  for (; i < MAX; p++, i++) cpt =+ p->x_a;
#+END_SRC

On part bien entendu du compte que MAX est connu dans la portée du code.

Bonne solution :

#+BEGIN_SRC c
  int cpt = 0;
  struct x *p;

  for (p = t; p < t + MAX; ++p) {
	  cpt += p->x_a;
  }
#+END_SRC

En effet, on peut garder l'adresse du début du tableau dans une autre variable. Quand la différence entre l'adresse dynamique et l'adresse de départ atteint MAX, on s'arrête.

*** Question 4

CPU : Central processing unit, fait les opérations arithmétiques et logiques, charge des zones de mémoire centrale dans sa mémoire personnelle, décharge sa mémoire personnelle dans la mémoire centrale.

Les registres sont le nom donné à la mémoire personnelle du processeur (accessible en un cycle).

RAM : La mémoire centrale, non-persistante (contenu disparaît à l'extinction de la machine). Permet d'accéder directement à un octet donné.

La mémoire morte est une zone de mémoire sans droits d'écriture dans laquelle on peut écrire le bios, par exemple.

Interruption (trappe) : Signal matériel (par opposition aux signaux, qui sont des entités logicielles), qui demande au système d'exploitation de reprendre la main pour faire des trucs. L'appel système est une sorte d'interruption logicielle.

Comment le CPU communique-t-il avec le matériel ? Via les interruptions et les contrôleurs (en fait des processeurs monotâche).

DMA (Direct Memory Access) : permet aux contrôleurs d'I/O d'accéder directement à des zones mémoire intéressantes (sans avoir besoin de passer par un tampon).

*** Question 5

La mémoire virtuelle, c'est la manière dont le processeur voit la mémoire, qui ne correspond pas à la mémoire physique.

C'est l'ensemble des adresses mémoire accessible par le processeur (qui dépend directement de la taille de son mot d'instruction). La correspondance entre les adresses de mémoire virtuelle et celles de mémoire physique est faite par le MMU (Memory Management Unit), une zone du processeur (ou un processeur spécifique). Le MMU dispose d'un cache appelé TLB (Translation Local-side Buffer).

Chaque processus dispose d'une table des pages qui stocke l'adresse des différents segments et pages, à laquelle le MMU accède, fait son calcul, et accède à l'adresse physique correspondante.

*** Question 6

La commutation de contexte :

La commutation de contexte est l'opération qui consiste à remplacer dans le processeurs et la mémoire centrale les données qui permettent l'exécution d'un processus, par celles qui permettent l'exécution d'un autre processus.

(Déjà, on ne choisit pas quand on commute, c'est le noyau)
La commutation se fait seule quand le quantum d'un processus est épuisé, à la suite d'une interruption d'horloge. Concrètement, lorsqu'une commutation commence, on copie le contexte processeur (les registres) et le contexte mémoire noyau (ce qui, dans la partie noyau de la mémoire, fait référence au processus courant) qqpart dans la mémoire centrale, et on charge à la place depuis un endroit en mémoire centrale le contexte processeurs et le contexte mémoire noyau.

*** Question 7

Les segments sont des zones de la mémoire spécifiques à un processus qui partagent les mêmes permissions. On les distingue traditionnellement entre les données (dans lesquelles on trouve le tas), accessibles en lecture et en écriture, le code (dans laquelle on va trouver les instructions du processus), accessible seulement en lecture, et la pile (pour les variables locales des fonctions), accessible en lecture et en écriture.

Le CPU y accède (s'il en a le droit !) via une instruction de son jeu d'instruction (load word, load byte), qui est transmise au MMU.

#+BEGIN_SRC c
  #include <stdio.h>

  int x = 37;

  void f(int a, int b)
  {
	  int i = 17;
	  int j = a + b + i;
	  printf("Hello : %d\n", i);
	  i = 45;
  }

  void g()
  {
	  int *i = (int*)malloc(sizeof(int) * 5);
	  f(3, 4);
  }

  int main()
  {
	  g();
	  return 0;
  }
#+END_SRC

Dessin du contexte mémoire :


|   | @code après g |      |
|---+---------------+------|
|   |       @malloc | f    |
|   | @code après f |      |
| b |             4 |      |
| a |             3 |      |
| i |            45 |      |
| j |            24 |      |
|   |               |      |
|   |               |      |
|   |               |      |
|   |               |      |
|---+---------------+------|
|   |               | tas  |
|---+---------------+------|
| x |            37 | glob |

*** Aparté

Processus : instance d'exécution d'un programme, et *son contexte et flux d'exécution*.

*** Question 8

En mode système, un certain nombre d'instructions spéciales et de registres spéciaux du processeurs sont accessibles en plus de celles accessibles en mode usager.

Il y a ces différences parce qu'on ne veut pas que l'usager puisse casser le matériel en accédant à des instructions ou des registres auquel il n'a pas droit.

Dans un processeur MIPS, il y a un registre système qui garde si l'exécution courante se fait en mode sytème ou en mode utilisateur.

PDP-11 ? [Pas traité ici]

Il y aussi une certaine zone de mémoire qui apparaît en mode S : en fait, une deuxième pile apparaît, la pile S, spécifique à un processus (distincte de la zone des données du systèmes, qui regroupe les variables globales à tous les processus).

La pile S sert à sauvegarder les appels de fonction du noyau, les variables locales des fonctions qui y sont exécutées (c'est une pile, après tout).

*** Question 9

Un appel système, c'est une interruption logicielle qui permet à un processus de faire appel à des ressources du système en mode noyau, auxquelles il est seulement possible d'accéder en mode noyau.

Appel système : fonction du système appelée à partir du mode utilisateur.

*** Question 10

Interruption (trappe) : Signal matériel (par opposition aux signaux, qui sont des entités logicielles), qui demande au système d'exploitation de reprendre la main pour faire des trucs.

*** Question 11

Il est très important qu'il y ait deux piles :
- on veut définir des autorisations différentes sur ces deux piles
- on veut que le processus en mode système puisse accéder à ses propres variables privées, éventuellement à des variables globales.

La pile S étant critique, elle peut être définie pour ne jamais être vide. On ne saurait donner les mêmes droits à un mode U (on ne fait pas confiance au programme).

Pourquoi une pile S par processus ?
Chaque processus a un contexte mémoire dans le noyau (dans la partie noyau de la mémoire).

Il faut sauver un contexte d'exécution des fonctions systèmes par processus. Précisément parce qu'on a la possibilité de sortir "pas proprement" du mode système, et donc que la pile S n'est pas propre, il en faut plusieurs, une par processus.

*** Question 12

Structure proc

p_flag : vecteur de bits, correspond à des états secondaires du processus
p_stat : vecteur de bits, correspondant à des états d'ordonnancement
p_textp : pointeur vers une structure de type texte, qui lui-même pointe vers le code du programme

On a une déclaration d'un tableau de cette structure : c'est une variable globale, avec NPROC nombre maximal de processus existants à n'importe quel moment.

(résultat de ps(1), avec option -aux)


Structure user

Tableaux de sauvegarde des registres, selon les cas.
Pointeur vers la structure proc correspondance.

u_ofile : tableau des descripteurs de fichier.
u_signal : Handler de signal
u_cdir : pointeur vers inode du répertoire courant

Une instance de la structure user existe pour chaque processus, elle est déclarée : la variable u est toujours peuplée de la structure du processus courant.

Informations moins importantes que dans la structure proc : peuvent être swappées, contrairement à proc.

Les informations de proc sont vitales, en particulier pour l'ordonnancement.

*** Question 13

Zone U :

Pile S + struct u (l'instance de la structure user)

Une seule zone U active fonctionnelle, à un moment précis.

Etat de la mémoire virtuelle à un moment précis :

| S     | Zone U          | Dynamique |
| S     | Code du système | Statique  |
|-------+-----------------+-----------|
| S + u | Pile            | Dynamique |
| S + u | Données (tas)   | Dynamique |
| S + u | Texte (Code)    | Dynamique |

Par dynamique, on entend que la région de mémoire physique vers laquelle pointe la zone change avec chaque commutation.
Le code du système reste toujours mappé vers la même zone de mémoire physique, quel que soit le processus exécuté.

u.u_procp->p_pid donne le pid du processus courant.

*** Question 14

PID pour chaque processus, pourquoi et comment attribué ?

Identification unique.

Compteur global, incrémenté à chaque création de processus (retour à partir d'une certaine valeur). On a la possibilité d'avoir plusieurs processus qui dans la vie de la machine ont eu le même pid (mais pas en même temps).

*** Question 15

BIOS what ?

Le code chargé au démarrage de la machine, teste le matériel, et lance l'exécution du système.



* TD 2 : 02/10/2019

On traite aujourd'hui de la synchronisation entre processus.

*** Question 1

On doit prendre garde à la fonction noyau sleep (à ne pas confondre avec l'appel système sleep(3) ou avec la commande shell sleep(1))

#+BEGIN_SRC c
  int sleep(caddr_t chan, int pri);
#+END_SRC

le processus appelant va se mettre en attente sur l'adresse chan (la ressource avec lequel on se synchronise), et se réveillera avec la priorité pri.

#+BEGIN_QUOTE
Give up the processor till a wakeup occurs on chan, at which time the process enters the scheduling queue at priority pri. The most important effect of pri is that when pri<=PZERO a signal cannot disturb the sleep ; if pri >PZERO signals will be processed. Callers of this routine must be prepared for premature return, and check that the reason for sleeping has gone away.
#+END_QUOTE

La fonction noyau wakeup :

#+BEGIN_SRC c
  int wakeup(caddr_t chan);
#+END_SRC

*** Question 3 bis

Seulement avec les fonctions sleep et wakeup, coder deux fonctions noyau newtemp et hot.

newtemp est appelé par la sonde, avec en paramètre  : pour faire quoi ?
On ne sait pas ce que les fonctions doivent faire.

hot est censée être appelée par d'autres processus, tourner en boucle, et se terminer dès lors que la température t passée en paramètre est dépassée.

Or hot ne peut pas connaître la température, il n'existe pas de fonction qui permettre d'obtenir la température.

La solution passe par les variables globales du noyau : en effet, newtemp peut se contenter d'enregistrer la température dans cette variable globale.

#+BEGIN_SRC c
  // TEMPHB est un define

  int cpt = 0;
  int curtemp = -20000;

  void newtemp(int t)
  {
	  curtemp = t;
	  if(cpt) wakeup(&curtemp);
  }

  void hot(int max)
  {
	  int oldmask = gpl();
	  spl(TEMPHB);

	  cpt++;
	  while (curtemp <= max) {
		  sleep(&curtemp,PRI_TEMP);
		  spl(TEMPHB);
	  }
	  cpt--;

	  spl(oldmask);
  }
#+END_SRC

L'addresse de tmp est prise au hasard : la seule contrainte, c'est que wakeup et sleep portent sur la même adresse : on aurait pu prendre n'importe quoi (mais préfère donner qqch de signifiant, ici )

cpt permet de ne pas avoir à parcourir toute la table : il compte le nombre de processus qui ont appelé hot : on ne lance wakeup que si on sait que le nombre de processus endormis (donné par cpt) dans l'adresse &curtemp est au moins 1.

On peut se permettre de ne pas protéger cpt parce que le noyau dont on parle est non-préemptif : on ne peut pas avoir cpt modifié par plusieurs processus en même temps, ils devraient tous être en mode noyau, or un processus en mode noyau ne lâche le processeur que si il se termine, ou ne sort du mode noyau que s'il le demande explicitement.

*** Analyse de sleep, wakeup et setrun

**** sleep

sleep est appelé par un processus qui souhaite s'endormir.

rp pointe vers la structure proc du processus courant :
#+BEGIN_SRC c
  register struct proc *rp = u.u_procp;
#+END_SRC

spl est le set priority level : fonction qui permet de masquer toutes les interruptions moins prioritaires.
CLINHB au moins aussi prioritaire que l'horloge : on fait ça pour changer des champs des structures proc, qui ont une influence sur l'ordonnanceur : *ces champs sont archi critiques*, c'est uniquement pour cette raison que le noyau se permet cette opération extrêmement violente de masquer toutes les interruptions, même l'interruption horloge.

#+BEGIN_QUOTE
Interruption, c'est comme si j'appelais une fonction sans l'avoir voulu : les données de la fonction handler de l'interruption sont empilées au-dessus (en-dessous en fait) des données du processus, ce qui fait que quand l'appel est fini, c'est comme si on dépilait : le pointeur de pile est directement au bon endroit pour reprendre l'execution directement où elle a été laissée.

Jonathan Lejeune
#+END_QUOTE

p_wchan est mis à chan l'adresse de l'événement à attendre, p_stat est mis à SLEEP, et p_pri est mis à pri.

Puis on appelle l'ordonnanceur (swtch()) : le moment où on lâche vraiment le processeur, le vrai moment où on s'endort.

dans l'alternative non-prioritaire :
runin signale au swapper que le processus est swappable, si il a envie.

On doit remettre la condition de traitement du signal après le switch, parce que le PC du processus est sur l'instruction de la ligne 42 : c'est la qu'on reviendra quand le processus récupèrera le processeur : donc on doit remettre l'instruction de traitement du signal avant de sortir de la fonction.

**** wakeup

On parcourt toute la table des processus à la recherche du processus qui attendait l'événement passé en argument.

**** setrun

p->p_wchan est une adresse, champ de la structure proc, et représente l'adresse de l'événement que le processus attent (en effet, les sleep et les wakeup sont fait sur une adresse) : il est mis à 0 si le processus n'attend rien.

runrun est une variable globale : si runrun > 0 alors il faudra appeler swtch dès qu'on sort du noyau : grâce à cette variable-là, le noyau peut ne pas être préemptif :
Si je réveille qqn de plus prioritaire que moi, je devrai lui laisser la main, *mais pas avant d'avoir fini ce que je voulais faire dans le noyau*.

Est-ce que le processus que je viens de réveiller a été swappé : si oui, on le rétablit dans la mémoire.

*** Question 4

spl définit le masquage des interruptions jusqu'à un certain niveau passé en paramètre.
gpl donne en valeur de retour le niveau de masquage des interruptions.

On utilise spl pour protéger les variables globales du noyau.

*** Question 5

Tout de suite, dans la fonction. Pour wakeup, c'est uniquement quand on sort du mode noyau.
Commutation se fait soit par abandon volontaire du processus, soit à la sortie du mode noyau.

*** Question 6

Processus qui s'occupe de faire le transfert des pages du processus de la mémoire vers le disque, ou vice versa.

*** Question 7

pri de sleep est la priorité à laquelle on veut s'endormir : il compte pour savoir si on est interruptible par signal, et il sert à l'ordonnanceur.

*Ce n'est pas le truc qui est passé en argument de spl !!!*. On passe en général à spl une valeur défini par un define en en-tête.

*** Question 8

Déjà décrit plus haut

*** Question bonus : question annale

L'objectif est de transmettre une valeur générée par un processus à un de ses fils.

On ajoute le champ int p_value à la structure proc.

S'il existe au moins 1 fils, la fonction void send_value(int val) sauvegarde la valeur val dans le champ p_value de la structure proc de l'appelant.
Cette valeur sera lue par un de ses fils en utilisant la fonction int recv_value(). Cette fonction renvoie la dernière valeur sauvegardée dans le champ p_value de la structure proc du père.

Un processus ne peut pas écrire une nouvelle valeur dans son champ p_value tant qu'un de ses fils n'a pas lu la valeur précédente. Dès lecture d'un fils, le père peut écrire une nouvelle valeur.

Si le père n'a pas écrit de nouvelle valeur, le fils qui appelle recv_value() doit s'endormir jusqu'à qu'une nouvelle valeur soit écrite. (ce qui signifie qu'une valeur ne saurait être lue deux fois)


En gros, on cherche à implémenter un tube, avec un problème de lecteur-rédacteur relativement classique :


On peut endormir le processus qui appelle la fonction send_value (le processus père, donc) après qu'il a mis à jour la valeur : il sera réveillé par le processus fils qui aura lu la valeur : il pourra sortir de la fonction send_value en train d'être exécutée, et à ce moment là en lancer une nouvelle.

Sinon, une variable globale indique si la valeur est lisible ou non, et elle bloque le père ou les fils selon les cas. Il faut protéger cette variable pendant son édition (sections critiques à déterminer.)

Si la variable globale est à 0 et que des fils veulent lire la variable, ils sont endormis. Au moment où on remet la variable à 1, on wakeup les fils, et on commande un coup d'ordonnanceur pour la sortie du mode noyau.

Si la variable globale est à 1 et que le père veut écrire sur la variable, il est endormi. Au moment où la variable est remise à 0, on wakeup le père, et on commande un coup d'ordonnanceur pour la sortie du mode noyau.

La vraie bonne manière de placer la variable, c'est de rajouter un champ dans la structure proc, appelé p_msgstate, initialisé à 0 pour tout le monde (pas de message).



#+BEGIN_SRC c
  void send_value(int val)
  {
	  register struct proc *moi = u.u_proc;
	  register struct proc *fils = NULL;

	  /*
	     vérifier si des fils existent. Si aucun existe, on termine la
	     fonction.
	  ,*/
	  for (fils = proc; fils < &proc[NPROC]; p++) {
		  if (fils->p.ppid == moi->p.pid) {
			  break;
		  }
	  }

	  // Si on a au moins un fils :
	  if (fils != &proc[NPROC] ) {

		  /* Apparemment pas nécessaire */
		  spl(PRIO);
		  /* Si j'ai déjà un message dans ma boîte d'envoi, je m'endors */
		  while (moi->p_msgstatedown) {
			  sleep(&(moi->p_msgstatedown), PRIORITE);
		  }

		  spl(PRIO); // Apparemment pas nécessaire
		  moi->p_value = val;
		  moi->p_msgstatedown = 1;
		  spl(NORMAL);

		  /* Réveiller les éventuels fils */
		  wakeup(&(moi->p_msgstatedown));
	  }

  }


  int recv_value()
  {
	  register struct proc *pere, moi = u.u_procp;

	  /*
	     La version précédente initialisait à moi la variable pere.
	     Or si ça se trouve, le père est avant le fils dans la table des
	     processus. C'est même le plus probable.
	     On vérifie tous les processus de la table des processus à la
	     recherche du père.
	     On suppose que le père ne meurt pas : très important
	  ,*/
	  for (pere = proc; pere < &proc[NPROC]; pere++) {
		  if (pere->p_pid == moi->p_ppid) {
			  break;
		  }
	  }

	  /*
	    Si le père n'a pas de message dans sa boîte d'envoi, on s'endort
	    sur l'adresse de son indicateur de message descendant
	  ,*/
	  while (!(pere->p_msgstatedown)) {
		  sleep(&(pere->p_msgstatedown), PRIORITE);
	  }

	  /*
	    Si le père a un message sur sa boîte d'envoi, on lui dit qu'il n'en a
	    plus, on le réveille s'il s'est éventuellement endormi en essayant
	    d'en mettre un autre, et on retourne la valeur du message.
	  ,*/

	  /* On veut que cette suite d'instructions soit atomique */
	  spl(PRIO);
	  pere->p_msgstatedown = 0;
	  wakeup(&(pere->p_msgstatedown));
	  spl(NORMAL);

	  return pere->p_value;
  }
#+END_SRC


* TD 3 : 09/10/2019

On traite aujourd'hui du traitement des signaux.

#+BEGIN_SRC c
  int kill(pid_t pid, int sig);
#+END_SRC

Il est bien clair qu'on parle ici de l'appel système, kill(2), et non pas de la fonction du noyau (dont l'implémentation est masquée de l'utilisateur, dépend de l'implémentation de unix).

Moyen rudimentaire de communication.

Traité par le processus !

Unix implémente la "boîte à diodes" des signaux entrants sous la forme d'un vecteur de bits. Diode allumée \to bit à 1.
(On ne sait donc pas si on a reçu un signal plusieurs fois, ce n'est pas une file d'attente)

On doit savoir quoi faire pour chaque signal : notion de *handler* (une fonction). Si aucun handler défini, on a un comportement par défaut.

Cette fonction est exécutée en mode utilisateur : en effet, ça a été codé par l'utilisateur.

Pour définir un handler de signal, on utilisait l'appel système signal(2):

#+BEGIN_SRC c
  typedef void (*sighandler_t)(int);

  sighandler_t signal(int signum, sighandler_t handler);
#+END_SRC

(De nos jours, on utiliserait plutôt sigaction, recommandé par la norme POSIX)

*signal redéfinit le handler de signal de manière provisoire (seulement la prochaine réception) !!*

On doit donc faire appel à signal dans le handler lui-même si on veut garder le handler pour les prochains traitements de signal.

Il y a deux signaux dont on ne peut pas redéfinir les handlers :
- SIGKILL
- SIGSTOP

#+BEGIN_QUOTE
The signals SIGKILL and SIGSTOP cannot be caught or ignored.

man page signal(2)
#+END_QUOTE

*** Question 1

#+BEGIN_SRC c
  #include <stdio.h>
  #include <unistd.h>

  void bonjour(int i)
  {
	  printf("Bonjour\n");
	  signal(SIGALRM, bonjour);
	  alarm(1);
  }

  int main()
  {
	  bonjour();
	  while (true) {
		  sleep(N);
	  }
	  return 0;
  }

#+END_SRC

*** Question 2

Différence signal ignoré et signal masqué.

Les deux ne prennent pas en compte le signal.

Ignorer : Je détruis ce signal (cette occurence du signal, mais pas forcément les occurences futures).
Masquer : retarder le traitement d'un signal.

(pas de masquage de signaux dans cette version du noyau.
Soit on les ignore, soit on les traite de manière précise avec un handler)

*** Question 2, TD 2

Rappels des opérateurs bit à bit en C :

AND bitwise : &

3 & 2 : 0b011 & 0b010 = 0b010 soit 2
(la puissance de 2 l'emporte toujours)

OU bitwise : |
3 | 2 = 0b011 | 0b010 = 0b011 = 3

NOT bitwise : ~
~2 = ~0b010 = 0b101 = 5

XOR bitwise : ^
3^2 = 0b011 ^ 0b010 = 0b001 = 1

SHIFT right : >>
5>>2 = 0b101>>2 = 0b001 = 1

SHIFT left : <<
5<<2 = 0b101<<2 = 0b100 = 4

Par exemple, si je veux mettre de manière certaine le ième bit à 1 du vecteur de bit v, je fais :
#+BEGIN_SRC c
  v |= (1<<(i-1));
#+END_SRC

Sinon, pour mettre le ième bit à 0 de manière sûre, je fais :
#+BEGIN_SRC c
  v = v & ~(1<<(i-1));
#+END_SRC

Tester si le ième bit est à 1 :
#+BEGIN_SRC c
  (v & (1<<(i-1)));
#+END_SRC

Tester si le ième bit est à 0 :
#+BEGIN_SRC c
  !(v & (1<<(i-1)));
#+END_SRC

*** Question prof

Trouver dans les structures unix les champs ou variables relatives aux signaux :

**** Dans la structure user (swappable) :

int u_signal[NSIG];

Or NSIG = 19, d'après le fichier d'en-tête sig.h

Donc on a un tableau de 19 entiers ??? (soient 19*32 bits : c'est bien plus qu'il n'en faut)

Contient les pointeurs vers les handlers, en fait. Les int étaient en fait des adresses.

**** Dans la structure proc (toujours en mémoire) :

long p_sig;

Un long est un entier de la taille d'un mot mémoire : ici, on va dire 32 bits : sachant qu'on a 19 signaux, ça suffit.

Les bits de p_sig constituent le vecteur de bits qui donne les signaux reçus par le processus.

short p_clktimer (un truc qui sert à compter le temps avant l'alarme).

*** Question 3

On vient d'y répondre.

*** Question 4

On est bien d'accord qu'on peut assimiler les signaux à des espèces d'interruptions logicielles.

Des différences majeures :
- Le traitement de l'interruption est toujours exécuté en mode noyau, mais en mode utilisateur dans le cas d'un signal.
- Emetteur est le matériel dans le cas de l'interruption, le noyau ou le processus dans le cas du signal.
- Mécanisme matériel, indépendemment du noyau dans le cas de l'interruption, et mécanisme logiciel dans le cas du signal.

*** Question 5

Quels sont les rôles des fonctions kill, psignal, issig, psig, fsig, sendsig et ssig ?

Pourquoi il n'y a pas d'argument à ces fonctions ?

Les arguments sont stockés dans la structure user.

Les fonctions en question sont exécutées sur la pile s : il n'y a rien dans cette pile, elles vont donc chercher leurs arguments dans la structure user du processus.

Le retour de la fonction système est stockée dans une zone R0, pour que la fonction utilisateur appelante puisse récupérer ce retour via son pointeur vers R0 dans sa structure user.

**** La fonction ssig()

On enregistre dans a le premier argument de la fonction utilisateur signal.

a représentera le numéro du signal.

On vérifie que a est valide (pas en dessous de 0, au dessus de 19, ni égale à SIGKIL) : s'il ne l'est pas, on sort de la fonction en rendant une erreur.

On remplit le retour de la fonction via la structure u_ar0

On met à jour le pointeur de fonction (ligne 15) : on met le deuxième argument de la fonction utilisateur signal dans le champ idoine de la structure user du processus.

(0 correspond à par défaut, 1 correspond à ignorer)

On remet à zéro la "diode" du signal.

**** La fonction kill()

On cherche dans la table des processus.

On doit intervertir le numéro du signal et le numéro du pid dans les noyaux modernes.

On met dans a le pid du processus à qui on veut envoyer un signal.

On boucle dans la table des processus :
- On vérifie que le p_stat du processus bouclé n'est pas NULL. (Il n'y a pas de processus dans ce champ)
- On vérifie que le pid du processus à signaler n'est pas 0, et que le pid du processus à signaler n'est pas le pid du processus bouclé (s'il ne l'est pas, on passe directement à la prochaine itération)
- Si le processus à signaler est 0 , ça veut soit dire qu'on veut s'adresser aux processus du même terminal, ou au processus swapper ou au processus init, on skip directement.
- On vérifie que (on n'est pas root AND on est bien proprio du processus) 

Si ces vérifications sont passées, on incrémente un compteur f et on lance la fonction psignal(p, u.u_arg[0]) (en n'oubliant pas que u.u_arg[0] contient le signal)

psignal a bien des arguments !
C'est normal, psignal n'est appelé que par d'autres fonctions noyau.

**** La fonction psignal(struct proc_p *p, int sig)

On vérifie que le signal existe bien.

On met le bit idoine du vecteur de bit du processus destinataire à 1 (quel que soit l'état du processus)

Si le processus n'est pas endormi avec une forte priorité, on le réveille.

**** La fonction issig()

Tant que le vecteur de bits du processus courant n'est pas exactement 0 (soit tant qu'on a pas vidé les signaux en attente) :

- On garde dans n le numéro du signal le plus bas (d'après l'analyse de la fonction fsig)

issig retourne le numéro du signal le plus bas reçu s'il y en a un, 0 sinon.

Ca veut dire que les signaux de numéro les plus bas sont traités de manière prioritaire : on peut avoir une famine pour les signaux les 

ligne 84 : si on a 1 au bit de poids faible, on sait qu'on veut ignorer : les adresses des handlers sont forcément alignées sur le mot mémoire, donc multiples de 4

Si on voulait ignorer (ligne 86), on remet le bit correspondant à 0.

**** La fonction fsig(struct proc *p)

Une fonction bien utile : retourne le signal de numéro le plus bas.

**** La fonction psig()

if(issig()) psig(); est la séquence exécutée systématiquement au retour en mode utilisateur.

Une version simplifiée, on ne va pas s'amuser à mettre tous les handlers par défaut.

psig récupère le numéro du signal à traiter dans n.
Il vérifie que ce n'est pas nul (ça ne devrait pas l'être si on suit la séquence plus haut)

Il remet le bit à 0.
Si le handler n'est pas 0 (càd si on ne veut pas utiliser le handler par défaut), on va lancer le handler, après l'avoir enlevé de la table des handlers (rappelons-nous, temporaire)

Si le handler est à 0, on fait les traitements par défaut.

**** La fonction sendsig(void *handler, int num)

La fonction charger d'appeler la fonction handler définie par l'utilisateur.

On manipule directement la pile de l'utilisateur pour le faire exécuter la fonction qu'il a lui-même écrite, à sa prochaine sortie du mode noyau.

Dans l'ordre :
- on enregistre dans sp le pointeur de pile enregistré du processus (u.u_ar0[SP]), pile augmenté d'un mot mémoire (en effet la pile croît de l'adresse la plus haute 0xffffffff vers l'adresse la plus basse 0x00000000).
- on alloue effectivement la mémoire de 0xffffffff jusqu'à sp (on imagine que la fonction grow alloue effectivement de la mémoire de 0xffffffff, ou un autre point de référence, à l'adresse qui lui est passée en paramètre)
- On enregistre cette nouvelle adresse modifiée dans le pointeur de pile enregistré du processus (u.u_ar0[SP]) (la pile est maintenant "officiellement" augmentée d'un mot mémoire)
- On enregistre dans ce mot mémoire qu'on vient d'allouer le PC (Program Count, AKA Compteur Ordinal, l'adresse le l'instruction à exécuter, tya compris fréro) enregistré du processus (u.u_ar0[PC])
- On met dans cette variable de sauvegarde du registre PC l'adresse de la fonction handler.

De cette manière, quand le processus repasse en mode utilisateur et récupère le processus, il exécute la fonction handler comme si c'était lui qui l'avait appelé.

*** Petit exo type examen

Implémenter un truc qui permet de masquer les signaux.

Requiert de modifier la fonction fsig.

Et de noter qqpart (dans la struct proc du processus) les indicateurs de signaux masqués.

On suppose dans la struct proc un vecteur de bits qui correspondent aux bits masqués.

Si le signal est masqué, fsig ne repère même pas le signal.

En C ANSI :

#+BEGIN_SRC c
  int fsig(struct proc *p)
  {
	  register int n, i, m, r;

	  n = p->p_sig;
	  m = m->p_mask; // Le vecteur des signaux masqués

	  r = n & ~m; // r correspond au vecteur des signaux non-masqués

	  for (i = 0; i < NSIG; ++i) {
		  if (r & 1) return (i);
		  r >>= 1;
	  }

	  return 0;
  }
#+END_SRC

Il faut aussi une fonction noyau pour ajouter un masque dans cette structure, une pour l'enlever. (assez trivial : on a juste un bit à bouger, juste des vérifications chiantes à faire avant)

Il faut aussi modifier la boucle while dans issig, de manière à éviter la boucle infinie (on ne teste plus while de p->p_sig, mais while de (p->p_pig & ~p->p_mask))


* TD 4 : 16/10/2019

On traite aujourd'hui de la question du temps et de l'ordonnancement.

*** Analyse des structures

L'interruption horloge, ou plutôt sa gestion, est écrite dans le fichier clock.

#+BEGIN_QUOTE
clock is called straight from real time clock interrupt.

Code source de Unix v6
#+END_QUOTE

La structure callo dans la fichier d'en-tête callo.h, permet de créer des appels réguliers.

On a un tableau statique de cette structure de taille NCALL, défini par une macro à la compilation.

On a dans le fichier param.h un define de l'inhibition des interruptions horloge.

Dans la structure proc, p_time, p_clktime, p_cpu.
p_time définit le temps pendant lequel on a été résident à un endroit précis en mémoire ou dans le swap (remis à 0 dès qu'on est swappé ou déswappé, mais incrémenté tout le temps).
p_clktime donne le temps avant l'alarme.
p_cpu donne l'utilisation du cpu.

On a une fonction accessible à l'utilisateur, time(2), définie comme suit.

#+BEGIN_SRC c
  #include <time.h>

  time_t time(time_t *tloc);
#+END_SRC

*** Question 1 : analyse des fonctions

La variable globale time fait appel au temps global, soit le nombre de secondes depuis 1/1/1970

**** clock()

On créé deux entiers externes (on fait appel à des variables déjà définies ailleurs).

Un pointeur vers une structure callo, dans un registre.

Un pointeur vers un entier, dans le registre.

On regarde le premier élément du tableau des callouts.

On parcourt le tableau des callouts :
Si c_time est inférieur à 0 et qu'il n'y a pas de fonction dans le champ c_func, on passe à l'élément suivant.
Sinon on décrémente le champ c_time et on sort de suite (plus de précisions dans l'explication de l'algorithme de callo)

idleflag est à 1 signifie qu'il n'y a aucun processus à élire.
Si l'usage du cpu d'un processus est en-dessous de 80, on incrémente cet usage.
L'usage du cpu est borné à 80.

On incrémente les stats, en vérifiant bien qu'on est pas idle.

On incrémente lbolt, puis on vérifie qu'il est supérieur ou égal à HZ, si c'est le cas on rajoute le flag WAKEUP.

HZ donne le nombre de ticks qu'on doit avoir en une seconde.
Quand lbolt arrive à HZ, on sait qu'on a passé une seconde.

On vérifie que le flag WAKEUP est vrai sur iaflags, et on appelle la fonction realtime(). (Ce n'est pas fait dans la fonction clock, mais ailleurs. On croira Jonathan Lejeune sur parole)

**** realtime()

On créé un pointeur vers une structure proc.

On remet lbolt à zéro.

On incrémente la variable globale time.

On incrémente runrun pour forcer une élection juste avant de sortir du mode noyau.

On réveille tout le monde à l'adresse lbolt (Quelqu'un qui veut être réveillé toutes les secondes, souvent des processus qui utilisent des drivers).

On parcourt la table des processus.

Si il y a bien un processus, on incrémente le resident time jusqu'à une limite de 127.

Si le temps jusqu'au prochain signal SIGALRM est 0, on traite le signal SIGALRM.

(utilisé par la fonction utilisateur alarm)
#+BEGIN_SRC c
  #include <unistd.h>

  unsigned int alarm(unsigned int seconds);
#+END_SRC


On divise le cpu usage par 2 : On applique le decay de l'algorithme d'ordonnancement de UNIX.

Si le processus a une prio faible, on remet à jour sa priorité selon l'algorithme unix, en appelant setpri.

Ensuite, si pression mémoire (testée par runin), on réveille le swapper.

**** setpri

En gros applique l'algorithme vu en cours, pour recréer un système de round robin sans queue.

*** Question 2

timeout permet de planifier l'exécution d'une fonction dans un certain temps.

Cette fonction prend en argument un pointeur vers une fonction, une chaîne de caractères pour les arguments et un entier qui donne le temps.

On créé deux pointeurs vers des structures callo.
Deux entiers, dont un dans le registre.

Le premier pointeur vers la structure callo est peuplé avec le premier élément de la table callout.

On met dans un des deux entiers le masquage des interruptions courant.
On met dans l'autre entier la valeur du paramètre.

On change le masquage des interruptions au niveau le plus puissant (CLINHB).

On parcourt la table callout.

Si on a bien une fonction dans la structure callo courante, et que le temps incrémentiel est en-dessous de t le temps passé en paramètre.

On applique l'algorithme décrit plus bas dans l'exercice.

En fait, l'idée est de ne noter que les temps cumulés à la prochaine fonction : il faut donc, lorsqu'on rajoute une fonction à exécuter plus tard, descendre dans le tableau en comparant aux temps de la fonction dans le tableau. Si c'est inférieur, c'est qu'on a trouvé notre place, auquel cas on shift tout le monde vers le bas. Si c'est supérieur, on décrémente le temps de la fonction à ajouter, et on compare au prochain élément.

De cette manière, lors d'une interruption horloge, on peut se contenter de ne décrémenter que le champ time du premier élément, ce qui mettra à jour tous les éléments du tableau :

#+BEGIN_QUOTE
The time in each structure entry is the number of HZ's more than the previous entry. In this way, decrementing the first entry has the effect of updating all entries
#+END_QUOTE

**** Petit exercice d'entraînement

On applique timeout(f, arg_f, 11) et timeout(g, arg_g, 5)

2 interruptions horloges

Puis timeout(h, arg_h, 3)

1 interruption horloge

Puis timeout(i, arg_i, 8)

Dessiner l'état du tableau callout à tout moment (on part du principe que la table est vide au début).


Tout est vide
| i | func | arg | time |
|---+------+-----+------|
| 0 |    0 |     |      |
| 1 |    0 |     |      |
| 2 |    0 |     |      |
| 3 |    0 |     |      |
| 4 |    0 |     |      |
| 5 |    0 |     |      |
| 6 |    0 |     |      |
| 7 |    0 |     |      |
| 8 |    0 |     |      |

| i | func | arg   | time |
|---+------+-------+------|
| 0 |    f | arg_f |   11 |
| 1 |    0 | '\0'  |  -11 |
| 2 |    0 |       |      |
| 3 |    0 |       |      |
| 4 |    0 |       |      |
| 5 |    0 |       |      |
| 6 |    0 |       |      |
| 7 |    0 |       |      |
| 8 |    0 |       |      |

| i | func | arg   | time |
|---+------+-------+------|
| 0 |    g | arg_g |    5 |
| 1 |    f | arg_f |    6 |
| 2 |    0 | '\0'  |  -11 |
| 3 |    0 |       |      |
| 4 |    0 |       |      |
| 5 |    0 |       |      |
| 6 |    0 |       |      |
| 7 |    0 |       |      |
| 8 |    0 |       |      |

| i | func | arg   | time |
|---+------+-------+------|
| 0 |    g | arg_g |    4 |
| 1 |    f | arg_f |    6 |
| 2 |    0 | '\0'  |  -11 |
| 3 |    0 |       |      |
| 4 |    0 |       |      |
| 5 |    0 |       |      |
| 6 |    0 |       |      |
| 7 |    0 |       |      |
| 8 |    0 |       |      |

| i | func | arg   | time |
|---+------+-------+------|
| 0 |    g | arg_g |    3 |
| 1 |    f | arg_f |    6 |
| 2 |    0 | '\0'  |  -11 |
| 3 |    0 |       |      |
| 4 |    0 |       |      |
| 5 |    0 |       |      |
| 6 |    0 |       |      |
| 7 |    0 |       |      |
| 8 |    0 |       |      |

| i | func | arg   | time |
|---+------+-------+------|
| 0 |    g | arg_g |    3 |
| 1 |    h | arg_h |    0 |
| 2 |    f | arg_f |    6 |
| 3 |    0 | '\0'  |  -11 |
| 4 |    0 |       |      |
| 5 |    0 |       |      |
| 6 |    0 |       |      |
| 7 |    0 |       |      |
| 8 |    0 |       |      |

| i | func | arg   | time |
|---+------+-------+------|
| 0 |    g | arg_g |    2 |
| 1 |    h | arg_h |    0 |
| 2 |    f | arg_f |    6 |
| 3 |    0 | '\0'  |  -11 |
| 4 |    0 |       |      |
| 5 |    0 |       |      |
| 6 |    0 |       |      |
| 7 |    0 |       |      |
| 8 |    0 |       |      |

| i | func | arg   | time |
|---+------+-------+------|
| 0 |    g | arg_g |    2 |
| 1 |    h | arg_h |    0 |
| 2 |    f | arg_f |    6 |
| 3 |    i | arg_i |    0 |
| 4 |    0 | '\0'  |  -11 |
| 5 |    0 |       |      |
| 6 |    0 |       |      |
| 7 |    0 |       |      |
| 8 |    0 |       |      |

*** Rappel

A chaque interruption d'horloge :
- clock()
- if(iaflag & WAKEUP)  realtime()
- if(iaflag & CALOUT) restart()

*** Coder la fonction restart

#+BEGIN_SRC c
  int restart()
  {
	  struct callo *p1;
	  struct callo *p2;

	  while ((&callout[0]->c_time == 0) &&
		 (&callout[0]->c_func != 0)) {

		  p1 = &callout[0];
		  ,*(p1->c_func)(p1->c_arg);

		  p2 = p1 + 1;

		  while ((p2-1)->c_func != 0) {
			  (p2-1)->c_func = p2->c_func;
			  (p2-1)->c_arg = p2->c_arg;
			  (p2-1)->c_tim = p2->c_tim;
			  ++p2;
		  }
	  }

	  return;
  }
#+END_SRC

On n'a pas besoin de masquer des interruptions, parce qu'on est déjà dans une interruption horloge.

*** Coder une fonction noyau sleep qui ne se servirait que de delay

On a bien compris ce que delay faisait : il demande à être réveillé dans ticks ticks et s'endort.

#+BEGIN_SRC c
  sleep()
  {
	  int sec = u.u_args[0];
	  int ticks = sec * HZ;
	  int expected_date = time + sec;
	  delay(ticks);

	  if (time < expected_date) {
		  u.u_ar0[R0].expected_date - time;
	  } else {
		  u.u_ar0[R0] = 0;
	  }
  }
#+END_SRC

*** Question type examen

Implémenter untimeout(ident)

#+BEGIN_SRC c
  untimeout(int ident)
  {
	  struct callo *p1;
	  struct callo *p2;

	  p1 = &callout[O];

	  while (p1->c_func != 0) {
		  if (p1->c_ident == ident) {
			  p2 = p1 + 1;
			  p2 ->c_time += p1->c_time;

			  while ((p2-1)->c_func != 0) {
				  (p2-1)->c_func = p2->c_func;
				  (p2-1)->c_arg = p2->c_arg;
				  (p2-1)->c_ident = p2->c_ident;
				  (p2-1)->c_time = p2->c_time;
				  ++p2;
			  }
		  }
		  ++p1;
	  }
  }
#+END_SRC


* TD 5 : 23/10/2019

On va parler aujourd'hui du mécanisme de commutation.

Comment faire pour passer d'un processus à un autre ?

La commutation, c'est le mécanisme du noyau qui permet le partage du temps processeur entre les processus (temps partagé).

*** Rappels de l'automate d'état

Un processus passe du mode élu S au mode prêt quand il a incrémenté runrun et qu'il perd l'élection.

Un processus passe du mode élu S au mode bloqué avec sleep().

Un processus passe du mode élu U au mode zombie avec exit().

*** La commutation

#+BEGIN_THEOREM
*Un processeur (ses registres visibles du processeur) ne connaît pas les adresses physiques*, mais seulement des adresses virtuelles.

Il existe certains registres (très peu) qui doivent connaître des adresses physiques.
#+END_THEOREM

Le compteur ordinal, en particulier, ne connaît que des adresses virtuelles.

Du point de vue du processeur, la mémoire ressemble à ça :

|---------|
| Zone U  |
|---------|
| OS      |
|---------|
| Pile U  |
|---------|
| Données |
|---------|
| Code    |
|---------|

Chacune des zones est mappée vers une zone de mémoire physique (la correspondance est dans la table des pages).
La zone OS est toujours mappée vers le même endroit (elle ne bouge pas dans la mémoire physique, et elle n'est jamais swappée).

On a un registre qui donne l'adresse *physique* de la table des pages (les registres systèmes ont le droit de stocker directement des adresses physiques).

p_addr est l'adresse physique de la zone mémoire du processus.


La commutation consiste donc en :
- Changer la traduction virtuelle-physique (opération de pointeur simple, peu coûteux)
- Changer le pointeur de pile (registres visibles de l'utilisateur)

On part du principe que tout processus qui est potentiellement élu avait appelé switch avant de perdre le processeur. Donc en fait, quand je change la table des pages et le pointeur de pile, en fait je sors de la fonction *pile au bon endroit* : la valeur à mettre dans le compteur ordinal, qu'on trouve en pointe de pile pour être retrouvée à chaque sortie de fonction, est déjà la bonne puisque c'est celle qu'on avait mis à l'appel de switch au temps jadis.

Le pointeur d'instruction reste donc le même (il doit bien exécuter le reste de la fonction switch), mais on sait qu'on retrouvera le bon.

#+BEGIN_THEOREM
Deux adresses physiques contigües en nombre ne sont pas forcément contigües en matériel
#+END_THEOREM

Segments mémoire d'un processus :
- Code
- Pile U
- Zone U (pile S plus struct u)
- Données (tas et variables globales)

Puis, ailleurs, dans la zone système de la mémoire :
- Code de l'OS
- Données de l'OS, variables globales
- Structures de données pour l'OS.

La fonction retu :
Prend en paramètre l'adresse physique de la mémoire des processus.
Remplace la table des pages courante par la table des pages adressée physiquement par le paramètre (en vrai, uniquement la partie de la table des pages qui mappe les adresses virtuelles de la zone U vers les adresses physiques. Le reste du travail est fait par une autre fonction, sureg())

**** Fichier text.h

x_daddr : l'adresse du bloc disque.
x_caddr : l'adresse du segment mémoire du texte.

x_count : nombre de références totales (quand c'est 0, on sait qu'on peut flush).
x_ccount : nombre de références par des processus chargés (quand c'est 0, on sait qu'on peut swap : on ramènera du disque en même temps que le processus qu'on ramènera).

*** Question 3

**** Analyse de swtch()

On déclare un pointeur (static : enregistré dans le segment de données plutôt que dans la pile, survit donc à la fonction, mais reste visible uniquement par celle-ci) vers une structure proc.
Deux entiers (dans le registre).
Un pointeur vers une structure proc (dans le registre).

Seulement si p est le pointeur NULL, on fait pointer p vers le premier élément du tableau (la struct proc du processus 0, le scheduler).
Si p n'est pas le pointeur NULL, alors il garde la valeur qu'il avait lors du dernier appel à swtch() : c'est pour cette raison qu'on a déclaré p avec le mot-clé static. Pourquoi on fait ça ? On veut que la recherche reprenne exactement là où on l'a interrompu la dernière fois.

On met le pointeur de pile dans la structure u du processus qui a appelé swtch (dans le champ u_rsav, plus spécifiquement).

savu sauvegarde le SP dans la structure passée en paramètre.

On charge dans les registres du processeur les registres sauvegardés en mémoire du scheduler (le processus 0) : u a changé.

aretu permet de changer le pointeur de pile sans commuter (retu en un peu moins puissant).

On a un label de loop :
runrun est remis à 0
On fait pointer rp vers p, p vers NULL, et n vers 128.

On regarde tous les processus prêts et chargés en mémoire.

On garde le plus prioritaire.

Quand on sort de la boucle après avoir décrémenté i NPROC fois (on ne fait plus d'un tour complet), on a un pointeur p vers la processus à élire.

Si j'ai trouvé aucun processus p, alors p est resté à NULL.
Je remets p à rp, j'attends la prochaine interruption, et je réessaye.

Si j'en ai un, j'alias son pointeur statique dans rp.

Je charge le registre qui donne l'adresse de sa table des pages.

sureg() : en fait, retu ne fait que changer la zone U, sureg() change les autres segments genre la pile U, les données et le code. On n'a pas fait sureg à l'entrée dans le processus 0 car ce processus n'a pas de pile, ni de code, ni de données (il écrit dans la pile du noyau, il manipule des données globales du noyau, et son code est celui du noyau)

ligne 69-72 : réponse dans deux épisodes.
Avant-goût : On vérifie si le champ p_flag du processus sélectionné porte le flag SSWAP (est-ce que le processus a été créé dans le swap).
Si oui, alors on l'enlève, et on change le pointeur de pile vers la valeur enregistrée dans u_ssav la dernière fois qu'on a appelé savu (on sait qu'on a appelé savu, parce qu'on part du principe que tous processus qui a existé a appelé swtch(), et que swtch() fait un appel à savu).

Si on a élu un processus, c'est qu'il est chargé en mémoire. Donc ce flag SSWAP peut être enlevé et on l'enlève. En fait, c'est lié au fork. Quand un processus fork, s'il n'y a pas assez de mémoire pour le nouveau processus, on peut immédiatement swap out le fils. Pendant ce swap-là, on enregistre le pointeur de pile du fils dans son u_ssav, avant de le swap out.

Si ensuite par chance il s'est fait reswap in, on rétablit son pointeur de pile. (pas encore très clair)

return(1) : Si jamais le processus que j'ai élu, c'est la première fois qu'il est là (via un fork). Permet de dire vrai. [en vrai, on verra ça dans 2 séances].

*** Passage mode U - mode S (et vice versa)

Une trappe : Fonction appelée quand on passe du mode U au mode S. Cette fonction est définie au niveau matériel, elle est écrite par le constructeur.

*** Question 5

Appel système (la fonction utilisateur) doit renseigner :
- La fonction système qu'on veut exécuter (en fait le numéro de l'appel système dans un registre)
- On met les arguments à passer à la fonction système dans un tableau (et on met l'adresse dans un registre)
- On appelle la fonction trap() : défini au niveau du matériel (changement de contexte, sp dans la zone U), on passe en mode S (on change la valeur d'un processus), déroutement vers l'appel système

- On sauvegarde les registres utilisateurs dans u.u_ar0
- On va chercher les arguments et on les met dans u.u_arg
- Réinitialiser le u_error
- savu(u.u_qsav) : on garde un SP vers là où on est dans la fonction trap
- On appelle la fonction noyau

A la sortie de la fonction noyau :

- Checker runrun, swtch() le cas échéant
- Checker les signaux, psig() le cas échéant
- Copier u.u_error dans errno

- On restaure les registres qu'on a sauvegardés avant de passer en mode S.

On revient en mode U (PC vers code U).

L'interruption, ce sera un sous-ensemble :
- TRAP : changement de contexte, déroutement
- Sauvegarde des registres utilisateurs
- Exécution "handler" interruption
- Vérification runrun
- Vérification signaux
- Restauration des registres utilisateurs

#+BEGIN_THEOREM
Quand on réveillé par un signal, on sort du mode noyau : on dépile toute la pile S jusqu'à TRAP, et on sort de TRAP
#+END_THEOREM

Dans les structures rsav, ssav, qsav sont enregistrés des SP qui correspondent à des états différents de quand ils ont été enregistrés (ssav, on l'a déjà vu, sert à enregistrer le SP juste avant de se faire swap).


* TD 6 : 20/11/2019

Petite reprise de l'épisode précédent, on a pu reprendre la fonction swtch().

On traite aujourd'hui de la naissance des processus.

*** Question 1

Modifier le programme pour créer N processus fils. Chaque processus doit incrémenter la variable a, afficher la nouvelle valeur et se terminer. Le processus original attend la fin des N fils puis affiche a avant de se terminer.

On part du principe, même si la consigne ne le précise pas, que le père doit créer les N fils avant de les attendre. On doit avoir, à un point dans le programme, N fils existant en même temps.

Notre solution :

#+BEGIN_SRC c
  #include <stdio.h>
  #include <sys/types.h>
  #include <unistd.h>
  #include <stdlib.h>
  #include <sys/wait.h>

  #define N 10

  int main(int argc, char *argv[])
  {
	  int a = 10;

	  for (int i = 0; i < N; ++i) {
		  if (fork() == 0) {
			  ++a;
			  printf("%d\n", a);
			  exit();
		  }
	  }

	  for (int i = 0; i < N; ++i) {
		  wait();
		  printf("%d\n", a);
	  }

	  return 0;
  }
#+END_SRC

Quelles sont les valeurs affichées pour chacun des processus ?

11 : Chaque fils incrémente sa propre version de la variable a.

Le père affiche par contre systématiquement 10. C'est sa propre version de la variable a qu'il regarde, et celle-ci n'a été modifiée par personne.

*** Fonctionnement de fork()

On enregistre dans deux registres visibles du processeur deux pointeurs p1 et p2 vers une structure proc.

On sauve dans p1 le pointeur vers le processus courant.

On itère dans la table des processus à la recherche d'une entrée libre (telle que p_stat == NULL), on fait pointer p2 vers cette entrée.
Si on est à la fin de la table des processus et qu'on a pas trouvé de place libre, on retourne une erreur, on met une valeur d'erreur sur la pile utilisateur pour la valeur de retour de l'appel système côté user.

Sinon, on appelle newproc qui créé le fils, et en fonction de son retour (newproc retourne 1 pour le processus fils, et 0 pour le processus père), on retourne 0 (respectivement le pid du fils créé) et on initialise des champs (les champs avec les stats de temps) de la structure proc du fils à 0 (respectivement on ne fait rien).

Ce fonctionnement est basé sur la capacité de newproc à retourner une valeur distincte selon si le processus courant est le père et le fils.

On va se pencher maintenant sur le fonctionnement de la fonction qui fait le gros du travail, la fonction newproc.

*** Fonctionnement de newproc

La fonction newproc déclare dans sa pile deux entiers (a1 et a2), deux pointeurs vers une struct proc p et up.

Elle demande aussi un pointeur vers une struct proc rpp dans un registre, ainsi qu'un pointeur vers un entier et un entier.

Un des pointeurs vers struct proc dans la pile est initialisé à NULL.

La variable globale mpid est incrémentée.

Le pointeur dans le registre *parcourt inconditionnellement la table des procs*, et ce dans sa totalité. Si il trouve une place libre, il stocke son adresse dans le pointeur précédemment initialisé à NULL.

Si le pid d'un des éléments de la table est égal à mpid, on incrémente mpid, et on recommence le parcours de la table *du début*.

Si on sort de la boucle et que le pointeur initialisé est toujours à NULL, c'est qu'on a trouvé aucune entrée libre. Dans ce cas, on a une panique noyau, Cette situation ne peut pas arriver parce qu'on a vérifié avant l'appel à newproc l'existence d'une entrée libre.

À la sortie de cette boucle, on a si tout va bien un pointeur vers une entrée libre, ainsi que dans mpid une valeur qu'on sait avec certitude n'être égale à aucun des pid présents dans la table (ni même à aucun des pid reliquats des entrées libres, ce qui ne semble pas nécessaire à première vue).

Le pointeur vers entier qu'on a stocké dans le registre est cast en pointeur vers struct proc (est-ce seulement possible en C K&R, pas sûr...) pour stocker un pointeur vers le processus courant (donc le père qui s'apprête à créer son fils).

Le pointeur vers le processus courant est aussi stocké sur la pile.

Dans l'entrée libre de la table des procs qu'on a sélectionné, on met l'état SRUN, le flag SLOAD, l'UID du père, le [pseudo-]terminal du père, le nice, le pointeur vers la zone de texte, mpid dans le champ pid, et le pid du père dans le champ ppid, et 0 dans le champ du temps résident.

Les descripteurs de fichier du père sont passés au fils (le pointeur vers entier casté en pointeur vers struct proc redevient pointeur vers entier au passage).

Le compteur de références vers la zone de texte est incrémenté, de même que le compteur de références par des processus chargés en mémoire.

Le compteur de références à l'inode du répertoire courant (qui est un fichier, ne l'oublions pas) est incrémenté.

On sauvegarde le pointeur de pile courant dans la structure u_rsav du processus courant.

Le pointeur vers la structure proc du processus courant est sauvée (ligne 100), le pointeur vers la structure proc de la structure user du processus courant est écrasé avec celui vers la structure proc du fils : le père prend l'identité de son fils.

Le champ taille mémoire du processus fils prend la taille de son père.

On tente d'allouer dans la mémoire la place correspondant à cette taille mémoire. Deux cas possibles :

**** L'allocation échoue

Si cette allocation échoue pour manque de place, on écrit alors l'image mémoire du processus dans le swap : on fait passer l'état du processus père à SIDL, on stocke dans le champ d'adresse de l'image mémoire du fils celle du père.

On sauvegarde le pointeur de pile courant dans la structure u_ssav du père, on copie (sans effacer, attention !) l'image mémoire du père dans le swap (la copie sera utilisée par le fils).

Ici, faisons bien attention : le pointeur de pile courant qu'on a sauvé à la ligne 114 fait bien partie des données qu'on est en train de copier. À la fin de cette copie, le fils a bien le pointeur de pile de là où on est maintenant sauvé dans sa propre structure u_ssav aussi.

Le pointeur de pile courant qu'on avait sauvé à la ligne 99 fait aussi partie des données qu'on a copié.

On met l'état du fils à SSWAP, et on remet l'état du père à SRUN.

**** L'allocation réussit

- Soit cette allocation réussit, on copie simplement tous les blocs un à un de l'image mémoire du père vers la zone mémoire juste allouée pour le fils.

**** Sortie de l'alternative

À ce moment, le père récupère son identité.

On sort de la fonction, avec la valeur de retour 0.

**** Et le fils ?

À ce moment, le fils n'a encore jamais jamais eu le processeur de sa vie, il n'a exécuté aucune instruction (en particulier aucune instruction de cette fonction)

Où est-ce que le fils va apparaître ? Autrement (mieux) dit, où est la toute première instruction que le fils va exécuter ? Vous l'avez compris, dans le code de swtch() : le registre pointeur d'instruction du processeur est à la ligne 57 du code de swtch() juste avant que le fils "obtienne le processeur".

Transportons-nous maintenant dans le code de swtch(), à la ligne 57. Le processeur exécute l'appel à la fonction retu.

On le rappelle, la fonction retu permet d'activer la partie de la table des pages qui décrit la correspondance entre l'adresse virtuelle et l'adresse physique de la zone U. Autrement dit, permet (entre autres) de changer de structure u.

retu implique entre autres un appel à aretu, qui copie simplement de l'entier passé en paramètre vers le registre pointeur de pile du processeur. La fonction retu appelle aretu sur u_rsav.

À la fin de cette instruction, le pointeur de pile dans le registre idoine du processeur est mis à la valeur qui lui avait été passée à la ligne 99 de la fonction newproc. Ce pointeur de pile est une adresse virtuelle, dont la correspondance avec l'adresse physique est donnée par la table des pages : l'appel à retu garantit que cette adresse se résout vers l'adresse physique de la pile du fils et non du père (parce que l'adresse virtuelle du pointeur de pile du père et de celui du fils peuvent parfaitement être encore la même : on a eu une copie simple à 115 ou à 124 de newproc).

Donc à ce moment là, le registre pointeur de pile contient l'adresse du mot de la pile qui stocke le mot d'instruction correspondant à l'instruction de la ligne 15 de la fonction fork (l'instruction de comparaison, plus précisément : l'instruction C de la ligne 15 se transcrit en au moins de deux instructions assembleur : un instruction de stockage de la valeur de retour, et une instruction de comparaison de la valeur de retour à 1 : c'est bien de cette deuxième instruction qu'il est question ici).

Le processeur appelle sureg, ce qui lui permet d'activer le reste des correspondances de la table des pages (celles qui donnent la pile U, les données, le code).

Si le processus sort maintenant de la fonction, il sort avec la valeur de retour 1, et il se retrouve à devoir exécuter la deuxième partie de l'instruction de la ligne 15 de la fonction fork(), et ainsi de suite.

Si le processus avait été créé dans le swap (il en a depuis été ramené, vous vous en doutez bien), on enlève son flag SSWAP, et on charge dans le registre pointeur de pile l'adresse sauvée à la ligne 114 de newproc.

Donc à ce moment là, exactement comme plus haut, le registre pointeur de pile contient l'adresse du mot de la pile qui stocke le mot d'instruction correspondant à l'instruction de comparaison de la ligne 15 de la fonction fork.

Si le processus sort maintenant de la fonction (et il le fait), il sort avec la valeur de retour 1, et il se retrouve à devoir exécuter la deuxième partie de l'instruction de la ligne 15 de la fonction fork(), et ainsi de suite.

Quoiqu'il se soit passé avec ces histoires de swap à la naissance ou non, on veut qu'à la sortie de la fonction swtch(), le processus fils aille exécuter l'instruction de comparaison de la ligne 15, et ignore tout le bruit potentiellement arbitraire qui a pu être mis dans la pile entre temps. Les sauvegardes de pointeur de pile dans la fonction newproc() et ses chargements à la fin de swtch() répondent à cette exigence.

De surcroît, la valeur de retour de swtch() sert à distinguer le père et le fils. Le père arrive à l'instruction de comparaison de la ligne 15 de fork() en venant de newproc, donc avec une valeur de retour de 0. Le fils arrive à cette même instruction depuis swtch(), donc avec une valeur de retour de 1.

*** Apartés et aphorismes nuls

#+BEGIN_THEOREM
Le processeur ne voit pas de processus, il ne voit que des instructions.
#+END_THEOREM

#+BEGIN_THEOREM
Un processus n'obtient pas le processeur, c'est le processeur qui va chercher ses instructions dans le contexte d'un processus plutôt que d'un autre.
#+END_THEOREM

*** La fonction exit()

On alloue, dans les registres visibles du processeur, un pointeur vers un entier, un entier, un pointeur vers une structure proc.

On enlève le flag STRC au processus courant.

On met 1 à tous les éléments de la table u_signal du processus courant, ce qui revient donc à effectivement ignorer tous les signaux reçus par le processus courant (cf. les lignes 84 et 85 de la fonction issig).

On ferme tous les descripteurs de fichier ouverts, et on supprime leurs référence de la table des fichiers.

On décrémente le compteur de références vers l'inode du répertoire courant.

On décrémente aussi le compteur de références vers le segment de code (opération qu'on ne voit pas ici, voir aparté et version Lions du code).

On alloue dans le swap 1 bloc. Si cette opération échoue, panique.

Cette allocation dans le swap est une allocation mémoire, mais qui se fait sur une section du disque. Elle ne réserve aucun espace dans la mémoire, juste un bloc sur le disque.

La fonction getblk réserve de la place dans le cache tampon de la mémoire, place dans laquelle est copiée le bloc du disque dont l'adresse est passée en deuxième paramètre (le premier paramètre est le matériel). La valeur de retour de la fonction est un pointeur vers une structure buf.

Grâce à cette fonction, on obtient un pointeur vers une structure buf, qui contient l'adresse en mémoire centrale (dans le cache tampon plus précisément) du bloc cache tampon copié depuis le bloc disque (ici, le processus courant fait une entrée/sortie, il va donc s'endormir).

La fonction bcopy nous permet de copier les n octets depuis l'adresse adr1 vers l'adresse adr2, adr1 étant le premier paramètre, adr2 étant le deuxième, et n étant le troisième. Elle permet aussi probablement de marquer le bloc mémoire comme modifié, devant donc être synchronisé vers le disque à un moment opportun (pure hypothèse, en vrai on n'en sait rien).

Comme là c'est un peu urgent, on demande explicitement la synchronisation du bloc tampon cache vers le bloc disque. (là techniquement, le processus courant fait une entrée/sortie, il va donc s'endormir).

On garde un pointeur dans le registre vers la structure proc du processus courant.

On vide de la mémoire toute l'image mémoire du processus (sa structure u, sa pile S [la raison pour laquelle exit() ne manipule jamais jamais la pile mais seulement du registre ou des variables globales], sa pile U, ses données)

Dans la structure proc du processus courant (qui, on le rappelle, ne fait pas partie de l'image mémoire du processus), le champ p_addr qui stocke l'adresse du premier octet du premier bloc de l'image mémoire contient maintenant l'adresse du bloc du swap qui contient la structure u du processus courant.

On fait passer l'état du processus courant à SZOMB.

On parcourt la table des procs. On réveille son père si on le trouve.

Si on trouve son père, on notifie tous ses fils que leur nouveau père est le processus de pid 1, le processus init, et on les réveille si ils sont stoppés ou tracés (? leur p_state égale SSTOP). Ensuite, on appelle swtch(), appel dont on ne retournera jamais.

Si à la sortie de la boucle qui parcourt la table des procs, on a pas trouvé son père, on se voit adopté par le processus init, puis renvoyé dans la boucle.

**** Aparté entrées/sorties

En deux endroits au moins le processus fait une entrée/sortie. Il va perdre le processeur au moins deux fois. On a bien pris garde à ne tenir aucun compte des signaux et à laisser l'état du processeur à SRUN. On est bien sûr que le processus va récupérer le processeur au même endroit à partir d'un certain moment.

**** Aparté segment texte (ou code)

Lors de la création d'un processus, on prend soin d'incrémenter le compteur de référence de la structure texte vers laquelle pointe p_textp.

Il n'y a pas, dans le code de exit présenté ici, de décrémentation symétrique, ce qui est incohérent.

Dans la version Lions du code, on a effectivement un appel à xfree(), placé entre la ligne 16 et la ligne 19 de notre version du code. Cette fonction se charge de décrémenter les compteurs de référence vers la zone de texte, de libérer la mémoire et le swap si ces compteurs tombent à 0.

L'image mémoire d'un processus ne comprend donc pas son segment de code.

*** Question 6

Implémenter le code de wait, selon la spécification POSIX, ou plutôt selon la simplification Lejeune de la spécification POSIX.

La fonction doit :

- Si le processus appelant n'a pas de fils, ni zombie ni vivant (aussi bien prêt que élu que bloqué/endormi), la fonction se termine, l'exécution n'est pas bloquante.
- Si le processus appelant a au moins un fils zombie, indépendemment de son nombre de fils actifs, il écrit la valeur de retour de son fils (le premier dans l'ordre de la table des processus) dans le pointeur qui lui a été passé en paramètre. Si aucun pointeur, ou le pointeur NULL lui a été passé, il n'écrit rien. Puis il libère le bloc dans lequel la structure u du zombie a été stockée lors du exit() du fils, il libère l'entrée correspondant à la structure p du fils, et il retourne enfin le pid du fils. Dans ce cas, la fonction se termine, l'exécution n'est pas bloquante.
- Si le processus appelant n'a pas de fils zombie, mais au moins un fils vivant, l'exécution est bloquante : le processus appelant s'endort, jusqu'à ce que son fils devienne zombie, moment auquel il reprend l'alternative 2.

Voilà notre solution : elle est a priori assurée de fonctionner.

On n'est en revanche pas capable de tester si l'utilisateur a effectivement passé un paramètre à l'appel système côté user wait(2). Il y a bien toujours quelque chose à u.u_arg[0], mais on n'a aucune manière de vérifier que cette chose interprétée comme un entier veut bien dire quelque chose, qu'elle fait référence à une adresse légale du processus, etc... Tout ça est quand même très important : quand on exécute le code de wait, on est en mode système, on peut écrire dans toutes les adresses sans peine, potentiellement écraser des informations importantes.

On a deux manières de régler le problème. Soit on décide de ne pas écrire la valeur de retour du fils à une adresse mémoire, mais dans un registre, et à l'appel système côté utilisateur d'aller l'y chercher (suppose d'être sûr que ce registre ne sera pas écrasé entre temps). C'est, d'après le Lions, la solution choisie par MM. Thompson et Ritchie.

Soit l'appel système côté utilisateur, avant le passage en mode noyau, s'assure de ce que l'appel système côté noyau trouvera en u.u_arg[0] une adresse valable si une adresse est spécifiée (erreur et sortie prématurée sinon), une adresse "poubelle" (par exemple l'adresse d'un entier de sa propre pile destinée à être dépilée après le retour du mode noyau) si rien ou NULL est passé en paramètre. D'après ce qu'on sait, c'est la manière dont fonctionnent les unix modernes : la fonction API utilisateur est en fait une fonction d'enveloppe qui vérifie que toutes les hypothèses faites par l'appel système côté noyau sont respectées.

Tout ça pour dire : dans notre implémentation, on écrira directement dans une adresse mémoire, en faisant toutes les hypothèses de correction sur cette adresse.

La fonction utilise un goto, *ce qui n'est pas un problème*. Tant qu'on arrive à garder les choses simples, il n'y a aucun problème à utiliser goto.

#+BEGIN_SRC c
  wait()
  {
	  register struct proc *p;
	  struct buf *b;
	  int f = 0;

  loop:
	  for (p = &proc[0]; p != &proc[NPROC]; p++) {
		  if ((p->p_stat & SZOMB) &&
		      (u.u_procp->pid == p->p_ppid)) {
			  u.u_ar0[R0] = p->p_pid;

			  /* Fonctionne aussi avec bread() */
			  b = getblk(swapdev, p->p_addr);
			  ,*(u.u_arg[0]) = b->b_addr->u_ar0[R0];
			  brelse(b);

			  mfree(swapmap, 1, p->p_addr);

			  p->p_stat = NULL;

			  /* Ici on copie le Lions */
			  /* On n'aurait pas pensé à faire ce nettoyage */
			  p->p_pid = 0;
			  p->p_ppid = 0;
			  p->p_sig = 0;
			  p->p_ttyp = 0;
			  p->p_flag = 0;

			  return;
		  }

		  if ((p->p_stat & SRUN) &&
		      (u.u_procp->pid == p->p_ppid)) {
			  f++;
		  }
	  }

	  if (f) {
		  sleep(u.u_procp, PWAIT);
		  goto loop;
	  }

	  u.u_ar0[R0] = -1;
	  return;
  }
#+END_SRC


* TD 7 : 27/11/2019

Aujourd'hui, le fonctionnement du swapper.

On commence à avoir fait le tour du fonctionnement des processus, on se rapproche petit à petit du fonctionnement du disque et du cache tampon.

*** Les caractéristiques du swapper

Le swapper est le processus d'id 0.

Il est toujours en mémoire, il s'exécute toujours en mode système : il n'exécute que du code système.

Sa priorité est la priorité PSWAP la plus prioritaire (minimale, donc). C'est la priorité qu'il a tout le temps (pas seulement quand il est endormi). On sait donc que quand on réveille le swapper :
- On force une nouvelle élection (runrun++, cf. code de setrun), dès la sortie du mode noyau.
- On sait qu'on va élire le swapper.

*** runin et runout

Dans quelles conditions le swapper s'endort-il ?

- Soit la mémoire est pleine et on a rien à évincer immédiatement : on s'endort sur runin (cf. ligne 129).
- Soit la mémoire est non pleine, mais on n'a rien à rappeler : on s'endort sur runout (cf. ligne 45).
- On s'endort bien entendu aussi pendant les entrées/sorties bloquantes, même si ça ne se verra pas forcément dans le code de cette fonction-là précisément.

Dans quelles conditions le swapper est-il réveillé ?
- Quand ses entrées/sorties sont finies, on imagine qu'il est réveillé par une interruption matérielle, même si on ne le voit pas encore dans le code.
- On veut ramener quelque processus du swap vers la mémoire centrale, par exemple quand on le réveille (cf. ligne 102 de setrun()), ou alors on vient d'évincer quelque processus, et on veut que le swapper vérifie s'il peut ramener quelque autre processus (cf. ligne 212 de xswap()) : on réveillera alors l'adresse runout.
- On veut signaler au swapper qu'on vient de s'endormir, et qu'on se porte volontaire pour se faire évincer (cf. ligne 40 de sleep()), ou alors une seconde vient de passer, et on doit réveiller le swapper de toute façon (cf. ligne 84 de realtime) : on réveillera alors sur l'adresse runin.

#+BEGIN_THEOREM
On réveille sur runout quand on veut rappeler quelque processus du swap vers la mémoire centrale.

On réveille sur runin quand on veut évincer quelque processus de la mémoire centrale vers le swap.

"in" et "out" sont toujours "in" le swap et "out" le swap.
#+END_THEOREM

*** Apartés et aphorismes nuls

#+BEGIN_THEOREM
Une écriture peut être asynchrone, une lecture ne le peut pas, à moins d'inventer ce qu'on lit.
#+END_THEOREM

*** Algorithme de la fonction sched()

Cette fonction est la boucle principale du processus swapper. Le processus est toujours dans cette fonction (ou des fonctions appelées par celle-ci) quand il a la main.

L'algorithme n'est pas si compliqué que ça, mais il est long. Le plus clair est encore de faire un automate.


#+NAME: bonjour
#+BEGIN_SRC dot :results output verbatim drawer :cmd graph-easy :cmdline --as_ascii

  digraph TestGraph1 {
      rankdir=LR
      "x" -> "b";
      "c" -> "b";
      "b" -> "d";
  }

#+END_SRC


#+CALL: bonjour[:results output verbatim drawer :cmd graph-easy :cmdline --as_ascii]()


Analyse de la fonction :

On masque toutes les interruptions.

On parcourt la table des procs, à la recherche d'un processus prêt. Celui qui a le temps résident en disque le plus long est gardé.

Si on en trouve pas, on s'endort sur la variable runout.


Ligne 58 : est-ce que le processus a une structure texte.
Ligne 59 : est-ce que la structure texte du processus est référencée et chargée en mémoire ?

Si oui, rien à faire. Sinon, on augmente la taille du processus de la taille de cette structure texte, et on alloue la place que prend cette structure texte.

Si cette allocation fonctionne :

On charge éventuellement le texte, si il n'est pas déjà chargé.
On charge les autres structures du processus.
On libère du disque ce qu'on vient de copier dans la RAM.
On ajoute le flag "chargé en mémoire" (SLOAD) au processus courant.
On réinitialise le temps résident.
On retourne au début.

Si cette allocation ne fonctionne pas :

On cherche une victime. On regarde si il existe un processus chargé, pas système, pas verrouillé en mémoire, endormi ou stoppé.

Si on en a trouvé un, on le vire de la mémoire vers le swap, et on retourne au début.

Est-ce que le temps résident du processus qu'on veut faire rentrer est moins de trois secondes. Si c'est le cas, on s'endort sur runin (on se réveillera toutes les secondes, ou quand un processus s'endort, et on reviendra au début.)

Si le temps résident du processus qu'on veut faire rentrer est de plus de trois secondes, on étend la recherche aux processus prêts, et on prend celui dont le temps résident en mémoire est le plus grand. Si le temps résident en mémoire de ce processus est plus de deux secondes, on le vire, sinon on s'endort.

Le processus swapper ne se termine jamais, il ne fait que s'endormir pour laisser la main à d'autres.


On s'intéresse maintenant à la fonction swap.

Permet de faire un transfert de la mémoire vers le disque, ou dans l'autre sens.
Introduction aux entrées-sorties.

Quand on ramène qqch du disque, on le ramène dans le cache tampon.

xswap est forcément de la mémoire vers le disque.

Description de la fonction :

212-215 : ces lignes sont là si ce n'est pas swapper qui a appelé la fonction xswap.



[il faut être capable de redessiner l'automate. photo et diagramme]




*** Exercice type examen

Hypothèses :

- Aucun processus autre que swapper ne change d'état.
- Pas d'autoswap
- Pas de nouveau proc/pas de exit.
- La mémoire est pleine.
- Les I/O << 1 seconde.
- Le processus p[3] vient de passer à l'état run, via setrun.

La question :

Dans combien de temps le processus d'indice 3 reviendra en mémoire ?
Donnez l'état de la table des procs au moment où il revient.

On a besoin de la taille de la mémoire.

| index | pwchan | p_time | p_pri | p_stat | p_flag      | p_size | p_addr (RAM ou SWAP) |
|-------+--------+--------+-------+--------+-------------+--------+----------------------|
|     0 | runout |    ... |       | SSLEEP | SSYS&SLOAD  |      0 | RAM                  |
|     1 |        |     44 |       | SSLEEP | SSYS&SLOAD  |      3 | RAM                  |
|     2 |        |     10 |       | SSLEEP | SLOCK&SLOAD |      2 | RAM                  |
|     3 |        |      2 |       | SRUN   | NULL        |     14 | SWAP                 |
|     4 |        |      3 |       | SRUN   | SLOAD       |      2 | RAM                  |
|     5 |        |      0 |       | SRUN   | SLOAD       |      4 | RAM                  |
|     6 |        |      0 |       | SSLEEP | SLOAD       |      5 | RAM                  |
|     7 |        |      4 |       | SSLEEP | SLOAD       |      4 | RAM                  |
|     8 |        |      0 |       | SRUN   | SLOAD       |      6 | RAM                  |

Taille de la mémoire : 26

La liste des opérations :

- Etat initial, place dispo 0
- On vire p[6] (premier processus endormi non système), place dispo 5

| index | pwchan | p_time | p_pri | p_stat | p_flag      | p_size | p_addr (RAM ou SWAP) |
|-------+--------+--------+-------+--------+-------------+--------+----------------------|
|     0 | runout |    ... |       | SRUN   | SSYS&SLOAD  |      0 | RAM                  |
|     1 |        |     44 |       | SSLEEP | SSYS&SLOAD  |      3 | RAM                  |
|     2 |        |     10 |       | SSLEEP | SLOCK&SLOAD |      2 | RAM                  |
|     3 |        |      2 |       | SRUN   | NULL        |     14 | SWAP                 |
|     4 |        |      3 |       | SRUN   | SLOAD       |      2 | RAM                  |
|     5 |        |      0 |       | SRUN   | SLOAD       |      4 | RAM                  |
|     6 |        |      0 |       | SSLEEP | ~SLOAD      |      5 | SWAP                 |
|     7 |        |      4 |       | SSLEEP | SLOAD       |      4 | RAM                  |
|     8 |        |      0 |       | SRUN   | SLOAD       |      6 | RAM                  |

- On vire p[7] (premier processus endormi non système), place dispo 9

| index | pwchan | p_time | p_pri | p_stat | p_flag      | p_size | p_addr (RAM ou SWAP) |
|-------+--------+--------+-------+--------+-------------+--------+----------------------|
|     0 | runout |    ... |       | SRUN   | SSYS&SLOAD  |      0 | RAM                  |
|     1 |        |     44 |       | SSLEEP | SSYS&SLOAD  |      3 | RAM                  |
|     2 |        |     10 |       | SSLEEP | SLOCK&SLOAD |      2 | RAM                  |
|     3 |        |      2 |       | SRUN   | NULL        |     14 | SWAP                 |
|     4 |        |      3 |       | SRUN   | SLOAD       |      2 | RAM                  |
|     5 |        |      0 |       | SRUN   | SLOAD       |      4 | RAM                  |
|     6 |        |      0 |       | SSLEEP | ~SLOAD      |      5 | SWAP                 |
|     7 |        |      0 |       | SSLEEP | ~SLOAD      |      4 | SWAP                 |
|     8 |        |      0 |       | SRUN   | SLOAD       |      6 | RAM                  |

- Le temps résident du processus à ramener en mémoire est de 2, donc inférieur à 3, donc on s'endort une seconde.

Temps attendu : 1 seconde.
Etat au réveil.

| index | pwchan | p_time | p_pri | p_stat | p_flag      | p_size | p_addr (RAM ou SWAP) |
|-------+--------+--------+-------+--------+-------------+--------+----------------------|
|     0 | runout |    ... |       | SRUN   | SSYS&SLOAD  |      0 | RAM                  |
|     1 |        |     45 |       | SSLEEP | SSYS&SLOAD  |      3 | RAM                  |
|     2 |        |     11 |       | SSLEEP | SLOCK&SLOAD |      2 | RAM                  |
|     3 |        |      3 |       | SRUN   | NULL        |     14 | SWAP                 |
|     4 |        |      4 |       | SRUN   | SLOAD       |      2 | RAM                  |
|     5 |        |      1 |       | SRUN   | SLOAD       |      4 | RAM                  |
|     6 |        |      1 |       | SSLEEP | ~SLOAD      |      5 | SWAP                 |
|     7 |        |      1 |       | SSLEEP | ~SLOAD      |      4 | SWAP                 |
|     8 |        |      1 |       | SRUN   | SLOAD       |      6 | RAM                  |

- On rééssaie : le temps résident du candidat est passé à 3, donc on cherche une victime vivante.
On prend celle dont le temps résident en mémoire est le plus long : p[4].
Le temps résident de p[4] est bien supérieur à 2, on peut le virer.
Place disponible 11.

| index | pwchan | p_time | p_pri | p_stat | p_flag      | p_size | p_addr (RAM ou SWAP) |
|-------+--------+--------+-------+--------+-------------+--------+----------------------|
|     0 | runout |    ... |       | SRUN   | SSYS&SLOAD  |      0 | RAM                  |
|     1 |        |     45 |       | SSLEEP | SSYS&SLOAD  |      3 | RAM                  |
|     2 |        |     11 |       | SSLEEP | SLOCK&SLOAD |      2 | RAM                  |
|     3 |        |      3 |       | SRUN   | NULL        |     14 | SWAP                 |
|     4 |        |      0 |       | SRUN   | ~SLOAD      |      2 | SWAP                 |
|     5 |        |      1 |       | SRUN   | SLOAD       |      4 | RAM                  |
|     6 |        |      1 |       | SSLEEP | ~SLOAD      |      5 | SWAP                 |
|     7 |        |      1 |       | SSLEEP | ~SLOAD      |      4 | SWAP                 |
|     8 |        |      1 |       | SRUN   | SLOAD       |      6 | RAM                  |

- On essaie encore. Le candidat vivant à virer est p[5]. Ce processus a un temps résident en mémoire strictement inférieur à 2, on s'endort.

Temps attendu : 2 secondes
Etat au réveil.

| index | pwchan | p_time | p_pri | p_stat | p_flag      | p_size | p_addr (RAM ou SWAP) |
|-------+--------+--------+-------+--------+-------------+--------+----------------------|
|     0 | runout |    ... |       | SRUN   | SSYS&SLOAD  |      0 | RAM                  |
|     1 |        |     46 |       | SSLEEP | SSYS&SLOAD  |      3 | RAM                  |
|     2 |        |     12 |       | SSLEEP | SLOCK&SLOAD |      2 | RAM                  |
|     3 |        |      4 |       | SRUN   | NULL        |     14 | SWAP                 |
|     4 |        |      1 |       | SRUN   | ~SLOAD      |      2 | SWAP                 |
|     5 |        |      2 |       | SRUN   | SLOAD       |      4 | RAM                  |
|     6 |        |      2 |       | SSLEEP | ~SLOAD      |      5 | SWAP                 |
|     7 |        |      2 |       | SSLEEP | ~SLOAD      |      4 | SWAP                 |
|     8 |        |      2 |       | SRUN   | SLOAD       |      6 | RAM                  |

- On essaie encore : le candidat vivant à virer est p[5].
Son temps résident en mémoire est de 2, on peut le virer.

Place dispo 15.

| index | pwchan | p_time | p_pri | p_stat | p_flag      | p_size | p_addr (RAM ou SWAP) |
|-------+--------+--------+-------+--------+-------------+--------+----------------------|
|     0 | runout |    ... |       | SRUN   | SSYS&SLOAD  |      0 | RAM                  |
|     1 |        |     46 |       | SSLEEP | SSYS&SLOAD  |      3 | RAM                  |
|     2 |        |     12 |       | SSLEEP | SLOCK&SLOAD |      2 | RAM                  |
|     3 |        |      4 |       | SRUN   | NULL        |     14 | SWAP                 |
|     4 |        |      1 |       | SRUN   | ~SLOAD      |      2 | SWAP                 |
|     5 |        |      0 |       | SRUN   | ~SLOAD      |      4 | SWAP                 |
|     6 |        |      2 |       | SSLEEP | ~SLOAD      |      5 | SWAP                 |
|     7 |        |      2 |       | SSLEEP | ~SLOAD      |      4 | SWAP                 |
|     8 |        |      2 |       | SRUN   | SLOAD       |      6 | RAM                  |

On peut swap in le processus.

| index | pwchan | p_time | p_pri | p_stat | p_flag      | p_size | p_addr (RAM ou SWAP) |
|-------+--------+--------+-------+--------+-------------+--------+----------------------|
|     0 | runin  |    ... |       | SSLEEP | SSYS&SLOAD  |      0 | RAM                  |
|     1 |        |     46 |       | SSLEEP | SSYS&SLOAD  |      3 | RAM                  |
|     2 |        |     12 |       | SSLEEP | SLOCK&SLOAD |      2 | RAM                  |
|     3 |        |      0 |       | SRUN   | SLOAD       |     14 | RAM                  |
|     4 |        |      1 |       | SRUN   | ~SLOAD      |      2 | SWAP                 |
|     5 |        |      0 |       | SRUN   | ~SLOAD      |      4 | SWAP                 |
|     6 |        |      2 |       | SSLEEP | ~SLOAD      |      5 | SWAP                 |
|     7 |        |      2 |       | SSLEEP | ~SLOAD      |      4 | SWAP                 |
|     8 |        |      2 |       | SRUN   | SLOAD       |      6 | RAM                  |

Place dispo : 1
swapper s'endort sur runin.

*** Exercice de l'an dernier

Taille de la mémoire = 20.

Table des processus :

| index | p_pid | p_uid | p_flag      | p_stat | p_size | p_time | p_wchan  | p_pri |
|-------+-------+-------+-------------+--------+--------+--------+----------+-------|
|     0 |     0 |     0 | SSYS&SLOAD  | SSLEEP |      2 |    120 | runout   | PSWP  |
|     1 |     1 |     0 | SSYS&SLOAD  | SSLEEP |      4 |    125 | &proc[1] | PWAIT |
|     2 |   101 |  1000 | SLOAD       | SSLEEP |      1 |      1 | &toto    | 50    |
|     3 |   102 |  1000 | SLOCK&SLOAD | SSLEEP |      3 |     10 | &toto    | 50    |
|     4 |   103 |  1000 | SLOAD       | SRUN   |     10 |      0 |          | 50    |
|     5 |   104 |  1000 | NULL        | SLEEP  |     10 |     10 | &toto    | 50    |
|     6 |   105 |  1000 | NULL        | SLEEP  |     10 |      5 | &toto    | 50    |

Pas de fork, pas de exit, pas de wakeup(&toto)

Temps d'exécution du code noyau (appels système, swapper, init) et E/S sont négligeables.
Segments de texte non pris en compte.

**** Question 1

On suppose qu'à t=0 le proc 103 exécute kill(104, SIGUSR1) et entre dans une boucle infinie, d'instructions ne comportant pas d'appel système.
Montrer que le swapper va se réveiller.

kill la fonction API utilisateur est exécutée, donc le code de kill appel système est exécuté.
Dans le code de kill, on a un appel à psignal.
psignal va appeler setrun sur 104
104 n'a pas le flag SLOAD, wakeup est donc appelé sur &runout.
Or le processus swapper est endormi sur runout. Le processus swapper sera élu lors de la prochaine élection, qui va arriver tout de suite (runrun++).

Les filtres de priorité sont bien respectés [à spécifier si on veut tous les points].

**** Question 2

A quelle date 104 va-t-il commencer à s'exécuter pour traiter le signal.

On part du principe que le swapper commence à s'exécuter à t=0.

Mémoire occupée : 20 Mémoire totale : 20.

On exécute le code de swapper. On veut faire rentrer.


Sur quelle adresse le swapper s'endort lorsque 104 s'exécute.

En supposant que la signal SIGUSR1 provoque un calcul de 9 secondes sur le proc 104., combien de temps.




* Annexes

Les supports de TD :

[[./TDTME.pdf][TD]]

La version Lions du code :

[[./unixv6Lions.pdf][Lions]]


