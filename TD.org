#+TITLE : Prise de notes TD 4I401 NOYAU
#+PROPERTY: header-args :mkdirp yes
#+STARTUP: inlineimages

Jonathan Lejeune(jonathan.lejeune@lip6.fr)

* TD 1 : 25/09/2019

Rappels systèmes et introduction au noyau Unix.

*** Question 1 : Quel est l'intérêt de déclarer une variable en register ?

Le temps d'accès à un registre est particulièrement bas. Si on sait qu'une variable devra être lue souvent, il peut être bon pour la vitesse d'exécution de mettre la variable dans le registre.

*** Question 2 : Que fait le programme suivant ?

#+BEGIN_SRC c
  f(from, to, count)
  int *from, *to;
  register count;

  {
	  register *f, *t;
	  f = from;
	  t = to;
	  do
		  ,*t++ = *f++;
	  while(--count);
  }
#+END_SRC

Le programme prend en paramètre deux pointeurs vers entier, et un entier count.

La copie locale du paramètre count doit être mis dans un registre si possible.

Le programme déclare ensuite deux pointeurs vers des entiers f et t, et demande à les mettre dans le registre. Il donne aux deux pointeurs ainsi créés les valeurs des deux paramètres from et to en entrée.

Le choix est judicieux : les variables appelées à être souvent modifiées (t, f, et count) sont mises dans un registre, celles destinées à n'être lues qu'une fois (from, to) se contentent de la mémoire centrale. Il n'est pas sûr que ce paramètre explicite soit nécessaire en 2019 : on pourrait estimer gcc capable de faire cette optimisation seul.

Le but du programme est de copier une certain nombre d'entiers contigus (exactement count entiers) de l'adresse from à l'adresse to.

L'incrémentation se fait après la copie : opérateur d'incrémentation post-fixé.

La décrémentation de count se fait avant le test du while : opérateur pré-fixé.

*** Question 3

Soit un tableau t d'une structure quelconque x

#+BEGIN_SRC c
  struct x {
	  int x_a;
  } t[MAX];
#+END_SRC


Ce code permet de parcourir la structure. (cpt stocke la somme des éléments du tableau).

#+BEGIN_SRC c
  int i, cpt;
  cpt = 0;
  for (i = 0; i < MAX; ++i) {
	  cpt += t[i].x_a;
  }
#+END_SRC

Ecrire un code qui permet de parcourir la structure en utilisant un pointeur vers la structure.

On doit pouvoir donner une condition d'arrêt. On peut soit déclarer une variable i, l'incrémenter en même temps que le pointeur, soit se servir de MAX (on ne sait pas si MAX est une variable locale ou globale, ou un alias, ou quoi que ce soit).



#+BEGIN_SRC c
  int cpt = 0;
  int i = 0;

  for (; i < MAX; p++, i++) cpt =+ p->x_a;
#+END_SRC

On part bien entendu du compte que MAX est connu dans la portée du code.

Bonne solution :

#+BEGIN_SRC c
  int cpt = 0;
  struct x *p;

  for (p = t; p < t + MAX; ++p) {
	  cpt += p->x_a;
  }
#+END_SRC

En effet, on peut garder l'adresse du début du tableau dans une autre variable. Quand la différence entre l'adresse dynamique et l'adresse de départ atteint MAX, on s'arrête.

*** Question 4

CPU : Central processing unit, fait les opérations arithmétiques et logiques, charge des zones de mémoire centrale dans sa mémoire personnelle, décharge sa mémoire personnelle dans la mémoire centrale.

Les registres sont le nom donné à la mémoire personnelle du processeur (accessible en un cycle).

RAM : La mémoire centrale, non-persistante (contenu disparaît à l'extinction de la machine). Permet d'accéder directement à un octet donné.

La mémoire morte est une zone de mémoire sans droits d'écriture dans laquelle on peut écrire le bios, par exemple.

Interruption (trappe) : Signal matériel (par opposition aux signaux, qui sont des entités logicielles), qui demande au système d'exploitation de reprendre la main pour faire des trucs. L'appel système est une sorte d'interruption logicielle.

Comment le CPU communique-t-il avec le matériel ? Via les interruptions et les contrôleurs (en fait des processeurs monotâche).

DMA (Direct Memory Access) : permet aux contrôleurs d'I/O d'accéder directement à des zones mémoire intéressantes (sans avoir besoin de passer par un tampon).

*** Question 5

La mémoire virtuelle, c'est la manière dont le processeur voit la mémoire, qui ne correspond pas à la mémoire physique.

C'est l'ensemble des adresses mémoire accessible par le processeur (qui dépend directement de la taille de son mot d'instruction). La correspondance entre les adresses de mémoire virtuelle et celles de mémoire physique est faite par le MMU (Memory Management Unit), une zone du processeur (ou un processeur spécifique). Le MMU dispose d'un cache appelé TLB (Translation Local-side Buffer).

Chaque processus dispose d'une table des pages qui stocke l'adresse des différents segments et pages, à laquelle le MMU accède, fait son calcul, et accède à l'adresse physique correspondante.

*** Question 6

La commutation de contexte :

La commutation de contexte est l'opération qui consiste à remplacer dans le processeurs et la mémoire centrale les données qui permettent l'exécution d'un processus, par celles qui permettent l'exécution d'un autre processus.

(Déjà, on ne choisit pas quand on commute, c'est le noyau)
La commutation se fait seule quand le quantum d'un processus est épuisé, à la suite d'une interruption d'horloge. Concrètement, lorsqu'une commutation commence, on copie le contexte processeur (les registres) et le contexte mémoire noyau (ce qui, dans la partie noyau de la mémoire, fait référence au processus courant) qqpart dans la mémoire centrale, et on charge à la place depuis un endroit en mémoire centrale le contexte processeurs et le contexte mémoire noyau.

*** Question 7

Les segments sont des zones de la mémoire spécifiques à un processus qui partagent les mêmes permissions. On les distingue traditionnellement entre les données (dans lesquelles on trouve le tas), accessibles en lecture et en écriture, le code (dans laquelle on va trouver les instructions du processus), accessible seulement en lecture, et la pile (pour les variables locales des fonctions), accessible en lecture et en écriture.

Le CPU y accède (s'il en a le droit !) via une instruction de son jeu d'instruction (load word, load byte), qui est transmise au MMU.

#+BEGIN_SRC c
  #include <stdio.h>

  int x = 37;

  void f(int a, int b)
  {
	  int i = 17;
	  int j = a + b + i;
	  printf("Hello : %d\n", i);
	  i = 45;
  }

  void g()
  {
	  int *i = (int*)malloc(sizeof(int) * 5);
	  f(3, 4);
  }

  int main()
  {
	  g();
	  return 0;
  }
#+END_SRC

Dessin du contexte mémoire :


|   | @code après g |      |
|---+---------------+------|
|   |       @malloc | f    |
|   | @code après f |      |
| b |             4 |      |
| a |             3 |      |
| i |            45 |      |
| j |            24 |      |
|   |               |      |
|   |               |      |
|   |               |      |
|   |               |      |
|---+---------------+------|
|   |               | tas  |
|---+---------------+------|
| x |            37 | glob |

*** Aparté

Processus : instance d'exécution d'un programme, et *son contexte et flux d'exécution*.

*** Question 8

En mode système, un certain nombre d'instructions spéciales et de registres spéciaux du processeurs sont accessibles en plus de celles accessibles en mode usager.

Il y a ces différences parce qu'on ne veut pas que l'usager puisse casser le matériel en accédant à des instructions ou des registres auquel il n'a pas droit.

Dans un processeur MIPS, il y a un registre système qui garde si l'exécution courante se fait en mode sytème ou en mode utilisateur.

PDP-11 ? [Pas traité ici]

Il y aussi une certaine zone de mémoire qui apparaît en mode S : en fait, une deuxième pile apparaît, la pile S, spécifique à un processus (distincte de la zone des données du systèmes, qui regroupe les variables globales à tous les processus).

La pile S sert à sauvegarder les appels de fonction du noyau, les variables locales des fonctions qui y sont exécutées (c'est une pile, après tout).

*** Question 9

Un appel système, c'est une interruption logicielle qui permet à un processus de faire appel à des ressources du système en mode noyau, auxquelles il est seulement possible d'accéder en mode noyau.

Appel système : fonction du système appelée à partir du mode utilisateur.

*** Question 10

Interruption (trappe) : Signal matériel (par opposition aux signaux, qui sont des entités logicielles), qui demande au système d'exploitation de reprendre la main pour faire des trucs.

*** Question 11

Il est très important qu'il y ait deux piles :
- on veut définir des autorisations différentes sur ces deux piles
- on veut que le processus en mode système puisse accéder à ses propres variables privées, éventuellement à des variables globales.

La pile S étant critique, elle peut être définie pour ne jamais être vide. On ne saurait donner les mêmes droits à un mode U (on ne fait pas confiance au programme).

Pourquoi une pile S par processus ?
Chaque processus a un contexte mémoire dans le noyau (dans la partie noyau de la mémoire).

Il faut sauver un contexte d'exécution des fonctions systèmes par processus. Précisément parce qu'on a la possibilité de sortir "pas proprement" du mode système, et donc que la pile S n'est pas propre, il en faut plusieurs, une par processus.

*** Question 12

Structure proc

p_flag : vecteur de bits, correspond à des états secondaires du processus
p_stat : vecteur de bits, correspondant à des états d'ordonnancement
p_textp : pointeur vers une structure de type texte, qui lui-même pointe vers le code du programme

On a une déclaration d'un tableau de cette structure : c'est une variable globale, avec NPROC nombre maximal de processus existants à n'importe quel moment.

(résultat de ps(1), avec option -aux)


Structure user

Tableaux de sauvegarde des registres, selon les cas.
Pointeur vers la structure proc correspondance.

u_ofile : tableau des descripteurs de fichier.
u_signal : Handler de signal
u_cdir : pointeur vers inode du répertoire courant

Une instance de la structure user existe pour chaque processus, elle est déclarée : la variable u est toujours peuplée de la structure du processus courant.

Informations moins importantes que dans la structure proc : peuvent être swappées, contrairement à proc.

Les informations de proc sont vitales, en particulier pour l'ordonnancement.

*** Question 13

Zone U :

Pile S + struct u (l'instance de la structure user)

Une seule zone U active fonctionnelle, à un moment précis.

Etat de la mémoire virtuelle à un moment précis :

| S     | Zone U          | Dynamique |
| S     | Code du système | Statique  |
|-------+-----------------+-----------|
| S + u | Pile            | Dynamique |
| S + u | Données (tas)   | Dynamique |
| S + u | Texte (Code)    | Dynamique |

Par dynamique, on entend que la région de mémoire physique vers laquelle pointe la zone change avec chaque commutation.
Le code du système reste toujours mappé vers la même zone de mémoire physique, quel que soit le processus exécuté.

u.u_procp->p_pid donne le pid du processus courant.

*** Question 14

PID pour chaque processus, pourquoi et comment attribué ?

Identification unique.

Compteur global, incrémenté à chaque création de processus (retour à partir d'une certaine valeur). On a la possibilité d'avoir plusieurs processus qui dans la vie de la machine ont eu le même pid (mais pas en même temps).

*** Question 15

BIOS what ?

Le code chargé au démarrage de la machine, teste le matériel, et lance l'exécution du système.



* TD 2 : 02/10/2019

On traite aujourd'hui de la synchronisation entre processus.

*** Question 1

On doit prendre garde à la fonction noyau sleep (à ne pas confondre avec l'appel système sleep(3) ou avec la commande shell sleep(1))

#+BEGIN_SRC c
  int sleep(caddr_t chan, int pri);
#+END_SRC

le processeur appelant va se mettre en attente sur l'adresse chan (la ressource avec lequel on se synchronise), et se réveillera avec la priorité pri.

#+BEGIN_QUOTE
Give up the processor till a wakeup occurs on chan, at which time the process enters the scheduling queue at priority pri. The most important effect of pri is that when pri<=PZERO a signal cannot disturb the sleep ; if pri >PZERO signals will be processed. Callers of this routine must be prepared for premature return, and check that the reason for sleeping has gone away.
#+END_QUOTE

La fonction noyau wakeup :

#+BEGIN_SRC c
  int wakeup(caddr_t chan);
#+END_SRC

*** Question 3 bis

Seulement avec les fonctions sleep et wakeup, coder deux fonctions noyau newtemp et hot.

newtemp est appelé par la sonde, avec en paramètre  : pour faire quoi ?
On ne sait pas ce que les fonctions doivent faire.

hot est censée être appelée par d'autres processus, tourner en boucle, et se terminer dès lors que la température t passée en paramètre est dépassée.

Or hot ne peut pas connaître la température, il n'existe pas de fonction qui permettre d'obtenir la température.

La solution passe par les variables globales du noyau : en effet, newtemp peut se contenter d'enregistrer la température dans cette variable globale.

#+BEGIN_SRC c
  // PRI_TEMP est un define

  int cpt = 0;
  int curtemp = -20000;

  void newtemp(int t)
  {
	  curtemp = t;
	  if(cpt) wakeup(&curtemp);
  }

  void hot(int max)
  {
	  int oldmask = gpl();
	  spl(TEMPHB);

	  cpt++;
	  while (curtemp <= max) {
		  sleep(&curtemp,PRI_TEMP);
		  spl(TEMPHB);
	  }
	  cpt--;

	  spl(oldmask);
  }
#+END_SRC

L'addresse de tmp est prise au hasard : la seule contrainte, c'est que wakeup et sleep portent sur la même adresse : on aurait pu prendre n'importe quoi.

cpt permet de ne pas avoir à parcourir toute la table : il compte le nombre de processus qui ont appelé hot : on ne lance wakeup que si on sait que le nombre de processus dans 

On peut se permettre de ne pas protéger cpt parce que le noyau dont on parle est non-préemptif : on ne peut pas avoir cpt modifié par plusieurs processus en même temps, ils devraient tous être en mode noyau, or un processus en mode noyau ne lâche le processeur que si il se termine.

*** Analyse de sleep, wakeup et setrun

**** sleep

sleep est appelé par un processus qui souhaite s'endormir.

rp pointe vers la structure proc du processus courant :
#+BEGIN_SRC c
  register struct proc *rp = u.u_procp;
#+END_SRC

spl est le set priority level : fonction qui permet de masquer toutes les interruptions moins prioritaires.
CLINHB au moins aussi prioritaire que l'horloge : on fait ça pour changer des champs des structures proc, qui elles ont une influence sur l'ordonnanceur.

#+BEGIN_QUOTE
Interruption, c'est comme si j'appelais une fonction sans l'avoir voulu : les données de la fonction handler de l'interruption sont empilées au-dessus (en-dessous en fait) des données du processus, ce qui fait que quand l'appel est fini, c'est comme si on dépilait.
#+END_QUOTE

p_wchan est mis à chan l'adresse de l'événement à attendre, p_stat est mis à SLEEP, et p_pri est mis à pri.

Puis on appelle l'ordonnanceur (swtch()) : le moment où on lâche vraiment le processeur, le vrai moment où on s'endort.

dans l'alternative non-prioritaire :
runin signale au swapper que le processus est swappable, si il a envie.

On doit remettre la condition de traitement du signal après le switch, parce que le PC du processus est sur l'instruction de la ligne 42 : c'est la qu'on reviendra quand le processus récupèrera le processeur : donc on doit remettre l'instruction de traitement du signal avant de sortir de la fonction.

**** wakeup

proc[] est manifestement une variable globale.
On parcourt toute la table des processus à la recherche du processus qui attendait l'événement passé en argument.

**** setrun

p->p_wchan est une adresse, champ de la structure proc, et représente l'adresse de l'événement que le processus attent (en effet, les sleep et les wakeup sont fait sur une adresse) : il est mis à 0 si le processus n'attend rien.

runrun est une variable globale : si runrun > 0 alors il faudra appeler swtch dès qu'on sort du noyau : grâce à cette variable-là, le noyau peut ne pas être préemptif :
si je réveille qqn de plus prioritaire que moi, je devrai lui laisser la main, *mais pas avant d'avoir fini ce que je voulais faire dans le noyau*.

Est-ce que le processus que je viens de réveiller a été swappé : si oui, on le rétablit dans la mémoire.

*** Question 4

spl définit le masquage des interruptions jusqu'à un certain niveau passé en paramètre.
gpl donne en valeur de retour le niveau de masquage des interruptions.

On utilise spl pour protéger les variables globales du noyau.

*** Question 5

Tout de suite, dans la fonction. Pour wakeup, c'est uniquement quand on sort du mode noyau.
Commutation se fait soit par abandon volontaire du processus, soit à la sortie du mode noyau.

runrun sert à dire s'il faut 

*** Question 6

Processus qui s'occupe de faire le transfert des pages du processus de la mémoire vers le disque, ou vice versa.

*** Question 7

pri de sleep est la priorité à laquelle on veut s'endormir : il compte pour savoir si on est interruptible par signal, et il sert à l'ordonnanceur.

*Ce n'est pas le truc qui est passé en argument de spl !!!*

*** Question 8

Déjà décrit plus haut

*** Question bonus : question annale

L'objectif est de transmettre une valeur générée par un processus à un de ses fils.

On ajoute le champ int p_value à la structure proc.

S'il existe au moins 1 fils, la fonction void send_value(int val) sauvegarde la valeur val dans le champ p_value de la structure proc de l'appelant.
Cette valeur sera lue par un de ses fils en utilisant la fonction int recv_value(). Cette fonction renvoie la dernière valeur sauvegardée dans le champ p_value de la structure proc du père.

Un processus ne peut pas écrire une nouvelle valeur dans son champ p_value tant qu'un de ses fils n'a pas lu la valeur précédente. Dès lecture d'un fils, le père peut écrire une nouvelle valeur.

Si le père n'a pas écrit de nouvelle valeur, le fils qui appelle recv_value() doit s'endormir jusqu'à qu'une nouvelle valeur soit écrite. (ce qui signifie qu'une valeur ne saurait être lue deux fois)


En gros, on cherche à implémenter un tube :


On peut endormir le processus qui appelle la fonction send_value (le processus père, donc) après qu'il a mis à jour la valeur : il sera réveillé par le processus fils qui aura lu la valeur : il pourra sortir de la fonction send_value en train d'être exécutée, et à ce moment là en lancer une nouvelle.

Sinon, une variable globale indique si la valeur est lisible ou non, et elle bloque le père ou les fils selon les cas. Il faut protéger cette variable pendant son édition (sections critiques à déterminer.)

Si la variable globale est à 0 et que des fils veulent lire la variable, ils sont endormis. Au moment où on remet la variable à 1, on wakeup les fils, et on commande un coup d'ordonnanceur pour la sortie du mode noyau.

Si la variable globale est à 1 et que le père veut écrire sur la variable, il est endormi. Au moment où la variable est remise à 0, on wakeup le père, et on commande un coup d'ordonnanceur pour la sortie du mode noyau.

La vraie bonne manière de placer la variable, c'est de rajouter un champ dans la structure proc, appelé p_msgstate, initialisé à 0 pour tout le monde.

edit : le mieux du mieux, c'est d'en rajouter deux : un pour les messages à recevoir (qui viennent du haut), un pour les messages à envoyer (qui vont en bas).

p_msgstatedown et p_msgstateup, tous deux initialisés à 0.

#+BEGIN_SRC c
  void send_value(int val)
  {
	  register struct proc *rp = u.u_proc;
	  register struct proc *p = NULL;

	  // vérifier si des fils existent. Si aucun existe, on termine la fonction.

	  for (p = proc; p < &proc[NPROC]; p++) {
		  if (p->p.ppid == rp->p.pid) {
			  break;
		  }
	  }

	  // Si on a au moins un fils :
	  if (p != &proc[NPROC] ) {
		  spl(PRIO);
		  while (rp->p_msgstatedown) {
			  sleep(&(rp->p_msgstatedown), PRIORITE);
		  }

		  spl(PRIO); // Apparemment pas nécessaire
		  rp->p_value = val;
		  rp->p_msgstatedown = 1;
		  spl(NORMAL);

		  // Réveiller les éventuels fils
		  wakeup(&(rp->p_msgstatedown));
	  }

  }


  int recv_value()
  {
	  register struct proc *pere, moi = u.u_procp;

	  for (pere = moi; pere < &proc[NPROC]; pere++) {
		  if (pere->p_pid == moi->p_ppid) {
			  break;
		  }
	  }

	  while (pere->p_msgstateup) {
		  sleep(&(pere->p_value), PZERO);
	  }

	  pere->p_msgstateup = 1; //ou 0, je me rappelle plus
	  wakeup(&(pere->p_value)); //problème ici : pas cohérent

	  return pere->p_value;
  }




#+END_SRC


* Annexes

Les supports de TD :

[[./TDTME.pdf][TD]]



