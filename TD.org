#+TITLE : Prise de notes TD 4I401 NOYAU
#+PROPERTY: header-args :mkdirp yes
#+STARTUP: inlineimages

Jonathan Lejeune(jonathan.lejeune@lip6.fr)

* TD 1 : 25/09/2019

Rappels systèmes et introduction au noyau Unix.

*** Question 1 : Quel est l'intérêt de déclarer une variable en register ?

Le temps d'accès à un registre est particulièrement bas. Si on sait qu'une variable devra être lue souvent, il peut être bon pour la vitesse d'exécution de mettre la variable dans le registre.

*** Question 2 : Que fait le programme suivant ?

#+BEGIN_SRC c
  f(from, to, count)
  int *from, *to;
  register count;

  {
	  register *f, *t;
	  f = from;
	  t = to;
	  do
		  ,*t++ = *f++;
	  while(--count);
  }
#+END_SRC

Le programme prend en paramètre deux pointeurs vers entier, et un entier count.

La copie locale du paramètre count doit être mis dans un registre si possible.

Le programme déclare ensuite deux pointeurs vers des entiers f et t, et demande à les mettre dans le registre. Il donne aux deux pointeurs ainsi créés les valeurs des deux paramètres from et to en entrée.

Le choix est judicieux : les variables appelées à être souvent modifiées (t, f, et count) sont mises dans un registre, celles destinées à n'être lues qu'une fois (from, to) se contentent de la mémoire centrale. Il n'est pas sûr que ce paramètre explicite soit nécessaire en 2019 : on pourrait estimer gcc capable de faire cette optimisation seul.

Le but du programme est de copier une certain nombre d'entiers contigus (exactement count entiers) de l'adresse from à l'adresse to.

L'incrémentation se fait après la copie : opérateur d'incrémentation post-fixé.

La décrémentation de count se fait avant le test du while : opérateur pré-fixé.

*** Question 3

Soit un tableau t d'une structure quelconque x

#+BEGIN_SRC c
  struct x {
	  int x_a;
  } t[MAX];
#+END_SRC


Ce code permet de parcourir la structure. (cpt stocke la somme des éléments du tableau).

#+BEGIN_SRC c
  int i, cpt;
  cpt = 0;
  for (i = 0; i < MAX; ++i) {
	  cpt += t[i].x_a;
  }
#+END_SRC

Ecrire un code qui permet de parcourir la structure en utilisant un pointeur vers la structure.

On doit pouvoir donner une condition d'arrêt. On peut soit déclarer une variable i, l'incrémenter en même temps que le pointeur, soit se servir de MAX (on ne sait pas si MAX est une variable locale ou globale, ou un alias, ou quoi que ce soit).



#+BEGIN_SRC c
  int cpt = 0;
  int i = 0;

  for (; i < MAX; p++, i++) cpt =+ p->x_a;
#+END_SRC

On part bien entendu du compte que MAX est connu dans la portée du code.

Bonne solution :

#+BEGIN_SRC c
  int cpt = 0;
  struct x *p;

  for (p = t; p < t + MAX; ++p) {
	  cpt += p->x_a;
  }
#+END_SRC

En effet, on peut garder l'adresse du début du tableau dans une autre variable. Quand la différence entre l'adresse dynamique et l'adresse de départ atteint MAX, on s'arrête.

*** Question 4

CPU : Central processing unit, fait les opérations arithmétiques et logiques, charge des zones de mémoire centrale dans sa mémoire personnelle, décharge sa mémoire personnelle dans la mémoire centrale.

Les registres sont le nom donné à la mémoire personnelle du processeur (accessible en un cycle).

RAM : La mémoire centrale, non-persistante (contenu disparaît à l'extinction de la machine). Permet d'accéder directement à un octet donné.

La mémoire morte est une zone de mémoire sans droits d'écriture dans laquelle on peut écrire le bios, par exemple.

Interruption (trappe) : Signal matériel (par opposition aux signaux, qui sont des entités logicielles), qui demande au système d'exploitation de reprendre la main pour faire des trucs. L'appel système est une sorte d'interruption logicielle.

Comment le CPU communique-t-il avec le matériel ? Via les interruptions et les contrôleurs (en fait des processeurs monotâche).

DMA (Direct Memory Access) : permet aux contrôleurs d'I/O d'accéder directement à des zones mémoire intéressantes (sans avoir besoin de passer par un tampon).

*** Question 5

La mémoire virtuelle, c'est la manière dont le processeur voit la mémoire, qui ne correspond pas à la mémoire physique.

C'est l'ensemble des adresses mémoire accessible par le processeur (qui dépend directement de la taille de son mot d'instruction). La correspondance entre les adresses de mémoire virtuelle et celles de mémoire physique est faite par le MMU (Memory Management Unit), une zone du processeur (ou un processeur spécifique). Le MMU dispose d'un cache appelé TLB (Translation Local-side Buffer).

Chaque processus dispose d'une table des pages qui stocke l'adresse des différents segments et pages, à laquelle le MMU accède, fait son calcul, et accède à l'adresse physique correspondante.

*** Question 6

La commutation de contexte :

La commutation de contexte est l'opération qui consiste à remplacer dans le processeurs et la mémoire centrale les données qui permettent l'exécution d'un processus, par celles qui permettent l'exécution d'un autre processus.

(Déjà, on ne choisit pas quand on commute, c'est le noyau)
La commutation se fait seule quand le quantum d'un processus est épuisé, à la suite d'une interruption d'horloge. Concrètement, lorsqu'une commutation commence, on copie le contexte processeur (les registres) et le contexte mémoire noyau (ce qui, dans la partie noyau de la mémoire, fait référence au processus courant) qqpart dans la mémoire centrale, et on charge à la place depuis un endroit en mémoire centrale le contexte processeurs et le contexte mémoire noyau.

*** Question 7

Les segments sont des zones de la mémoire spécifiques à un processus qui partagent les mêmes permissions. On les distingue traditionnellement entre les données (dans lesquelles on trouve le tas), accessibles en lecture et en écriture, le code (dans laquelle on va trouver les instructions du processus), accessible seulement en lecture, et la pile (pour les variables locales des fonctions), accessible en lecture et en écriture.

Le CPU y accède (s'il en a le droit !) via une instruction de son jeu d'instruction (load word, load byte), qui est transmise au MMU.

#+BEGIN_SRC c
  #include <stdio.h>

  int x = 37;

  void f(int a, int b)
  {
	  int i = 17;
	  int j = a + b + i;
	  printf("Hello : %d\n", i);
	  i = 45;
  }

  void g()
  {
	  int *i = (int*)malloc(sizeof(int) * 5);
	  f(3, 4);
  }

  int main()
  {
	  g();
	  return 0;
  }
#+END_SRC

Dessin du contexte mémoire :


|   | @code après g |      |
|---+---------------+------|
|   |       @malloc | f    |
|   | @code après f |      |
| b |             4 |      |
| a |             3 |      |
| i |            45 |      |
| j |            24 |      |
|   |               |      |
|   |               |      |
|   |               |      |
|   |               |      |
|---+---------------+------|
|   |               | tas  |
|---+---------------+------|
| x |            37 | glob |

*** Aparté

Processus : instance d'exécution d'un programme, et *son contexte et flux d'exécution*.

*** Question 8

En mode système, un certain nombre d'instructions spéciales et de registres spéciaux du processeurs sont accessibles en plus de celles accessibles en mode usager.

Il y a ces différences parce qu'on ne veut pas que l'usager puisse casser le matériel en accédant à des instructions ou des registres auquel il n'a pas droit.

Dans un processeur MIPS, il y a un registre système qui garde si l'exécution courante se fait en mode sytème ou en mode utilisateur.

PDP-11 ? [Pas traité ici]

Il y aussi une certaine zone de mémoire qui apparaît en mode S : en fait, une deuxième pile apparaît, la pile S, spécifique à un processus (distincte de la zone des données du systèmes, qui regroupe les variables globales à tous les processus).

La pile S sert à sauvegarder les appels de fonction du noyau, les variables locales des fonctions qui y sont exécutées (c'est une pile, après tout).

*** Question 9

Un appel système, c'est une interruption logicielle qui permet à un processus de faire appel à des ressources du système en mode noyau, auxquelles il est seulement possible d'accéder en mode noyau.

Appel système : fonction du système appelée à partir du mode utilisateur.

*** Question 10

Interruption (trappe) : Signal matériel (par opposition aux signaux, qui sont des entités logicielles), qui demande au système d'exploitation de reprendre la main pour faire des trucs.

*** Question 11

Il est très important qu'il y ait deux piles :
- on veut définir des autorisations différentes sur ces deux piles
- on veut que le processus en mode système puisse accéder à ses propres variables privées, éventuellement à des variables globales.

La pile S étant critique, elle peut être définie pour ne jamais être vide. On ne saurait donner les mêmes droits à un mode U (on ne fait pas confiance au programme).

Pourquoi une pile S par processus ?
Chaque processus a un contexte mémoire dans le noyau (dans la partie noyau de la mémoire).

Il faut sauver un contexte d'exécution des fonctions systèmes par processus. Précisément parce qu'on a la possibilité de sortir "pas proprement" du mode système, et donc que la pile S n'est pas propre, il en faut plusieurs, une par processus.

*** Question 12

Structure proc

p_flag : vecteur de bits, correspond à des états secondaires du processus
p_stat : vecteur de bits, correspondant à des états d'ordonnancement
p_textp : pointeur vers une structure de type texte, qui lui-même pointe vers le code du programme

On a une déclaration d'un tableau de cette structure : c'est une variable globale, avec NPROC nombre maximal de processus existants à n'importe quel moment.

(résultat de ps(1), avec option -aux)


Structure user

Tableaux de sauvegarde des registres, selon les cas.
Pointeur vers la structure proc correspondance.

u_ofile : tableau des descripteurs de fichier.
u_signal : Handler de signal
u_cdir : pointeur vers inode du répertoire courant

Une instance de la structure user existe pour chaque processus, elle est déclarée : la variable u est toujours peuplée de la structure du processus courant.

Informations moins importantes que dans la structure proc : peuvent être swappées, contrairement à proc.

Les informations de proc sont vitales, en particulier pour l'ordonnancement.

*** Question 13

Zone U :

Pile S + struct u (l'instance de la structure user)

Une seule zone U active fonctionnelle, à un moment précis.

Etat de la mémoire virtuelle à un moment précis :

| S     | Zone U          | Dynamique |
| S     | Code du système | Statique  |
|-------+-----------------+-----------|
| S + u | Pile            | Dynamique |
| S + u | Données (tas)   | Dynamique |
| S + u | Texte (Code)    | Dynamique |

Par dynamique, on entend que la région de mémoire physique vers laquelle pointe la zone change avec chaque commutation.
Le code du système reste toujours mappé vers la même zone de mémoire physique, quel que soit le processus exécuté.

u.u_procp->p_pid donne le pid du processus courant.

*** Question 14

PID pour chaque processus, pourquoi et comment attribué ?

Identification unique.

Compteur global, incrémenté à chaque création de processus (retour à partir d'une certaine valeur). On a la possibilité d'avoir plusieurs processus qui dans la vie de la machine ont eu le même pid (mais pas en même temps).

*** Question 15

BIOS what ?

Le code chargé au démarrage de la machine, teste le matériel, et lance l'exécution du système.



* TD 2 : 02/10/2019

On traite aujourd'hui de la synchronisation entre processus.

*** Question 1

On doit prendre garde à la fonction noyau sleep (à ne pas confondre avec l'appel système sleep(3) ou avec la commande shell sleep(1))

#+BEGIN_SRC c
  int sleep(caddr_t chan, int pri);
#+END_SRC

le processus appelant va se mettre en attente sur l'adresse chan (la ressource avec lequel on se synchronise), et se réveillera avec la priorité pri.

#+BEGIN_QUOTE
Give up the processor till a wakeup occurs on chan, at which time the process enters the scheduling queue at priority pri. The most important effect of pri is that when pri<=PZERO a signal cannot disturb the sleep ; if pri >PZERO signals will be processed. Callers of this routine must be prepared for premature return, and check that the reason for sleeping has gone away.
#+END_QUOTE

La fonction noyau wakeup :

#+BEGIN_SRC c
  int wakeup(caddr_t chan);
#+END_SRC

*** Question 3 bis

Seulement avec les fonctions sleep et wakeup, coder deux fonctions noyau newtemp et hot.

newtemp est appelé par la sonde, avec en paramètre  : pour faire quoi ?
On ne sait pas ce que les fonctions doivent faire.

hot est censée être appelée par d'autres processus, tourner en boucle, et se terminer dès lors que la température t passée en paramètre est dépassée.

Or hot ne peut pas connaître la température, il n'existe pas de fonction qui permettre d'obtenir la température.

La solution passe par les variables globales du noyau : en effet, newtemp peut se contenter d'enregistrer la température dans cette variable globale.

#+BEGIN_SRC c
  // TEMPHB est un define

  int cpt = 0;
  int curtemp = -20000;

  void newtemp(int t)
  {
	  curtemp = t;
	  if(cpt) wakeup(&curtemp);
  }

  void hot(int max)
  {
	  int oldmask = gpl();
	  spl(TEMPHB);

	  cpt++;
	  while (curtemp <= max) {
		  sleep(&curtemp,PRI_TEMP);
		  spl(TEMPHB);
	  }
	  cpt--;

	  spl(oldmask);
  }
#+END_SRC

L'addresse de tmp est prise au hasard : la seule contrainte, c'est que wakeup et sleep portent sur la même adresse : on aurait pu prendre n'importe quoi (mais préfère donner qqch de signifiant, ici )

cpt permet de ne pas avoir à parcourir toute la table : il compte le nombre de processus qui ont appelé hot : on ne lance wakeup que si on sait que le nombre de processus endormis (donné par cpt) dans l'adresse &curtemp est au moins 1.

On peut se permettre de ne pas protéger cpt parce que le noyau dont on parle est non-préemptif : on ne peut pas avoir cpt modifié par plusieurs processus en même temps, ils devraient tous être en mode noyau, or un processus en mode noyau ne lâche le processeur que si il se termine, ou ne sort du mode noyau que s'il le demande explicitement.

*** Analyse de sleep, wakeup et setrun

**** sleep

sleep est appelé par un processus qui souhaite s'endormir.

rp pointe vers la structure proc du processus courant :
#+BEGIN_SRC c
  register struct proc *rp = u.u_procp;
#+END_SRC

spl est le set priority level : fonction qui permet de masquer toutes les interruptions moins prioritaires.
CLINHB au moins aussi prioritaire que l'horloge : on fait ça pour changer des champs des structures proc, qui ont une influence sur l'ordonnanceur : *ces champs sont archi critiques*, c'est uniquement pour cette raison que le noyau se permet cette opération extrêmement violente de masquer toutes les interruptions, même l'interruption horloge.

#+BEGIN_QUOTE
Interruption, c'est comme si j'appelais une fonction sans l'avoir voulu : les données de la fonction handler de l'interruption sont empilées au-dessus (en-dessous en fait) des données du processus, ce qui fait que quand l'appel est fini, c'est comme si on dépilait : le stack pointer est directement au bon endroit pour reprendre l'execution directement où elle a été laissée.

Jonathan Lejeune
#+END_QUOTE

p_wchan est mis à chan l'adresse de l'événement à attendre, p_stat est mis à SLEEP, et p_pri est mis à pri.

Puis on appelle l'ordonnanceur (swtch()) : le moment où on lâche vraiment le processeur, le vrai moment où on s'endort.

dans l'alternative non-prioritaire :
runin signale au swapper que le processus est swappable, si il a envie.

On doit remettre la condition de traitement du signal après le switch, parce que le PC du processus est sur l'instruction de la ligne 42 : c'est la qu'on reviendra quand le processus récupèrera le processeur : donc on doit remettre l'instruction de traitement du signal avant de sortir de la fonction.

**** wakeup

On parcourt toute la table des processus à la recherche du processus qui attendait l'événement passé en argument.

**** setrun

p->p_wchan est une adresse, champ de la structure proc, et représente l'adresse de l'événement que le processus attent (en effet, les sleep et les wakeup sont fait sur une adresse) : il est mis à 0 si le processus n'attend rien.

runrun est une variable globale : si runrun > 0 alors il faudra appeler swtch dès qu'on sort du noyau : grâce à cette variable-là, le noyau peut ne pas être préemptif :
Si je réveille qqn de plus prioritaire que moi, je devrai lui laisser la main, *mais pas avant d'avoir fini ce que je voulais faire dans le noyau*.

Est-ce que le processus que je viens de réveiller a été swappé : si oui, on le rétablit dans la mémoire.

*** Question 4

spl définit le masquage des interruptions jusqu'à un certain niveau passé en paramètre.
gpl donne en valeur de retour le niveau de masquage des interruptions.

On utilise spl pour protéger les variables globales du noyau.

*** Question 5

Tout de suite, dans la fonction. Pour wakeup, c'est uniquement quand on sort du mode noyau.
Commutation se fait soit par abandon volontaire du processus, soit à la sortie du mode noyau.

*** Question 6

Processus qui s'occupe de faire le transfert des pages du processus de la mémoire vers le disque, ou vice versa.

*** Question 7

pri de sleep est la priorité à laquelle on veut s'endormir : il compte pour savoir si on est interruptible par signal, et il sert à l'ordonnanceur.

*Ce n'est pas le truc qui est passé en argument de spl !!!*. On passe en général à spl une valeur défini par un define en en-tête.

*** Question 8

Déjà décrit plus haut

*** Question bonus : question annale

L'objectif est de transmettre une valeur générée par un processus à un de ses fils.

On ajoute le champ int p_value à la structure proc.

S'il existe au moins 1 fils, la fonction void send_value(int val) sauvegarde la valeur val dans le champ p_value de la structure proc de l'appelant.
Cette valeur sera lue par un de ses fils en utilisant la fonction int recv_value(). Cette fonction renvoie la dernière valeur sauvegardée dans le champ p_value de la structure proc du père.

Un processus ne peut pas écrire une nouvelle valeur dans son champ p_value tant qu'un de ses fils n'a pas lu la valeur précédente. Dès lecture d'un fils, le père peut écrire une nouvelle valeur.

Si le père n'a pas écrit de nouvelle valeur, le fils qui appelle recv_value() doit s'endormir jusqu'à qu'une nouvelle valeur soit écrite. (ce qui signifie qu'une valeur ne saurait être lue deux fois)


En gros, on cherche à implémenter un tube, avec un problème de lecteur-rédacteur relativement classique :


On peut endormir le processus qui appelle la fonction send_value (le processus père, donc) après qu'il a mis à jour la valeur : il sera réveillé par le processus fils qui aura lu la valeur : il pourra sortir de la fonction send_value en train d'être exécutée, et à ce moment là en lancer une nouvelle.

Sinon, une variable globale indique si la valeur est lisible ou non, et elle bloque le père ou les fils selon les cas. Il faut protéger cette variable pendant son édition (sections critiques à déterminer.)

Si la variable globale est à 0 et que des fils veulent lire la variable, ils sont endormis. Au moment où on remet la variable à 1, on wakeup les fils, et on commande un coup d'ordonnanceur pour la sortie du mode noyau.

Si la variable globale est à 1 et que le père veut écrire sur la variable, il est endormi. Au moment où la variable est remise à 0, on wakeup le père, et on commande un coup d'ordonnanceur pour la sortie du mode noyau.

La vraie bonne manière de placer la variable, c'est de rajouter un champ dans la structure proc, appelé p_msgstate, initialisé à 0 pour tout le monde (pas de message).



#+BEGIN_SRC c
  void send_value(int val)
  {
	  register struct proc *moi = u.u_proc;
	  register struct proc *fils = NULL;

	  /*
	     vérifier si des fils existent. Si aucun existe, on termine la
	     fonction.
	  ,*/
	  for (fils = proc; fils < &proc[NPROC]; p++) {
		  if (fils->p.ppid == moi->p.pid) {
			  break;
		  }
	  }

	  // Si on a au moins un fils :
	  if (fils != &proc[NPROC] ) {

		  /* Apparemment pas nécessaire */
		  spl(PRIO);
		  /* Si j'ai déjà un message dans ma boîte d'envoi, je m'endors */
		  while (moi->p_msgstatedown) {
			  sleep(&(moi->p_msgstatedown), PRIORITE);
		  }

		  spl(PRIO); // Apparemment pas nécessaire
		  moi->p_value = val;
		  moi->p_msgstatedown = 1;
		  spl(NORMAL);

		  /* Réveiller les éventuels fils */
		  wakeup(&(moi->p_msgstatedown));
	  }

  }


  int recv_value()
  {
	  register struct proc *pere, moi = u.u_procp;

	  /*
	     La version précédente initialisait à moi la variable pere.
	     Or si ça se trouve, le père est avant le fils dans la table des
	     processus. C'est même le plus probable.
	     On vérifie tous les processus de la table des processus à la
	     recherche du père.
	     On suppose que le père ne meurt pas : très important
	  ,*/
	  for (pere = proc; pere < &proc[NPROC]; pere++) {
		  if (pere->p_pid == moi->p_ppid) {
			  break;
		  }
	  }

	  /*
	    Si le père n'a pas de message dans sa boîte d'envoi, on s'endort
	    sur l'adresse de son indicateur de message descendant
	  ,*/
	  while (!(pere->p_msgstatedown)) {
		  sleep(&(pere->p_msgstatedown), PRIORITE);
	  }

	  /*
	    Si le père a un message sur sa boîte d'envoi, on lui dit qu'il n'en a
	    plus, on le réveille s'il s'est éventuellement endormi en essayant
	    d'en mettre un autre, et on retourne la valeur du message.
	  ,*/

	  /* On veut que cette suite d'instructions soit atomique */
	  spl(PRIO);
	  pere->p_msgstatedown = 0;
	  wakeup(&(pere->p_msgstatedown));
	  spl(NORMAL);

	  return pere->p_value;
  }
#+END_SRC


* TD 3 : 09/10/2019

On traite aujourd'hui du traitement des signaux.

#+BEGIN_SRC c
  int kill(pid_t pid, int sig);
#+END_SRC

Il est bien clair qu'on parle ici de l'appel système, kill(2), et non pas de la fonction du noyau (dont l'implémentation est masquée de l'utilisateur, dépend de l'implémentation de unix).

Moyen rudimentaire de communication.

Traité par le processus !

Unix implémente la "boîte à diodes" des signaux entrants sous la forme d'un vecteur de bits. Diode allumée \to bit à 1.
(On ne sait donc pas si on a reçu un signal plusieurs fois, ce n'est pas une file d'attente)

On doit savoir quoi faire pour chaque signal : notion de *handler* (une fonction). Si aucun handler défini, on a un comportement par défaut.

Cette fonction est exécutée en mode utilisateur : en effet, ça a été codé par l'utilisateur.

Pour définir un handler de signal, on utilisait l'appel système signal(2):

#+BEGIN_SRC c
  typedef void (*sighandler_t)(int);

  sighandler_t signal(int signum, sighandler_t handler);
#+END_SRC

(De nos jours, on utiliserait plutôt sigaction, recommandé par la norme POSIX)

*signal redéfinit le handler de signal de manière provisoire (seulement la prochaine réception) !!*

On doit donc faire appel à signal dans le handler lui-même si on veut garder le handler pour les prochains traitements de signal.

Il y a deux signaux dont on ne peut pas redéfinir les handlers :
- SIGKILL
- SIGSTOP

#+BEGIN_QUOTE
The signals SIGKILL and SIGSTOP cannot be caught or ignored.

man page signal(2)
#+END_QUOTE

*** Question 1

#+BEGIN_SRC c
  #include <stdio.h>
  #include <unistd.h>

  void bonjour(int i)
  {
	  printf("Bonjour\n");
	  signal(SIGALRM, bonjour);
	  alarm(1);
  }

  int main()
  {
	  bonjour();
	  while (true) {
		  sleep(N);
	  }
	  return 0;
  }

#+END_SRC

*** Question 2

Différence signal ignoré et signal masqué.

Les deux ne prennent pas en compte le signal.

Ignorer : Je détruis ce signal (cette occurence du signal, mais pas forcément les occurences futures).
Masquer : retarder le traitement d'un signal.

(pas de masquage de signaux dans cette version du noyau.
Soit on les ignore, soit on les traite de manière précise avec un handler)

*** Question 2, TD 2

Rappels des opérateurs bit à bit en C :

AND bitwise : &

3 & 2 : 0b011 & 0b010 = 0b010 soit 2
(la puissance de 2 l'emporte toujours)

OU bitwise : |
3 | 2 = 0b011 | 0b010 = 0b011 = 3

NOT bitwise : ~
~2 = ~0b010 = 0b101 = 5

XOR bitwise : ^
3^2 = 0b011 ^ 0b010 = 0b001 = 1

SHIFT right : >>
5>>2 = 0b101>>2 = 0b001 = 1

SHIFT left : <<
5<<2 = 0b101<<2 = 0b100 = 4

Par exemple, si je veux mettre de manière certaine le ième bit à 1 du vecteur de bit v, je fais :
#+BEGIN_SRC c
  v |= (1<<(i-1));
#+END_SRC

Sinon, pour mettre le ième bit à 0 de manière sûre, je fais :
#+BEGIN_SRC c
  v = v & ~(1<<(i-1));
#+END_SRC

Tester si le ième bit est à 1 :
#+BEGIN_SRC c
  (v & (1<<(i-1)));
#+END_SRC

Tester si le ième bit est à 0 :
#+BEGIN_SRC c
  !(v & (1<<(i-1)));
#+END_SRC

*** Question prof

Trouver dans les structures unix les champs ou variables relatives aux signaux :

**** Dans la structure user (swappable) :

int u_signal[NSIG];

Or NSIG = 19, d'après le fichier d'en-tête sig.h

Donc on a un tableau de 19 entiers ??? (soient 19*32 bits : c'est bien plus qu'il n'en faut)

Contient les pointeurs vers les handlers, en fait. Les int étaient en fait des adresses.

**** Dans la structure proc (toujours en mémoire) :

long p_sig;

Un long est un entier de la taille d'un mot mémoire : ici, on va dire 32 bits : sachant qu'on a 19 signaux, ça suffit.

Les bits de p_sig constituent le vecteur de bits qui donne les signaux reçus par le processus.

short p_clktimer (un truc qui sert à compter le temps avant l'alarme).

*** Question 3

On vient d'y répondre.

*** Question 4

On est bien d'accord qu'on peut assimiler les signaux à des espèces d'interruptions logicielles.

Des différences majeures :
- Le traitement de l'interruption est toujours exécuté en mode noyau, mais en mode utilisateur dans le cas d'un signal.
- Emetteur est le matériel dans le cas de l'interruption, le noyau ou le processus dans le cas du signal.
- Mécanisme matériel, indépendemment du noyau dans le cas de l'interruption, et mécanisme logiciel dans le cas du signal.

*** Question 5

Quels sont les rôles des fonctions kill, psignal, issig, psig, fsig, sendsig et ssig ?

Pourquoi il n'y a pas d'argument à ces fonctions ?

Les arguments sont stockés dans la structure user.

Les fonctions en question sont exécutées sur la pile s : il n'y a rien dans cette pile, elles vont donc chercher leurs arguments dans la structure user du processus.

Le retour de la fonction système est stockée dans une zone R0, pour que la fonction utilisateur appelante puisse récupérer ce retour via son pointeur vers R0 dans sa structure user.

**** La fonction ssig()

On enregistre dans a le premier argument de la fonction utilisateur signal.

a représentera le numéro du signal.

On vérifie que a est valide (pas en dessous de 0, au dessus de 19, ni égale à SIGKIL) : s'il ne l'est pas, on sort de la fonction en rendant une erreur.

On remplit le retour de la fonction via la structure u_ar0

On met à jour le pointeur de fonction (ligne 15) : on met le deuxième argument de la fonction utilisateur signal dans le champ idoine de la structure user du processus.

(0 correspond à par défaut, 1 correspond à ignorer)

On remet à zéro la "diode" du signal.

**** La fonction kill()

On cherche dans la table des processus.

On doit intervertir le numéro du signal et le numéro du pid dans les noyaux modernes.

On met dans a le pid du processus à qui on veut envoyer un signal.

On boucle dans la table des processus :
- On vérifie que le p_stat du processus bouclé n'est pas NULL. (Il n'y a pas de processus dans ce champ)
- On vérifie que le pid du processus à signaler n'est pas 0, et que le pid du processus à signaler n'est pas le pid du processus bouclé (s'il ne l'est pas, on passe directement à la prochaine itération)
- Si le processus à signaler est 0 , ça veut soit dire qu'on veut s'adresser aux processus du même terminal, ou au processus swapper ou au processus init, on skip directement.
- On vérifie que (on n'est pas root AND on est bien proprio du processus) 

Si ces vérifications sont passées, on incrémente un compteur f et on lance la fonction psignal(p, u.u_arg[0]) (en n'oubliant pas que u.u_arg[0] contient le signal)

psignal a bien des arguments !
C'est normal, psignal n'est appelé que par d'autres fonctions noyau.

**** La fonction psignal(struct proc_p *p, int sig)

On vérifie que le signal existe bien.

On met le bit idoine du vecteur de bit du processus destinataire à 1 (quel que soit l'état du processus)

Si le processus n'est pas endormi avec une forte priorité, on le réveille.

**** La fonction issig()

Tant que le vecteur de bits du processus courant n'est pas exactement 0 (soit tant qu'on a pas vidé les signaux en attente) :

- On garde dans n le numéro du signal le plus bas (d'après l'analyse de la fonction fsig)

issig retourne le numéro du signal le plus bas reçu s'il y en a un, 0 sinon.

Ca veut dire que les signaux de numéro les plus bas sont traités de manière prioritaire : on peut avoir une famine pour les signaux les 

ligne 84 : si on a 1 au bit de poids faible, on sait qu'on veut ignorer : les adresses des handlers sont forcément alignées sur le mot mémoire, donc multiples de 4

Si on voulait ignorer (ligne 86), on remet le bit correspondant à 0.

**** La fonction fsig(struct proc *p)

Une fonction bien utile : retourne le signal de numéro le plus bas.

**** La fonction psig()

if(issig()) psig(); est la séquence exécutée systématiquement au retour en mode utilisateur.

Une version simplifiée, on ne va pas s'amuser à mettre tous les handlers par défaut.

psig récupère le numéro du signal à traiter dans n.
Il vérifie que ce n'est pas nul (ça ne devrait pas l'être si on suit la séquence plus haut)

Il remet le bit à 0.
Si le handler n'est pas 0 (càd si on ne veut pas utiliser le handler par défaut), on va lancer le handler, après l'avoir enlevé de la table des handlers (rappelons-nous, temporaire)

Si le handler est à 0, on fait les traitements par défaut.

**** La fonction sendsig(void *handler, int num)

La fonction charger d'appeler la fonction handler définie par l'utilisateur.

On manipule directement la pile de l'utilisateur pour le faire exécuter la fonction qu'il a lui-même écrite, à sa prochaine sortie du mode noyau.

Dans l'ordre :
- on enregistre dans sp le pointeur de pile enregistré du processus (u.u_ar0[SP]), pile augmenté d'un mot mémoire (en effet la pile croît de l'adresse la plus haute 0xffffffff vers l'adresse la plus basse 0x00000000).
- on alloue effectivement la mémoire de 0xffffffff jusqu'à sp (on imagine que la fonction grow alloue effectivement de la mémoire de 0xffffffff, ou un autre point de référence, à l'adresse qui lui est passée en paramètre)
- On enregistre cette nouvelle adresse modifiée dans le pointeur de pile enregistré du processus (u.u_ar0[SP]) (la pile est maintenant "officiellement" augmentée d'un mot mémoire)
- On enregistre dans ce mot mémoire qu'on vient d'allouer le PC (Program Count, AKA Compteur Ordinal, l'adresse le l'instruction à exécuter, tya compris fréro) enregistré du processus (u.u_ar0[PC])
- On met dans cette variable de sauvegarde du registre PC l'adresse de la fonction handler.

De cette manière, quand le processus repasse en mode utilisateur et récupère le processus, il exécute la fonction handler comme si c'était lui qui l'avait appelé.

*** Petit exo type examen

Implémenter un truc qui permet de masquer les signaux.

Requiert de modifier la fonction fsig.

Et de noter qqpart (dans la struct proc du processus) les indicateurs de signaux masqués.

On suppose dans la struct proc un vecteur de bits qui correspondent aux bits masqués.

Si le signal est masqué, fsig ne repère même pas le signal.

En C ANSI :

#+BEGIN_SRC c
  int fsig(struct proc *p)
  {
	  register int n, i, m, r;

	  n = p->p_sig;
	  m = m->p_mask; // Le vecteur des signaux masqués

	  r = n & ~m; // r correspond au vecteur des signaux non-masqués

	  for (i = 0; i < NSIG; ++i) {
		  if (r & 1) return (i);
		  r >>= 1;
	  }

	  return 0;
  }
#+END_SRC

Il faut aussi une fonction noyau pour ajouter un masque dans cette structure, une pour l'enlever. (assez trivial : on a juste un bit à bouger, juste des vérifications chiantes à faire avant)

Il faut aussi modifier la boucle while dans issig, de manière à éviter la boucle infinie (on ne teste plus while de p->p_sig, mais while de (p->p_pig & ~p->p_mask))


* TD 4 : 16/10/2019

On traite aujourd'hui de la question du temps et de l'ordonnancement.

*** Analyse des structures

L'interruption horloge, ou plutôt sa gestion, est écrite dans le fichier clock.

#+BEGIN_QUOTE
clock is called straight from real time clock interrupt.

Code source de Unix v6
#+END_QUOTE

La structure callo dans la fichier d'en-tête callo.h, permet de créer des appels réguliers.

On a un tableau statique de cette structure de taille NCALL, défini par une macro à la compilation.

On a dans le fichier param.h un define de l'inhibition des interruptions horloge.

Dans la structure proc, p_time, p_clktime, p_cpu.
p_time définit le temps pendant lequel on a été résident à un endroit précis en mémoire ou dans le swap (remis à 0 dès qu'on est swappé ou déswappé, mais incrémenté tout le temps).
p_clktime donne le temps avant l'alarme.
p_cpu donne l'utilisation du cpu.

On a une fonction accessible à l'utilisateur, time(2), définie comme suit.

#+BEGIN_SRC c
  #include <time.h>

  time_t time(time_t *tloc);
#+END_SRC

*** Question 1 : analyse des fonctions

La variable globale time fait appel au temps global, soit le nombre de secondes depuis 1/1/1970

**** clock()

On créé deux entiers externes (on fait appel à des variables déjà définies ailleurs).

Un pointeur vers une structure callo, dans un registre.

Un pointeur vers un entier, dans le registre.

On regarde le premier élément du tableau des callouts.

On parcourt le tableau des callouts :
Si c_time est inférieur à 0 et qu'il n'y a pas de fonction dans le champ c_func, on passe à l'élément suivant.
Sinon on décrémente le champ c_time et on sort de suite (plus de précisions dans l'explication de l'algorithme de callo)

idleflag est à 1 signifie qu'il n'y a aucun processus à élire.
Si l'usage du cpu d'un processus est en-dessous de 80, on incrémente cet usage.
L'usage du cpu est borné à 80.

On incrémente les stats, en vérifiant bien qu'on est pas idle.

On incrémente lbolt, puis on vérifie qu'il est supérieur ou égal à HZ, si c'est le cas on rajoute le flag WAKEUP.

HZ donne le nombre de ticks qu'on doit avoir en une seconde.
Quand lbolt arrive à HZ, on sait qu'on a passé une seconde.

On vérifie que le flag WAKEUP est vrai sur iaflags, et on appelle la fonction realtime(). (Ce n'est pas fait dans la fonction clock, mais ailleurs. On croira Jonathan Lejeune sur parole)

**** realtime()

On créé un pointeur vers une structure proc.

On remet lbolt à zéro.

On incrémente la variable globale time.

On incrémente runrun pour forcer une élection juste avant de sortir du mode noyau.

On réveille tout le monde à l'adresse lbolt (Quelqu'un qui veut être réveillé toutes les secondes, souvent des processus qui utilisent des drivers).

On parcourt la table des processus.

Si il y a bien un processus, on incrémente le resident time jusqu'à une limite de 127.

Si le temps jusqu'au prochain signal SIGALRM est 0, on traite le signal SIGALRM.

(utilisé par la fonction utilisateur alarm)
#+BEGIN_SRC c
  #include <unistd.h>

  unsigned int alarm(unsigned int seconds);
#+END_SRC


On divise le cpu usage par 2 : On applique le decay de l'algorithme d'ordonnancement de UNIX.

Si le processus a une prio faible, on remet à jour sa priorité selon l'algorithme unix, en appelant setpri.

Ensuite, si pression mémoire (testée par runin), on réveille le swapper.

**** setpri

En gros applique l'algorithme vu en cours, pour recréer un système de round robin sans queue.

*** Question 2

timeout permet de planifier l'exécution d'une fonction dans un certain temps.

Cette fonction prend en argument un pointeur vers une fonction, une chaîne de caractères pour les arguments et un entier qui donne le temps.

On créé deux pointeurs vers des structures callo.
Deux entiers, dont un dans le registre.

Le premier pointeur vers la structure callo est peuplé avec le premier élément de la table callout.

On met dans un des deux entiers le masquage des interruptions courant.
On met dans l'autre entier la valeur du paramètre.

On change le masquage des interruptions au niveau le plus puissant (CLINHB).

On parcourt la table callout.

Si on a bien une fonction dans la structure callo courante, et que le temps incrémentiel est en-dessous de t le temps passé en paramètre.

On applique l'algorithme décrit plus bas dans l'exercice.

En fait, l'idée est de ne noter que les temps cumulés à la prochaine fonction : il faut donc, lorsqu'on rajoute une fonction à exécuter plus tard, descendre dans le tableau en comparant aux temps de la fonction dans le tableau. Si c'est inférieur, c'est qu'on a trouvé notre place, auquel cas on shift tout le monde vers le bas. Si c'est supérieur, on décrémente le temps de la fonction à ajouter, et on compare au prochain élément.

De cette manière, lors d'une interruption horloge, on peut se contenter de ne décrémenter que le champ time du premier élément, ce qui mettra à jour tous les éléments du tableau :

#+BEGIN_QUOTE
The time in each structure entry is the number of HZ's more than the previous entry. In this way, decrementing the first entry has the effect of updating all entries
#+END_QUOTE

**** Petit exercice d'entraînement

On applique timeout(f, arg_f, 11) et timeout(g, arg_g, 5)

2 interruptions horloges

Puis timeout(h, arg_h, 3)

1 interruption horloge

Puis timeout(i, arg_i, 8)

Dessiner l'état du tableau callout à tout moment (on part du principe que la table est vide au début).


Tout est vide
| i | func | arg | time |
|---+------+-----+------|
| 0 |    0 |     |      |
| 1 |    0 |     |      |
| 2 |    0 |     |      |
| 3 |    0 |     |      |
| 4 |    0 |     |      |
| 5 |    0 |     |      |
| 6 |    0 |     |      |
| 7 |    0 |     |      |
| 8 |    0 |     |      |

| i | func | arg   | time |
|---+------+-------+------|
| 0 |    f | arg_f |   11 |
| 1 |    0 | '\0'  |  -11 |
| 2 |    0 |       |      |
| 3 |    0 |       |      |
| 4 |    0 |       |      |
| 5 |    0 |       |      |
| 6 |    0 |       |      |
| 7 |    0 |       |      |
| 8 |    0 |       |      |

| i | func | arg   | time |
|---+------+-------+------|
| 0 |    g | arg_g |    5 |
| 1 |    f | arg_f |    6 |
| 2 |    0 | '\0'  |  -11 |
| 3 |    0 |       |      |
| 4 |    0 |       |      |
| 5 |    0 |       |      |
| 6 |    0 |       |      |
| 7 |    0 |       |      |
| 8 |    0 |       |      |

| i | func | arg   | time |
|---+------+-------+------|
| 0 |    g | arg_g |    4 |
| 1 |    f | arg_f |    6 |
| 2 |    0 | '\0'  |  -11 |
| 3 |    0 |       |      |
| 4 |    0 |       |      |
| 5 |    0 |       |      |
| 6 |    0 |       |      |
| 7 |    0 |       |      |
| 8 |    0 |       |      |

| i | func | arg   | time |
|---+------+-------+------|
| 0 |    g | arg_g |    3 |
| 1 |    f | arg_f |    6 |
| 2 |    0 | '\0'  |  -11 |
| 3 |    0 |       |      |
| 4 |    0 |       |      |
| 5 |    0 |       |      |
| 6 |    0 |       |      |
| 7 |    0 |       |      |
| 8 |    0 |       |      |

| i | func | arg   | time |
|---+------+-------+------|
| 0 |    g | arg_g |    3 |
| 1 |    h | arg_h |    0 |
| 2 |    f | arg_f |    6 |
| 3 |    0 | '\0'  |  -11 |
| 4 |    0 |       |      |
| 5 |    0 |       |      |
| 6 |    0 |       |      |
| 7 |    0 |       |      |
| 8 |    0 |       |      |

| i | func | arg   | time |
|---+------+-------+------|
| 0 |    g | arg_g |    2 |
| 1 |    h | arg_h |    0 |
| 2 |    f | arg_f |    6 |
| 3 |    0 | '\0'  |  -11 |
| 4 |    0 |       |      |
| 5 |    0 |       |      |
| 6 |    0 |       |      |
| 7 |    0 |       |      |
| 8 |    0 |       |      |

| i | func | arg   | time |
|---+------+-------+------|
| 0 |    g | arg_g |    2 |
| 1 |    h | arg_h |    0 |
| 2 |    f | arg_f |    6 |
| 3 |    i | arg_i |    0 |
| 4 |    0 | '\0'  |  -11 |
| 5 |    0 |       |      |
| 6 |    0 |       |      |
| 7 |    0 |       |      |
| 8 |    0 |       |      |

*** Rappel

A chaque interruption d'horloge :
- clock()
- if(iaflag & WAKEUP)  realtime()
- if(iaflag & CALOUT) restart()

*** Coder la fonction restart

#+BEGIN_SRC c
  int restart()
  {
	  struct callo *p1;
	  struct callo *p2;

	  while ((&callout[0]->c_time == 0) &&
		 (&callout[0]->c_func != 0)) {

		  p1 = &callout[0];
		  ,*(p1->c_func)(p1->c_arg);

		  p2 = p1 + 1;

		  while ((p2-1)->c_func != 0) {
			  (p2-1)->c_func = p2->c_func;
			  (p2-1)->c_arg = p2->c_arg;
			  (p2-1)->c_tim = p2->c_tim;
			  ++p2;
		  }
	  }

	  return;
  }
#+END_SRC

On n'a pas besoin de masquer des interruptions, parce qu'on est déjà dans une interruption horloge.

*** Coder une fonction noyau sleep qui ne se servirait que de delay

On a bien compris ce que delay faisait : il demande à être réveillé dans ticks ticks et s'endort.

#+BEGIN_SRC c
  sleep()
  {
	  int sec = u.u_args[0];
	  int ticks = sec * HZ;
	  int expected_date = time + sec;
	  delay(ticks);

	  if (time < expected_date) {
		  u.u_ar0[R0].expected_date - time;
	  } else {
		  u.u_ar0[R0] = 0;
	  }
  }
#+END_SRC

*** Question type examen

Implémenter untimeout(ident)

#+BEGIN_SRC c
  untimeout(int ident)
  {
	  struct callo *p1;
	  struct callo *p2;

	  p1 = &callout[O];

	  while (p1->c_func != 0) {
		  if (p1->c_ident == ident) {
			  p2 = p1 + 1;
			  p2 ->c_time += p1->c_time;

			  while ((p2-1)->c_func != 0) {
				  (p2-1)->c_func = p2->c_func;
				  (p2-1)->c_arg = p2->c_arg;
				  (p2-1)->c_ident = p2->c_ident;
				  (p2-1)->c_time = p2->c_time;
				  ++p2;
			  }
		  }
		  ++p1;
	  }
  }
#+END_SRC


* TD 5 : 23/10/2019

On va parler aujourd'hui du mécanisme de commutation.

Comment faire pour passer d'un processus à un autre ?

La commutation, c'est le mécanisme du noyau qui permet le partage du temps processeur entre les processus (temps partagé).

*** Rappels de l'automate d'état

Un processus passe du mode élu S au mode prêt quand il a incrémenté runrun et qu'il perd l'élection.

Un processus passe du mode élu S au mode bloqué avec sleep().

Un processus passe du mode élu U au mode zombie avec exit().

*** La commutation

#+BEGIN_THEOREM
*Un processeur (ses registres visibles du processeur) ne connaît pas les adresses physiques*, mais seulement des adresses virtuelles.

Il existe certains registres (très peu) qui doivent connaître des adresses physiques.
#+END_THEOREM

Le compteur ordinal, en particulier, ne connaît que des adresses virtuelles.

Du point de vue du processeur, la mémoire ressemble à ça :

|---------|
| Zone U  |
|---------|
| OS      |
|---------|
| Pile U  |
|---------|
| Données |
|---------|
| Code    |
|---------|

Chacune des zones est mappée vers une zone de mémoire physique (la correspondance est dans la table des pages).
La zone OS est toujours mappée vers le même endroit (elle ne bouge pas dans la mémoire physique, et elle n'est jamais swappée).

On a un registre qui donne l'adresse *physique* de la table des pages (les registres systèmes ont le droit de stocker directement des adresses physiques).

p_addr est l'adresse physique de la zone mémoire du processus.


La commutation consiste donc en :
- Changer la traduction virtuelle-physique (opération de pointeur simple, peu coûteux)
- Changer le pointeur de pile (registres visibles de l'utilisateur)

On part du principe que tout processus qui est potentiellement élu avait appelé switch avant de perdre le processeur. Donc en fait, quand je change la table des pages et le pointeur de pile, en fait je sors de la fonction *pile au bon endroit* : la valeur à mettre dans le compteur ordinal, qu'on trouve en pointe de pile pour être retrouvée à chaque sortie de fonction, est déjà la bonne puisque c'est celle qu'on avait mis à l'appel de switch au temps jadis.

Le pointeur d'instruction reste donc le même (il doit bien exécuter le reste de la fonction switch), mais on sait qu'on retrouvera le bon.

#+BEGIN_THEOREM
Deux adresses physiques contigües en nombre ne sont pas forcément contigües en matériel
#+END_THEOREM

Segments mémoire d'un processus :
- Code
- Pile U
- Zone U (pile S plus struct u)
- Données (tas et variables globales)

Puis, ailleurs, dans la zone système de la mémoire :
- Code de l'OS
- Données de l'OS, variables globales
- Structures de données pour l'OS.

La fonction retu :
Prend en paramètre l'adresse physique de la mémoire des processus.
Remplace la table des pages courante par la table des pages adressée physiquement par le paramètre (en vrai, uniquement la partie de la table des pages qui mappe les adresses virtuelles de la zone U vers les adresses physiques. Le reste du travail est fait par une autre fonction, sureg())

**** Fichier text.h

x_daddr : l'adresse du bloc disque.
x_caddr : l'adresse du segment mémoire du texte.

x_count : nombre de références totales (quand c'est 0, on sait qu'on peut flush).
x_ccount : nombre de références par des processus chargés (quand c'est 0, on sait qu'on peut swap : on ramènera du disque en même temps que le processus qu'on ramènera).

*** Question 3

**** Analyse de swtch()

On déclare un pointeur (static : enregistré dans le segment de données plutôt que dans la pile, survit donc à la fonction, mais reste visible uniquement par celle-ci) vers une structure proc.
Deux entiers (dans le registre).
Un pointeur vers une structure proc (dans le registre).

Seulement si p est le pointeur NULL, on fait pointer p vers le premier élément du tableau (la struct proc du processus 0, le scheduler).
Si p n'est pas le pointeur NULL, alors il garde la valeur qu'il avait lors du dernier appel à swtch() : c'est pour cette raison qu'on a déclaré p avec le mot-clé static. Pourquoi on fait ça ? On veut que la recherche reprenne exactement là où on l'a interrompu la dernière fois.

On met le stack pointer dans la structure u du processus qui a appelé swtch (dans le champ u_rsav, plus spécifiquement).

savu sauvegarde le SP dans la structure passée en paramètre.

On charge dans les registres du processeur les registres sauvegardés en mémoire du scheduler (le processus 0) : u a changé.

aretu permet de changer le stack pointer sans commuter (retu en un peu moins puissant).

On a un label de loop :
runrun est remis à 0
On fait pointer rp vers p, p vers NULL, et n vers 128.

On regarde tous les processus prêts et chargés en mémoire.

On garde le plus prioritaire.

Quand on sort de la boucle après avoir décrémenté i NPROC fois (on ne fait plus d'un tour complet), on a un pointeur p vers la processus à élire.

Si j'ai trouvé aucun processus p, alors p est resté à NULL.
Je remets p à rp, j'attends la prochaine interruption, et je réessaye.

Si j'en ai un, j'alias son pointeur statique dans rp.

Je charge le registre qui donne l'adresse de sa table des pages.

sureg() : en fait, retu ne fait que changer la zone U, sureg() change les autres segments genre la pile U, les données et le code. On n'a pas fait sureg à l'entrée dans le processus 0 car ce processus n'a pas de pile, ni de code, ni de données (il écrit dans la pile du noyau, il manipule des données globales du noyau, et son code est celui du noyau)

ligne 69-72 : réponse dans deux épisodes.
Avant-goût : On vérifie si le champ p_flag du processus sélectionné porte le flag SSWAP (est-ce que le processus est en train de se faire swapped out).
Si oui, alors on l'enlève, et on change le stack pointer vers la valeur enregistrée dans u_ssav la dernière fois qu'on a appelé savu (on sait qu'on a appelé savu, parce qu'on part du principe que tous processus qui a existé a appelé swtch(), et que swtch() fait un appel à savu).

Si on a élu un processus, c'est qu'il est chargé en mémoire. Donc ce flag SSWAP est ancien, et il doit être enlevé (d'ailleurs, on l'enlève). En fait, c'est lié au fork. Quand un processus fork, s'il n'y a pas assez de mémoire pour le nouveau processus, on peut immédiatement swap out le fils. Pendant ce swap-là, on enregistre le pointeur de pile du fils dans son u_ssav, avant de le swap out.

Si ensuite par chance il s'est fait reswap in, on rétablit son pointeur de pile. (pas encore très clair)

return(1) : Si jamais le processus que j'ai élu, c'est la première fois qu'il est là (via un fork). Permet de dire vrai. [en vrai, on verra ça dans 2 séances].

*** Passage mode U - mode S (et vice versa)

Une trappe : Fonction appelée quand on passe du mode U au mode S. Cette fonction est définie au niveau matériel, elle est écrite par le constructeur.

*** Question 5

Appel système (la fonction utilisateur) doit renseigner :
- La fonction système qu'on veut exécuter (en fait le numéro de l'appel système dans un registre)
- On met les arguments à passer à la fonction système dans un tableau (et on met l'adresse dans un registre)
- On appelle la fonction trap() : défini au niveau du matériel (changement de contexte, sp dans la zone U), on passe en mode S (on change la valeur d'un processus), déroutement vers l'appel système

- On sauvegarde les registres utilisateurs dans u.u_ar0
- On va chercher les arguments et on les met dans u.u_arg
- Réinitialiser le u_error
- savu(u.u_qsav) : on garde un SP vers là où on est dans la fonction trap
- On appelle la fonction noyau

A la sortie de la fonction noyau :

- Checker runrun, swtch() le cas échéant
- Checker les signaux, psig() le cas échéant
- Copier u.u_error dans errno

- On restaure les registres qu'on a sauvegardés avant de passer en mode S.

On revient en mode U (PC vers code U).

L'interruption, ce sera un sous-ensemble :
- TRAP : changement de contexte, déroutement
- Sauvegarde des registres utilisateurs
- Exécution "handler" interruption
- Vérification runrun
- Vérification signaux
- Restauration des registres utilisateurs

#+BEGIN_THEOREM
Quand on réveillé par un signal, on sort du mode noyau : on dépile toute la pile S jusqu'à TRAP, et on sort de TRAP
#+END_THEOREM

Dans les structures rsav, ssav, qsav sont enregistrés des SP qui correspondent à des états différents de quand ils ont été enregistrés (ssav, on l'a déjà vu, sert à enregistrer le SP juste avant de se faire swap).


* TD 6 : 20/11/2019

Petite reprise de l'épisode précédent, on a pu reprendre la fonction swtch().

On traite aujourd'hui de la naissance des processus.

*** Question 1

Modifier le programme pour créer N processus fils. Chaque processus doit incrémenter la variable a, afficher la nouvelle valeur et se terminer. Le processus original attend la fin des N fils puis affiche a avant de se terminer.

On part du principe, même si la consigne ne le précise pas, que le père doit créer les N fils avant de les attendre. On doit avoir, à un point dans le programme, N fils existant en même temps.

Notre solution :

#+BEGIN_SRC c
  #include <stdio.h>
  #include <sys/types.h>
  #include <unistd.h>
  #include <stdlib.h>
  #include <sys/wait.h>

  #define N 10

  int main(int argc, char *argv[])
  {
	  int a = 10;

	  for (int i = 0; i < N; ++i) {
		  if (fork() == 0) {
			  ++a;
			  printf("%d\n", a);
			  exit();
		  }
	  }

	  for (int i = 0; i < N; ++i) {
		  wait();
		  printf("%d\n", a);
	  }

	  return 0;
  }
#+END_SRC

Quelles sont les valeurs affichées pour chacun des processus ?

11 : Chaque fils incrémente sa propre version de la variable a.

Le père affiche par contre systématiquement 10. C'est sa propre version de la variable a qu'il regarde, et celle-ci n'a été modifiée par personne.

*** Question 2

Le mystère de swtch() et de newproc() est enfin éclairci.

Le mécanisme de création des nouveaux processus détaillé.

[à reprendre correctement, en bon français]

[reprendre aussi le cas du swap]

*** Question perso

Implémenter le code de wait, selon la spécification POSIX, ou plutôt selon la simplification Lejeune de la spécification POSIX.

La fonction doit :

- Si le processus appelant n'a pas de fils, ni zombie ni vivant (aussi bien prêt que élu que bloqué/endormi), la fonction se termine, l'exécution n'est pas bloquante.
- Si le processus appelant a au moins un fils zombie, indépendemment de son nombre de fils actifs, il écrit la valeur de retour de son fils (le premier dans l'ordre de la table des processus) dans le pointeur qui lui a été passé en paramètre (si aucun pointeur ne lui a été passé en paramètre, il écrit la valeur de retour du fils dans le pointeur NULL, c'est-à-dire dans le vide [à vérifier : est-ce qu'on est sûr qu'écrire dans le pointeur NULL est un comportement défini ?]), il libère le bloc dans lequel la structure u du zombie a été stockée lors du exit() du fils, il libère l'entrée correspondant à la structure p du fils, et il retourne enfin le pid du fils. Dans ce cas, la fonction se termine, l'exécution n'est pas bloquante.
- Si le processus appelant n'a pas de fils zombie, mais au moins un fils vivant, l'exécution est bloquante : le processus appelant s'endort, jusqu'à ce que son fils devienne zombie, moment auquel il reprend l'alternative 2.

Voilà notre solution : elle est a priori assurée de fonctionner (l'éventuel comportement indéfini mentionné plus haut à peu près).

On n'est pas très content de parcourir deux fois la table des processus, une fois pour compter, une fois pour nettoyer.

La fonction utilise un goto, *ce qui n'est pas un problème*.

#+BEGIN_SRC c
  wait()
  {
	  struct proc *p;
	  struct u *oldu;
	  int nfv = 0;
	  int nfz = 0;
	  int *status = u.u_arg[0];

	  for (p = &proc[0]; p != &proc[NPROC]; p++) {
		  if ((p.p_stat & SZOMB) &&
		      (u.u_procp->pid == p.p_ppid)) {
			  nfz++;
		  }

		  if ((p.p_stat & SRUN) &&
		      (u.u_procp->pid == p.p_ppid)) {
			  nfv++;
		  }
	  }

	  if ((nfv == 0) && (nfz == 0)) {
		  u.u_ar0[R0] = -1;
		  return;
	  }

  rm:
	  if ((nfz > 0)) {
		  for (p = &proc[0]; p != &proc[NPROC]; p++) {
			  if ((p.p_stat & SZOMB) &&
			      (u.u_procp->pid == p.p_ppid)) {
				  oldu = bread(swapdev,p->p_addr);
				  ,*status = oldu->b_addr->u_arg[0];
				  mfree(swapmap,1,p->p_addr);
				  brelse(oldu);
				  p.p_stat = NULL;
				  u.u_ar0[R0] = p.pid;
				  return;
			  }
		  }
	  }

	  sleep(u.u_procp,PWAIT);

	  goto rm;
  }
#+END_SRC



* Annexes

Les supports de TD :

[[./TDTME.pdf][TD]]


